<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>苗の博</title>
  
  <subtitle>无迹方知时光逝，有梦不觉人生寒</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-07-15T08:29:13.512Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>禾田</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>HashMap源码解析</title>
    <link href="http://yoursite.com/2018/07/15/HashMap%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>http://yoursite.com/2018/07/15/HashMap源码解析/</id>
    <published>2018-07-15T08:28:00.000Z</published>
    <updated>2018-07-15T08:29:13.512Z</updated>
    
    <content type="html"><![CDATA[<h3 id="对于HashMap需要掌握以下几点"><a href="#对于HashMap需要掌握以下几点" class="headerlink" title="对于HashMap需要掌握以下几点"></a>对于HashMap需要掌握以下几点</h3><ul><li>Map的创建：HashMap()</li><li>往Map中添加键值对：即put(Object key, Object value)方法</li><li>获取Map中的单个对象：即get(Object key)方法</li></ul><p>下面结合源码看看hashmap的原理：</p><h3 id="构建HashMap"><a href="#构建HashMap" class="headerlink" title="构建HashMap"></a>构建HashMap</h3><p>源码中关键的一些属性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 默认的初始化容量（必须是2的次方） java8中都改成了位运算，提高运算效率</span><br><span class="line">static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4;   </span><br><span class="line">// 最大指定容量为2的30次方</span><br><span class="line">static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30; </span><br><span class="line">// 默认的加载因子（用于resize）</span><br><span class="line">static final float DEFAULT_LOAD_FACTOR = 0.75f;    </span><br><span class="line">// Node数组（数组容量必须是2的多少次方，若不足必要会扩容resize）--这就是HashMap的底层数据结构</span><br><span class="line">transient Node&lt;K,V&gt;[] table;</span><br><span class="line">// 该map中存放的key-value对个数，该个数决定了数组的扩容（而非table中的所占用的桶的个数来决定是否扩容）</span><br><span class="line">transient int size;        </span><br><span class="line">// 扩容resize的条件:eg.capacity=16,load_factor=0.75,threshold=capacity*load_factor=12,即当该map中存放的key-value对个数size&gt;=12时，就resize）</span><br><span class="line">int threshold;        </span><br><span class="line">// 负载因子（用于resize）</span><br><span class="line">final float loadFactor;    </span><br><span class="line">// 标志位，用于标识并发问题，主要用于迭代的快速失败（在迭代过程中，如果发生了put（添加而不是更新的时候）、remove操作，该值发生变化，快速失败）</span><br><span class="line">transient volatile int modCount;</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>map中存放的key-value对个数size，该个数决定了数组的扩容（size&gt;=threshold时，扩容），而非table中的所占用的桶的个数来决定是否扩容</li><li>标志位modCount采用volatile实现该变量的线程可见性（之后会在”Java并发”章节中去讲）</li><li>数组中的桶，指的就是table[i]</li><li>threshold默认为0.75，这是综合时间和空间的利用率来考虑的，通常不要变，如果该值过大，可能会造成链表太长，导致get、put等操作缓慢；如果太小，空间利用率不足。</li><li>容量（必须是2的次方）是为了方便后面定位hash桶的位置的时候进行取模运算</li></ul><p>无参构造器（也是当下最常用的构造器）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 构造一个空的hashMap，设置默认初始化容量为16和默认负载因子为0.75</span><br><span class="line"> */</span><br><span class="line">public HashMap() &#123;</span><br><span class="line">    this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于hashmap而言，还有两个比较常用的构造器，一个双参，一个单参。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public HashMap(int initialCapacity, float loadFactor) &#123;</span><br><span class="line">    // 一些边界条件判断</span><br><span class="line">    if (initialCapacity &lt; 0)</span><br><span class="line">        throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; +</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    if (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))</span><br><span class="line">        throw new IllegalArgumentException(&quot;Illegal load factor: &quot; +</span><br><span class="line">                                           loadFactor);</span><br><span class="line">    this.loadFactor = loadFactor;</span><br><span class="line">    this.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 获取cap的下一个2的n次幂的数（这个算法有兴趣可以研究下，涉及到位运算的一些技巧）</span><br><span class="line">static final int tableSizeFor(int cap) &#123;</span><br><span class="line">    int n = cap - 1;</span><br><span class="line">    n |= n &gt;&gt;&gt; 1;</span><br><span class="line">    n |= n &gt;&gt;&gt; 2;</span><br><span class="line">    n |= n &gt;&gt;&gt; 4;</span><br><span class="line">    n |= n &gt;&gt;&gt; 8;</span><br><span class="line">    n |= n &gt;&gt;&gt; 16;</span><br><span class="line">    return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 指定初始容量</span><br><span class="line"> */</span><br><span class="line">public HashMap(int initialCapacity) &#123;</span><br><span class="line">    // 会调用上边的双参构造器</span><br><span class="line">    this(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>利用上述两个构造器构造出的数组容量不一定是指定的初始化容量，而是一个刚刚大于指定初始化容量的2的几次方的一个值。</li><li>在实际使用中，若我们能预判所要存储的元素的多少，最好使用上述的单参构造器来指定初始容量，这样的话，就可以避免就来扩容时带来的消耗（这一点与ArrayList一样）。</li><li>table的初始化是在resize中进行的，这个和java7中的初始化逻辑不一样。后面会具体说。</li></ul><p>从结构实现来讲，HashMap是数组+链表+红黑树（JDK1.8增加了红黑树部分）实现的，如下如所示：</p><p><img src="http://owq01tqh9.bkt.clouddn.com/hashmap%E7%BB%93%E6%9E%84.jpg" alt="image"></p><p>HashMap的底层数据结构是一个Node[]，Node是HashMap的一个内部类，源代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;</span><br><span class="line">    final int hash;</span><br><span class="line">    final K key;</span><br><span class="line">    V value;</span><br><span class="line">    // 该Node的下一个Node（hash冲突时，形成链表）</span><br><span class="line">    Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">    Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        this.hash = hash;</span><br><span class="line">        this.key = key;</span><br><span class="line">        this.value = value;</span><br><span class="line">        this.next = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public final K getKey()        &#123; return key; &#125;</span><br><span class="line">    public final V getValue()      &#123; return value; &#125;</span><br><span class="line">    public final String toString() &#123; return key + &quot;=&quot; + value; &#125;</span><br><span class="line"></span><br><span class="line">    public final int hashCode() &#123;</span><br><span class="line">        return Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public final V setValue(V newValue) &#123;</span><br><span class="line">        V oldValue = value;</span><br><span class="line">        value = newValue;</span><br><span class="line">        return oldValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public final boolean equals(Object o) &#123;</span><br><span class="line">        if (o == this)</span><br><span class="line">            return true;</span><br><span class="line">        if (o instanceof Map.Entry) &#123;</span><br><span class="line">            Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">            if (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class="line">                Objects.equals(value, e.getValue()))</span><br><span class="line">                return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 在hashmap中可以存放null键和null值</span><br><span class="line">public static boolean equals(Object a, Object b) &#123;</span><br><span class="line">    return (a == b) || (a != null &amp;&amp; a.equals(b));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>注意： </p><ul><li>Node是一个节点，在其中还保存了下一个Node的引用（用来解决put时的hash冲突问题），这样的话，我们可以把hashmap看作是”一个链表数组”</li><li>Node类中的equals()方法会在get(Object key)中使用</li></ul><h3 id="put-Object-key-Object-value"><a href="#put-Object-key-Object-value" class="headerlink" title="put(Object key, Object value)"></a>put(Object key, Object value)</h3><p>put流程图：</p><p><img src="http://owq01tqh9.bkt.clouddn.com/hashmap%E7%9A%84put%E6%B5%81%E7%A8%8B" alt="image"></p><ol><li><p>判断键值对数组table[i]是否为空或为null，否则执行resize()进行扩容；</p></li><li><p>根据键值key计算hash值得到插入的数组索引i，如果table[i]==null，直接新建节点添加，转向6，如果table[i]不为空，转向3；</p></li><li><p>判断table[i]的首个元素是否和key一样，如果相同直接覆盖value，否则转向4，这里的相同指的是hashCode以及equals；</p></li><li><p>判断table[i] 是否为treeNode，即table[i] 是否是红黑树，如果是红黑树，则直接在树中插入键值对，否则转向5；</p></li><li><p>遍历table[i]，判断链表长度是否大于8，大于8的话把链表转换为红黑树，在红黑树中执行插入操作，否则进行链表的插入操作；遍历过程中若发现key已经存在直接覆盖value即可；</p></li><li><p>插入成功后，判断实际存在的键值对数量size是否超多了最大容量threshold，如果超过，进行扩容。</p></li></ol><p>源代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">      // 对key的hashCode()做hash</span><br><span class="line">      return putVal(hash(key), key, value, false, true);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">final V putVal(int hash, K key, V value, boolean onlyIfAbsent,</span><br><span class="line">                boolean evict) &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;</span><br><span class="line">    // 步骤1：tab为空则创建</span><br><span class="line">    if ((tab = table) == null || (n = tab.length) == 0)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    // 步骤2：计算index，并对null做处理 </span><br><span class="line">    if ((p = tab[i = (n - 1) &amp; hash]) == null) </span><br><span class="line">        tab[i] = newNode(hash, key, value, null);</span><br><span class="line">    else &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        // 步骤3：节点key存在，直接覆盖value</span><br><span class="line">        if (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        // 步骤4：判断该链为红黑树</span><br><span class="line">        else if (p instanceof TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);</span><br><span class="line">        // 步骤5：该链为链表</span><br><span class="line">        else &#123;</span><br><span class="line">            for (int binCount = 0; ; ++binCount) &#123;</span><br><span class="line">                // 如果没找到则将节点添加到链表最后面</span><br><span class="line">                if ((e = p.next) == null) &#123;</span><br><span class="line">                    p.next = newNode(hash, key,value,null);</span><br><span class="line">                    //链表长度大于8转换为红黑树进行处理</span><br><span class="line">                    if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st  </span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                // key已经存在直接覆盖value</span><br><span class="line">                if (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))                                          </span><br><span class="line">                    break;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        if (e != null) &#123; // existing mapping for key</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            if (!onlyIfAbsent || oldValue == null)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            return oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ++modCount;</span><br><span class="line">    // 步骤6：超过最大容量就扩容</span><br><span class="line">    if (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>hash运算：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">static final int hash(Object key) &#123;</span><br><span class="line">    int h;</span><br><span class="line">    // h = key.hashCode() 为第一步 取hashCode值</span><br><span class="line">    // h ^ (h &gt;&gt;&gt; 16)  为第二步 高位参与运算</span><br><span class="line">    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在JDK1.8的实现中，优化了高位运算的算法，通过hashCode()的高16位异或低16位实现的：(h = k.hashCode()) ^ (h &gt;&gt;&gt; 16)，主要是从速度、功效、质量来考虑的，这么做可以在数组table的length比较小的时候，也能保证考虑到高低Bit都参与到Hash的计算中，同时不会有太大的开销。</p><p>说明：在上述的步骤1中判断tab为空时候，调用了扩容函数resize()</p><p>下面举个例子说明下扩容过程。假设了我们的hash算法就是简单的用key表示。其中的哈希桶数组table的size=2， 所以key = 3、7、5，put顺序依次为3、7、5 。在mod 2以后都冲突在table[1]这里了。这里假设负载因子 loadFactor=1，即当键值对的实际大小size 大于 table的实际大小时进行扩容。接下来的三个步骤是哈希桶数组 resize成4，然后所有的Node重新rehash的过程。</p><p><img src="http://owq01tqh9.bkt.clouddn.com/hashmap%E6%89%A9%E5%AE%B91.jpg" alt="image"></p><p>注意：java8在添加新节点到链表时候是使用的尾插，所以插入顺序和链表遍历顺序是一样的。而java7使用的是头插方式，插入顺序和链表遍历的顺序相反。</p><p>java8对扩容做了些优化。经过观测可以发现，我们使用的是2次幂的扩展(指长度扩为原来2倍)，所以，元素的位置要么是在原位置，要么是在原位置再移动2次幂的位置。看下图可以明白这句话的意思，n为table的长度，图（a）表示扩容前的key1和key2两种key确定索引位置的示例，图（b）表示扩容后key1和key2两种key确定索引位置的示例，其中hash1是key1对应的哈希与高位运算结果。</p><p><img src="http://owq01tqh9.bkt.clouddn.com/hashmap%E6%89%A9%E5%AE%B93.jpg" alt="image"></p><p>元素在重新计算hash之后，因为n变为2倍，那么n-1的mask范围在高位多1bit(红色)，因此新的index就会发生这样的变化：</p><p><img src="http://owq01tqh9.bkt.clouddn.com/hashmap%E6%89%A9%E5%AE%B94.jpg" alt="image"></p><p>因此，我们在扩充HashMap的时候，不需要像JDK1.7的实现那样重新计算hash，只需要看看原来的hash值新增的那个bit是1还是0就好了，是0的话索引没变，是1的话索引变成“原索引+oldCap”，可以看看下图为16扩充为32的resize示意图：</p><p><img src="http://owq01tqh9.bkt.clouddn.com/hashmap%E6%89%A9%E5%AE%B95.jpg" alt="image"></p><p>这个设计确实非常的巧妙，既省去了重新计算hash值的时间，而且同时，由于新增的1bit是0还是1可以认为是随机的，因此resize的过程，均匀的把之前的冲突的节点分散到新的bucket了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">final Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    int oldCap = (oldTab == null) ? 0 : oldTab.length;</span><br><span class="line">    int oldThr = threshold;</span><br><span class="line">    int newCap, newThr = 0;</span><br><span class="line">    if (oldCap &gt; 0) &#123;</span><br><span class="line">        // 如果超过最大值就不再扩充了，就只好随你碰撞去吧</span><br><span class="line">        if (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            return oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        // 没超过最大值，就扩充为原来的2倍</span><br><span class="line">        else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; 1; // double threshold</span><br><span class="line">    &#125;</span><br><span class="line">    else if (oldThr &gt; 0) // initial capacity was placed in threshold</span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    else &#123;               // zero initial threshold signifies using defaults</span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    // 计算新的resize上限</span><br><span class="line">    if (newThr == 0) &#123;</span><br><span class="line">        float ft = (float)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (int)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line">    @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span><br><span class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    if (oldTab != null) &#123;</span><br><span class="line">        // 把每个bucket都移动到新的buckets中</span><br><span class="line">        for (int j = 0; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            if ((e = oldTab[j]) != null) &#123;</span><br><span class="line">                oldTab[j] = null;</span><br><span class="line">                if (e.next == null)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - 1)] = e;</span><br><span class="line">                else if (e instanceof TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);</span><br><span class="line">                else &#123; </span><br><span class="line">                    // 链表优化重hash的代码块，保证链表节点顺序</span><br><span class="line">                    Node&lt;K,V&gt; loHead = null, loTail = null;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = null, hiTail = null;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    do &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        // 原索引</span><br><span class="line">                        if ((e.hash &amp; oldCap) == 0) &#123;</span><br><span class="line">                            if (loTail == null)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            else</span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        // 原索引+oldCap</span><br><span class="line">                        else &#123;</span><br><span class="line">                            if (hiTail == null)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            else</span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; while ((e = next) != null);</span><br><span class="line">                    // 原索引放到bucket里</span><br><span class="line">                    if (loTail != null) &#123;</span><br><span class="line">                        loTail.next = null;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (hiTail != null) &#123;</span><br><span class="line">                        hiTail.next = null;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="get-Object-key"><a href="#get-Object-key" class="headerlink" title="get(Object key)"></a>get(Object key)</h3><p>源代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public V get(Object key) &#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    // 在hashmap的结构中查找key值，如果没找到返回null，找到了就返回对应的value值</span><br><span class="line">    return (e = getNode(hash(key), key)) == null ? null : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">final Node&lt;K,V&gt; getNode(int hash, Object key) &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k;</span><br><span class="line">    // 根据hash(key)定位桶的位置</span><br><span class="line">    if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;</span><br><span class="line">        (first = tab[(n - 1) &amp; hash]) != null) &#123;</span><br><span class="line">        // 判断第一个节点是否相同，相同直接返回</span><br><span class="line">        if (first.hash == hash &amp;&amp; // always check first node</span><br><span class="line">            ((k = first.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">            return first;</span><br><span class="line">        // 遍历链表</span><br><span class="line">        if ((e = first.next) != null) &#123;</span><br><span class="line">            // 如果已经调整成红黑树，则遍历红黑树</span><br><span class="line">            if (first instanceof TreeNode)</span><br><span class="line">                return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            do &#123;</span><br><span class="line">                if (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">                    return e;</span><br><span class="line">            &#125; while ((e = e.next) != null);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>HashMap底层就是一个Node数组，Node又包含next，事实上，可以看成是一个”链表数组”,java8还在此基础上增加了红黑树结构</li><li>扩容：map中存放的key-value对个数size，该个数决定了数组的扩容（size&gt;=threshold时，扩容），而非table中的所占用的桶的个数来决定是否扩容</li><li>扩容过程，不会重新计算hash值，只会重新按位与</li><li>在实际使用中，若我们能预判所要存储的元素的多少，最好使用上述的单参构造器来指定初始容量</li><li>HashMap可以插入null的key和value</li><li>HashMap线程不安全（多线程情况下会导致环形链表产生），若想要线程安全，最好使用ConcurrentHashMap</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;对于HashMap需要掌握以下几点&quot;&gt;&lt;a href=&quot;#对于HashMap需要掌握以下几点&quot; class=&quot;headerlink&quot; title=&quot;对于HashMap需要掌握以下几点&quot;&gt;&lt;/a&gt;对于HashMap需要掌握以下几点&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Map的
      
    
    </summary>
    
      <category term="java集合框架源码" scheme="http://yoursite.com/categories/java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="java集合框架源码" scheme="http://yoursite.com/tags/java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>LinkedList源码解析</title>
    <link href="http://yoursite.com/2018/07/12/LinkedList%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>http://yoursite.com/2018/07/12/LinkedList源码解析/</id>
    <published>2018-07-12T11:57:00.000Z</published>
    <updated>2018-07-15T08:25:48.221Z</updated>
    
    <content type="html"><![CDATA[<h3 id="对于LinkedList需要掌握的八点内容"><a href="#对于LinkedList需要掌握的八点内容" class="headerlink" title="对于LinkedList需要掌握的八点内容"></a>对于LinkedList需要掌握的八点内容</h3><ul><li>LinkedList的创建：即构造器</li><li>往LinkedList中添加对象：即add(E)方法</li><li>获取LinkedList中的单个对象：即get(int index)方法</li><li>修改LinkedList中的指定索引的节点的数据set(int index, E element)</li><li>删除LinkedList中的对象：即remove(E)，remove(int index)方法</li><li>遍历LinkedList中的对象：即iterator，在实际中更常用的是增强型的for循环去做遍历</li><li>判断对象是否存在于LinkedList中：contain(E)</li><li>LinkedList中对象的排序：主要取决于所采取的排序算法</li></ul><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><h4 id="LinkedList的创建"><a href="#LinkedList的创建" class="headerlink" title="LinkedList的创建"></a>LinkedList的创建</h4><p>实现方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; strList0 = new LinkedList&lt;String&gt;();</span><br></pre></td></tr></table></figure></p><p>源代码：在读源代码之前，首先要知道什么是环形双向链表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">// 链表大小0</span><br><span class="line">transient int size = 0;</span><br><span class="line">// 双向链表的头结点</span><br><span class="line">transient Node&lt;E&gt; first;</span><br><span class="line">// 双向链表的尾结点</span><br><span class="line">transient Node&lt;E&gt; last;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 构造一个空节点</span><br><span class="line"> */</span><br><span class="line">public LinkedList() &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 链表节点，LinkedList的一个内部类：</span><br><span class="line"> */</span><br><span class="line">private static class Node&lt;E&gt; &#123;</span><br><span class="line">    // 链表存储的数据</span><br><span class="line">    E item;</span><br><span class="line">    // 链表的下一个节点</span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line">    // 链表的上一个节点</span><br><span class="line">    Node&lt;E&gt; prev;</span><br><span class="line"></span><br><span class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">        this.item = element;</span><br><span class="line">        this.next = next;</span><br><span class="line">        this.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="往LinkedList中添加对象（add-E-e-）"><a href="#往LinkedList中添加对象（add-E-e-）" class="headerlink" title="往LinkedList中添加对象（add(E e)）"></a>往LinkedList中添加对象（add(E e)）</h4><p>实现方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strList0.add(&quot;hello&quot;);</span><br></pre></td></tr></table></figure><p>源代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// 在链表的尾部添加新节点，添加成功则返回true</span><br><span class="line">public boolean add(E e) &#123;</span><br><span class="line">    linkLast(e);</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void linkLast(E e) &#123;</span><br><span class="line">    // 临时保存尾节点</span><br><span class="line">    final Node&lt;E&gt; l = last;</span><br><span class="line">    // 把节点添加到双向链表中</span><br><span class="line">    final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null);</span><br><span class="line">    // 令链表尾指针指向新添加的节点</span><br><span class="line">    last = newNode;</span><br><span class="line">    // 如果是空链表</span><br><span class="line">    if (l == null)</span><br><span class="line">        // 则令头指针指向新添加的节点，相当于创建一个新链表头节点</span><br><span class="line">        first = newNode;</span><br><span class="line">    else</span><br><span class="line">        l.next = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    // 保证遍历时候检查链表是否有添加或删除节点</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加过程如下图：</p><p><img src="http://owq01tqh9.bkt.clouddn.com/linkedList%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8.png" alt="image"></p><p>这里，结合着代码注释与图片去看add(E)的源代码就好。</p><p>注意：在添加元素方面LinkedList不需要考虑数组扩容和数组复制，只需要新建一个对象。</p><h4 id="获取LinkedList中的单个对象（get-int-index-）"><a href="#获取LinkedList中的单个对象（get-int-index-）" class="headerlink" title="获取LinkedList中的单个对象（get(int index)）"></a>获取LinkedList中的单个对象（get(int index)）</h4><p>实现方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 注意：下标从0开始</span><br><span class="line">strList.get(0);</span><br></pre></td></tr></table></figure><p>源码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 返回索引值为index节点的数据，index从0开始计算</span><br><span class="line"> */</span><br><span class="line">public E get(int index) &#123;</span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    return node(index).item;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * 判断index是否在合理范围内</span><br><span class="line"> */</span><br><span class="line">private void checkElementIndex(int index) &#123;</span><br><span class="line">    if (!isElementIndex(index))</span><br><span class="line">        throw new IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line">&#125;</span><br><span class="line">private boolean isElementIndex(int index) &#123;</span><br><span class="line">    return index &gt;= 0 &amp;&amp; index &lt; size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 获取指定index索引位置的节点（需要遍历链表）</span><br><span class="line"> */</span><br><span class="line">Node&lt;E&gt; node(int index) &#123;</span><br><span class="line">    // 如果index小于链表大小的半，就从链表头开始遍历，否则从尾部开始遍历</span><br><span class="line">    if (index &lt; (size &gt;&gt; 1)) &#123;</span><br><span class="line">        Node&lt;E&gt; x = first;</span><br><span class="line">        for (int i = 0; i &lt; index; i++)</span><br><span class="line">            x = x.next;</span><br><span class="line">        return x;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        Node&lt;E&gt; x = last;</span><br><span class="line">        for (int i = size - 1; i &gt; index; i--)</span><br><span class="line">            x = x.prev;</span><br><span class="line">        return x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>注意：链表节点的按索引查找，需要遍历链表；而数组不需要。</p><h4 id="修改LinkedList中指定索引的节点的数据：set-int-index-E-element"><a href="#修改LinkedList中指定索引的节点的数据：set-int-index-E-element" class="headerlink" title="修改LinkedList中指定索引的节点的数据：set(int index, E element)"></a>修改LinkedList中指定索引的节点的数据：set(int index, E element)</h4><p>使用方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strList.set(0, &quot;world&quot;);</span><br></pre></td></tr></table></figure><p>源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 修改指定索引位置index上的节点的数据为element</span><br><span class="line"> */</span><br><span class="line">public E set(int index, E element) &#123;</span><br><span class="line">    // 判断index是否在合理范围内</span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    // 获取指定index索引位置的节点（需要遍历链表）</span><br><span class="line">    Node&lt;E&gt; x = node(index);</span><br><span class="line">    // 保存节点旧值</span><br><span class="line">    E oldVal = x.item;</span><br><span class="line">    // 将新值赋给该节点的element属性</span><br><span class="line">    x.item = element;</span><br><span class="line">    // 返回旧值</span><br><span class="line">    return oldVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="删除LinkedList中的对象"><a href="#删除LinkedList中的对象" class="headerlink" title="删除LinkedList中的对象"></a>删除LinkedList中的对象</h4><h5 id="remove-Object-o"><a href="#remove-Object-o" class="headerlink" title="remove(Object o)"></a>remove(Object o)</h5><p>使用方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strList.remove(&quot;world&quot;);</span><br></pre></td></tr></table></figure><p>源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 删除第一个出现的指定元数据为o的节点</span><br><span class="line"> */</span><br><span class="line">public boolean remove(Object o) &#123;</span><br><span class="line">    if (o == null) &#123;</span><br><span class="line">        for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123;</span><br><span class="line">            if (x.item == null) &#123;</span><br><span class="line">                unlink(x);</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123;</span><br><span class="line">            if (o.equals(x.item)) &#123;</span><br><span class="line">                unlink(x);</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * 删除节点逻辑（节点不为空）</span><br><span class="line"> */</span><br><span class="line">E unlink(Node&lt;E&gt; x) &#123;</span><br><span class="line">    final E element = x.item;</span><br><span class="line">    final Node&lt;E&gt; next = x.next;</span><br><span class="line">    final Node&lt;E&gt; prev = x.prev;</span><br><span class="line"></span><br><span class="line">    // 处理待删除节点的前面节点</span><br><span class="line">    if (prev == null) &#123;</span><br><span class="line">        first = next;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        prev.next = next;</span><br><span class="line">        x.prev = null;</span><br><span class="line">    &#125;</span><br><span class="line">    // 处理待删除节点的后面节点</span><br><span class="line">    if (next == null) &#123;</span><br><span class="line">        last = prev;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        next.prev = prev;</span><br><span class="line">        x.next = null;</span><br><span class="line">    &#125;</span><br><span class="line">    x.item = null;</span><br><span class="line">    size--;</span><br><span class="line">    modCount++;</span><br><span class="line">    return element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="remove-int-index"><a href="#remove-int-index" class="headerlink" title="remove(int index)"></a>remove(int index)</h5><p>使用方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strList.remove(0);</span><br></pre></td></tr></table></figure><p>源代码： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 删除指定位置的节点</span><br><span class="line">public E remove(int index) &#123;</span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    return unlink(node(index));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：</p><p>unlink(node(index))见上边</p><h4 id="判断对象是否存在于LinkedList中（contains-E-）"><a href="#判断对象是否存在于LinkedList中（contains-E-）" class="headerlink" title="判断对象是否存在于LinkedList中（contains(E)）"></a>判断对象是否存在于LinkedList中（contains(E)）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 链表中是否包含指定数据o的节点</span><br><span class="line"> */</span><br><span class="line">public boolean contains(Object o) &#123;</span><br><span class="line">    return indexOf(o) != -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 从链表头开始，查找第一个出现o的索引</span><br><span class="line"> */</span><br><span class="line">public int indexOf(Object o) &#123;</span><br><span class="line">    int index = 0;</span><br><span class="line">    if (o == null) &#123;</span><br><span class="line">        for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123;</span><br><span class="line">            if (x.item == null)</span><br><span class="line">                return index;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123;</span><br><span class="line">            if (o.equals(x.item))</span><br><span class="line">                return index;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：indexOf(Object o)返回第一个出现的元素o的索引</p><h4 id="遍历LinkedList中的对象（iterator-）"><a href="#遍历LinkedList中的对象（iterator-）" class="headerlink" title="遍历LinkedList中的对象（iterator()）"></a>遍历LinkedList中的对象（iterator()）</h4><p>使用方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; strList = new LinkedList&lt;String&gt;();</span><br><span class="line">strList.add(&quot;jigang&quot;);</span><br><span class="line">strList.add(&quot;nana&quot;);</span><br><span class="line">strList.add(&quot;nana2&quot;);</span><br><span class="line"></span><br><span class="line">Iterator&lt;String&gt; it = strList.iterator();</span><br><span class="line">while (it.hasNext()) &#123;</span><br><span class="line">    System.out.println(it.next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>源代码：iterator()方法是在父类AbstractSequentialList中实现的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public Iterator&lt;E&gt; iterator() &#123;</span><br><span class="line">    return listIterator();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>listIterator()方法是在父类AbstractList中实现的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public ListIterator&lt;E&gt; listIterator() &#123;</span><br><span class="line">    return listIterator(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>listIterator(int index)方法是在父类AbstractList中实现的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public ListIterator&lt;E&gt; listIterator(final int index) &#123;</span><br><span class="line">    if (index &lt; 0 || index &gt; size())</span><br><span class="line">        throw new IndexOutOfBoundsException(&quot;Index: &quot; + index);</span><br><span class="line"></span><br><span class="line">    return new ListItr(index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法返回AbstractList的一个内部类ListItr对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">private class ListItr extends Itr implements ListIterator&lt;E&gt; &#123;</span><br><span class="line">    ListItr(int index) &#123;</span><br><span class="line">        cursor = index;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>上边这个类并不完整，它继承了内部类Itr，还扩展了一些其他方法（eg.向前查找方法hasPrevious()等），至于hasNext()/next()等方法还是来自于Itr的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">private class Itr implements Iterator&lt;E&gt; &#123;</span><br><span class="line">    //标记位：标记遍历到哪一个元素</span><br><span class="line">    int cursor = 0;</span><br><span class="line">    //标记位：用于判断是否在遍历的过程中，是否发生了add、remove操作</span><br><span class="line">    int expectedModCount = modCount;</span><br><span class="line">    //检测对象数组是否还有元素</span><br><span class="line">    public boolean hasNext() &#123;</span><br><span class="line">        //如果cursor==size，说明已经遍历完了，上一次遍历的是最后一个元素</span><br><span class="line">        return cursor != size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //获取元素</span><br><span class="line">    public E next() &#123;</span><br><span class="line">        //检测在遍历的过程中，是否发生了add、remove操作</span><br><span class="line">        checkForComodification();</span><br><span class="line">        try &#123;</span><br><span class="line">            E next = get(cursor++);</span><br><span class="line">            return next;</span><br><span class="line">            //捕获get(cursor++)方法的IndexOutOfBoundsException</span><br><span class="line">        &#125; catch (IndexOutOfBoundsException e) &#123;</span><br><span class="line">            checkForComodification();</span><br><span class="line">            throw new NoSuchElementException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //检测在遍历的过程中，是否发生了add、remove等操作</span><br><span class="line">    final void checkForComodification() &#123;</span><br><span class="line">        //发生了add、remove操作,这个我们可以查看add等的源代码，发现会出现modCount++</span><br><span class="line">        if (modCount != expectedModCount)</span><br><span class="line">            throw new ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：上述的Itr我去掉了一个此时用不到的方法和属性。这里的get(int index)方法参照2.3所示。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>LinkedList基于环形双向链表方式实现，无容量的限制</li><li>添加元素时不用扩容（直接创建新节点，调整插入节点的前后节点的指针属性的指向即可）</li><li>线程不安全</li><li>get(int index)：需要遍历链表</li><li>remove(Object o)需要遍历链表</li><li>remove(int index)需要遍历链表</li><li>contains(E)需要遍历链表</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;对于LinkedList需要掌握的八点内容&quot;&gt;&lt;a href=&quot;#对于LinkedList需要掌握的八点内容&quot; class=&quot;headerlink&quot; title=&quot;对于LinkedList需要掌握的八点内容&quot;&gt;&lt;/a&gt;对于LinkedList需要掌握的八点内容&lt;/
      
    
    </summary>
    
      <category term="java集合框架源码 " scheme="http://yoursite.com/categories/java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="java集合框架源码 " scheme="http://yoursite.com/tags/java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>ArrayList源码解析</title>
    <link href="http://yoursite.com/2018/07/11/ArrayList%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>http://yoursite.com/2018/07/11/ArrayList源码解析/</id>
    <published>2018-07-11T07:00:00.000Z</published>
    <updated>2018-07-11T11:50:23.071Z</updated>
    
    <content type="html"><![CDATA[<h2 id="对于ArrayList需要掌握的七点内容"><a href="#对于ArrayList需要掌握的七点内容" class="headerlink" title="对于ArrayList需要掌握的七点内容"></a>对于ArrayList需要掌握的七点内容</h2><ul><li>ArrayList的创建：即构造器  </li><li>往ArrayList中添加对象：即add(E)方法  </li><li>获取ArrayList中的单个对象：即get(int index)方法  </li><li>删除ArrayList中的对象：即remove(E)方法  </li><li>遍历ArrayList中的对象：即iterator，在实际中更常用的是增强型的for循环去做遍历  </li><li>判断对象是否存在于ArrayList中：contain(E)  </li><li>ArrayList中对象的排序：主要取决于所采取的排序算法  </li></ul><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="ArrayList的创建（常见的两种方式）"><a href="#ArrayList的创建（常见的两种方式）" class="headerlink" title="ArrayList的创建（常见的两种方式）"></a>ArrayList的创建（常见的两种方式）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; strList = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">List&lt;String&gt; strList2 = <span class="keyword">new</span> ArrayList&lt;String&gt;(<span class="number">5</span>);</span><br></pre></td></tr></table></figure><p>ArrayList源代码：</p><p>基本属性：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对象数组：ArrayList的底层数据结构</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Object[] elementData;</span><br><span class="line"><span class="comment">//elementData中已存放的元素的个数，注意：不是elementData的容量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size;</span><br></pre></td></tr></table></figure></p><p>注意：</p><ul><li>transient关键字的作用：在采用Java默认的序列化机制的时候，被该关键字修饰的属性不会被序列化。  </li><li>ArrayList类实现了java.io.Serializable接口，即采用了Java默认的序列化机制  </li><li>上面的elementData属性采用了transient来修饰，表明其不使用Java默认的序列化机制来实例化，但是该属性是ArrayList的底层数据结构，在网络传输中一定需要将其序列化，之后使用的时候还需要反序列化，那不采用Java默认的序列化机制，那采用什么呢？直接翻到源码的最下边有两个方法，发现ArrayList自己实现了序列化和反序列化的方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Save the state of the &lt;tt&gt;ArrayList&lt;/tt&gt; instance to a stream (that</span></span><br><span class="line"><span class="comment"> * is, serialize it).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@serialData</span> The length of the array backing the &lt;tt&gt;ArrayList&lt;/tt&gt;</span></span><br><span class="line"><span class="comment"> *             instance is emitted (int), followed by all of its elements</span></span><br><span class="line"><span class="comment"> *             (each an &lt;tt&gt;Object&lt;/tt&gt;) in the proper order.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> java.io.IOException</span>&#123;</span><br><span class="line">    <span class="comment">// Write out element count, and any hidden stuff</span></span><br><span class="line">    <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line">    s.defaultWriteObject();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Write out size as capacity for behavioural compatibility with clone()</span></span><br><span class="line">    s.writeInt(size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Write out all elements in the proper order.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</span><br><span class="line">        s.writeObject(elementData[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Reconstitute the &lt;tt&gt;ArrayList&lt;/tt&gt; instance from a stream (that is,</span></span><br><span class="line"><span class="comment"> * deserialize it).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> java.io.IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">    elementData = EMPTY_ELEMENTDATA;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read in size, and any hidden stuff</span></span><br><span class="line">    s.defaultReadObject();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read in capacity</span></span><br><span class="line">    s.readInt(); <span class="comment">// ignored</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// be like clone(), allocate array based upon size not capacity</span></span><br><span class="line">        <span class="keyword">int</span> capacity = calculateCapacity(elementData, size);</span><br><span class="line">        SharedSecrets.getJavaOISAccess().checkArray(s, Object[].class, capacity);</span><br><span class="line">        ensureCapacityInternal(size);</span><br><span class="line"></span><br><span class="line">        Object[] a = elementData;</span><br><span class="line">        <span class="comment">// Read in all elements in the proper order.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</span><br><span class="line">            a[i] = s.readObject();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 创建一个容量为initialCapacity的空的（size==0）对象数组</span><br><span class="line"> */</span><br><span class="line">public ArrayList(int initialCapacity) &#123;</span><br><span class="line">    if (initialCapacity &gt; 0) &#123;</span><br><span class="line">        this.elementData = new Object[initialCapacity];</span><br><span class="line">    &#125; else if (initialCapacity == 0) &#123;</span><br><span class="line">        this.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;Illegal Capacity: &quot; + initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 默认初始化一个容量为10的对象数组(java8之前)</span><br><span class="line"> */</span><br><span class="line">public ArrayList() &#123;</span><br><span class="line">    //即上边的public ArrayList(int initialCapacity)&#123;&#125;构造器</span><br><span class="line">    this(10);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 默认初始化一个空数组(java8)，在java8中，在第一次add方法中会调用ensureExplicitCapac * ity方法把容量初始化为10，效果同上面一样  </span><br><span class="line"> */</span><br><span class="line">private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line">public ArrayList() &#123;</span><br><span class="line">    this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在我们执行new ArrayList\&lt;String>()时，会调用上边的无参构造器，创造一个容量为10的对象数组。<br>在我们执行new ArrayList\&lt;String>(5)时，会调用上边的public ArrayList(int initialCapacity)，创造一个容量为5的对象数组。</p><p>在实际使用中，如果我们能对所需的ArrayList的大小进行判断，有两个好处：</p><ul><li>节省内存空间（eg.我们只需要放置两个元素到数组，new ArrayList<string>(2)）</string></li><li>避免数组扩容（下边会讲）引起的效率下降（eg.我们只需要放置大约37个元素到数组，new ArrayList<string>(40)）</string></li></ul><h3 id="往ArrayList中添加对象（常见的两个方法add-E-和addAll-Collection-lt-extends-E-gt-c-）"><a href="#往ArrayList中添加对象（常见的两个方法add-E-和addAll-Collection-lt-extends-E-gt-c-）" class="headerlink" title="往ArrayList中添加对象（常见的两个方法add(E)和addAll(Collection&lt;? extends E&gt; c)）"></a>往ArrayList中添加对象（常见的两个方法add(E)和addAll(Collection&lt;? extends E&gt; c)）</h3><h4 id="add-E"><a href="#add-E" class="headerlink" title="add(E)"></a>add(E)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strList.add(&quot;hello&quot;);</span><br></pre></td></tr></table></figure><p>ArrayList源代码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 向elementData中添加元素</span><br><span class="line"> */</span><br><span class="line">public boolean add(E e) &#123;</span><br><span class="line">    //确保对象数组elementData有足够的容量，可以将新加入的元素e加进去</span><br><span class="line">    ensureCapacityInternal(size + 1);</span><br><span class="line">    //加入新元素e，size加1</span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//确保对象数组elementData有足够的容量</span><br><span class="line">private void ensureCapacityInternal(int minCapacity) &#123;</span><br><span class="line">    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 计算数组容量，保证初始化容量为10</span><br><span class="line">private static int calculateCapacity(Object[] elementData, int minCapacity) &#123;</span><br><span class="line">    if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        return Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    return minCapacity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 保证有足够容量</span><br><span class="line">private void ensureExplicitCapacity(int minCapacity) &#123;</span><br><span class="line">    // modCount变量用于在遍历集合（iterator()）时，检测是否发生了add、remove操作。</span><br><span class="line">    modCount++;</span><br><span class="line">    // 如果容量不够则扩容</span><br><span class="line">    if (minCapacity - elementData.length &gt; 0)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 扩容逻辑</span><br><span class="line">private void grow(int minCapacity) &#123;</span><br><span class="line">    // 原始容量大小</span><br><span class="line">    int oldCapacity = elementData.length;</span><br><span class="line">    // 容量扩大1.5倍</span><br><span class="line">    int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);</span><br><span class="line">    if (newCapacity - minCapacity &lt; 0)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    // 如果超出最大值，则设置为最大值</span><br><span class="line">    if (newCapacity - MAX_ARRAY_SIZE &gt; 0)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在上述代码的扩容结束后，调用了Arrays.copyOf(elementData, newCapacity)方法，这个方法中：对于我们这里而言，先创建了一个新的容量为newCapacity的对象数组，然后使用System.arraycopy()方法将旧的对象数组复制到新的对象数组中去了。</p><p>注意：modCount变量用于在遍历集合（iterator()）时，检测是否发生了add、remove操作。</p><h4 id="addAll-Collection-lt-extends-E-gt-c"><a href="#addAll-Collection-lt-extends-E-gt-c" class="headerlink" title="addAll(Collection&lt;? extends E&gt; c)"></a>addAll(Collection&lt;? extends E&gt; c)</h4><p>使用方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; strList = new ArrayList&lt;String&gt;();</span><br><span class="line">strList.add(&quot;jigang&quot;);</span><br><span class="line">strList.add(&quot;nana&quot;);</span><br><span class="line">strList.add(&quot;nana2&quot;);</span><br><span class="line"></span><br><span class="line">List&lt;String&gt; strList2 = new ArrayList&lt;String&gt;(2);</span><br><span class="line">strList2.addAll(strList);</span><br></pre></td></tr></table></figure><p>源代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 将c全部加入elementData</span><br><span class="line"> */</span><br><span class="line">public boolean addAll(Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">    // 将c集合转化为对象数组a</span><br><span class="line">    Object[] a = c.toArray();</span><br><span class="line">    // 获取a对象数组的容量</span><br><span class="line">    int numNew = a.length;</span><br><span class="line">    // 确保对象数组elementData有足够的容量，可以将新加入的a对象数组加进去</span><br><span class="line">    ensureCapacityInternal(size + numNew);</span><br><span class="line">    //将对象数组a拷贝到elementData中去</span><br><span class="line">    System.arraycopy(a, 0, elementData, size, numNew);</span><br><span class="line">    // 重新设置elementData中已加入的元素的个数</span><br><span class="line">    size += numNew;</span><br><span class="line">    // 若加入的是空集合则返回false</span><br><span class="line">    return numNew != 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意:</p><ul><li>从上述代码可以看出，若加入的c是空集合，则返回false</li><li>ensureCapacity(size + numNew);这个方法在上边用过</li><li>System.arraycopy()方法定义如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public static native void arraycopy(Object src,  int  srcPos, Object dest, int destPos,  int length);</span><br></pre></td></tr></table></figure></li></ul><p>将数组src从下标为srcPos开始拷贝，一直拷贝length个元素到dest数组中，在dest数组中从destPos开始加入先的srcPos数组元素。</p><p>除了以上两种常用的add方法外，还有如下两种：</p><h4 id="add-int-index-E-element"><a href="#add-int-index-E-element" class="headerlink" title="add(int index, E element)"></a>add(int index, E element)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 在特定位置（只能是已有元素的数组的特定位置）index插入元素E</span><br><span class="line"> */</span><br><span class="line">public void add(int index, E element) &#123;</span><br><span class="line">    // 检查index是否在已有的数组中</span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line">    // 确保对象数组elementData有足够的容量，可以将新加入的元素e加进去</span><br><span class="line">    ensureCapacityInternal(size + 1); </span><br><span class="line">    // 将index及其后边的所有的元素整块后移，空出index位置</span><br><span class="line">    System.arraycopy(elementData, index, elementData, index + 1,</span><br><span class="line">                     size - index);</span><br><span class="line">    // 插入元素</span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    // 已有数组元素个数+1</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 检查index是否在已有的数组中</span><br><span class="line"> */</span><br><span class="line">private void rangeCheckForAdd(int index) &#123;</span><br><span class="line">    if (index &gt; size || index &lt; 0)</span><br><span class="line">        throw new IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：index&lt;=size才行，并不是index&lt;elementData.length</p><h4 id="set-int-index-E-element"><a href="#set-int-index-E-element" class="headerlink" title="set(int index, E element)"></a>set(int index, E element)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 更换特定位置index上的元素为element，返回该位置上的旧值</span><br><span class="line"> */</span><br><span class="line">public E set(int index, E element) &#123;</span><br><span class="line">    // 检查index是否在已有的数组中</span><br><span class="line">    rangeCheck(index);</span><br><span class="line">    // 旧值</span><br><span class="line">    E oldValue = elementData(index);</span><br><span class="line">    // 该位置替换为新值</span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    // 返回旧值 </span><br><span class="line">    return oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="获取ArrayList中的单个对象（get-int-index-）"><a href="#获取ArrayList中的单个对象（get-int-index-）" class="headerlink" title="获取ArrayList中的单个对象（get(int index)）"></a>获取ArrayList中的单个对象（get(int index)）</h3><p>实现方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; strList2 = new ArrayList&lt;String&gt;(2);</span><br><span class="line">strList2.add(&quot;hello&quot;);</span><br><span class="line">strList2.add(&quot;nana&quot;);</span><br><span class="line">strList2.add(&quot;nana2&quot;);</span><br><span class="line">System.out.println(strList2.get(0));</span><br></pre></td></tr></table></figure><p>源代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 按照索引查询对象E</span><br><span class="line"> */</span><br><span class="line">public E get(int index) &#123;</span><br><span class="line">    RangeCheck(index);//检查索引范围</span><br><span class="line">    return (E) elementData[index];//返回元素，并将Object转型为E</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 检查索引index是否超出size-1</span><br><span class="line"> */</span><br><span class="line">private void RangeCheck(int index) &#123;</span><br><span class="line">    if (index &gt;= size)</span><br><span class="line">        throw new IndexOutOfBoundsException(&quot;Index:&quot;+index+&quot;,Size:&quot;+size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：这里对index进行了索引检查，是为了将异常内容写的详细一些并且将检查的内容缩小（index &lt; 0 || index &gt;= size，注意这里的size是已存储元素的个数）；<br>事实上不检查也可以，因为对于数组而言，如果index不满足要求（index &lt; 0 || index &gt; = length，注意这里的length是数组的容量）,都会直接抛出数组越界异常，而假设数组的length为10，当前的size是2，你去计算array[9]，这时候得出是null，这也是上边get为什么减小检查范围的原因。</p><h3 id="删除ArrayList中的对象"><a href="#删除ArrayList中的对象" class="headerlink" title="删除ArrayList中的对象"></a>删除ArrayList中的对象</h3><h4 id="remove-Object-o"><a href="#remove-Object-o" class="headerlink" title="remove(Object o)"></a>remove(Object o)</h4><p>使用方式： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strList2.remove(&quot;hello&quot;);</span><br></pre></td></tr></table></figure><p>源代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 从前向后移除第一个出现的元素o</span><br><span class="line"> */</span><br><span class="line">public boolean remove(Object o) &#123;</span><br><span class="line">    //移除对象数组elementData中的第一个null</span><br><span class="line">    if (o == null) &#123;</span><br><span class="line">        for (int index = 0; index &lt; size; index++)</span><br><span class="line">            if (elementData[index] == null) &#123;</span><br><span class="line">                fastRemove(index);</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">    //移除对象数组elementData中的第一个o</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        for (int index = 0; index &lt; size; index++)</span><br><span class="line">            if (o.equals(elementData[index])) &#123;</span><br><span class="line">                fastRemove(index);</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * 删除单个位置的元素，是ArrayList的私有方法</span><br><span class="line"> */</span><br><span class="line">private void fastRemove(int index) &#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    int numMoved = size - index - 1;</span><br><span class="line">    //删除的不是最后一个元素</span><br><span class="line">    if (numMoved &gt; 0)</span><br><span class="line">        //删除的元素到最后的元素整块前移</span><br><span class="line">        System.arraycopy(elementData, index + 1, elementData, index,numMoved);</span><br><span class="line">    //将最后一个元素设为null，在下次gc的时候就会回收掉了</span><br><span class="line">    elementData[--size] = null; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="remove-int-index"><a href="#remove-int-index" class="headerlink" title="remove(int index)"></a>remove(int index)</h4><p>使用方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strList2.remove(0);</span><br></pre></td></tr></table></figure><p>源代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 删除指定索引index下的元素，返回被删除的元素</span><br><span class="line"> */</span><br><span class="line">public E remove(int index) &#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line">    modCount++;</span><br><span class="line">    E oldValue = elementData(index);</span><br><span class="line"></span><br><span class="line">    int numMoved = size - index - 1;</span><br><span class="line">    if (numMoved &gt; 0)</span><br><span class="line">        System.arraycopy(elementData, index+1, elementData, index,</span><br><span class="line">                         numMoved);</span><br><span class="line">    elementData[--size] = null; </span><br><span class="line">    return oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：<br>remove(Object o)需要遍历数组，remove(int index)不需要，只需要判断索引符合范围即可，所以，通常：后者效率更高。</p><h3 id="判断对象是否存在于ArrayList中（contains-E-）"><a href="#判断对象是否存在于ArrayList中（contains-E-）" class="headerlink" title="判断对象是否存在于ArrayList中（contains(E)）"></a>判断对象是否存在于ArrayList中（contains(E)）</h3><p>源代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 判断动态数组是否包含元素o</span><br><span class="line"> */</span><br><span class="line">public boolean contains(Object o) &#123;</span><br><span class="line">    return indexOf(o) &gt;= 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 返回第一个出现的元素o的索引位置</span><br><span class="line"> */</span><br><span class="line">public int indexOf(Object o) &#123;</span><br><span class="line">    if (o == null) &#123;//返回第一个null的索引</span><br><span class="line">        for (int i = 0; i &lt; size; i++)</span><br><span class="line">            if (elementData[i] == null)</span><br><span class="line">                return i;</span><br><span class="line">    &#125; else &#123;//返回第一个o的索引</span><br><span class="line">        for (int i = 0; i &lt; size; i++)</span><br><span class="line">            if (o.equals(elementData[i]))</span><br><span class="line">                return i;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;//若不包含，返回-1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 返回最后一个出现的元素o的索引位置</span><br><span class="line"> */</span><br><span class="line">public int lastIndexOf(Object o) &#123;</span><br><span class="line">    if (o == null) &#123;</span><br><span class="line">        for (int i = size - 1; i &gt;= 0; i--)</span><br><span class="line">            if (elementData[i] == null)</span><br><span class="line">                return i;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        for (int i = size - 1; i &gt;= 0; i--)</span><br><span class="line">            if (o.equals(elementData[i]))</span><br><span class="line">                return i;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>注意：<br>indexOf(Object o)返回第一个出现的元素o的索引；lastIndexOf(Object o)返回最后一个o的索引</p><h3 id="遍历ArrayList中的对象（iterator-）"><a href="#遍历ArrayList中的对象（iterator-）" class="headerlink" title="遍历ArrayList中的对象（iterator()）"></a>遍历ArrayList中的对象（iterator()）</h3><p>使用方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; strList = new ArrayList&lt;String&gt;();</span><br><span class="line">strList.add(&quot;jigang&quot;);</span><br><span class="line">strList.add(&quot;nana&quot;);</span><br><span class="line">strList.add(&quot;nana2&quot;);</span><br><span class="line"></span><br><span class="line">Iterator&lt;String&gt; it = strList.iterator();</span><br><span class="line">while (it.hasNext()) &#123;</span><br><span class="line">    System.out.println(it.next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>源代码：iterator()方法是在AbstractList中实现的，该方法返回AbstractList的一个内部类Itr对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public Iterator&lt;E&gt; iterator() &#123;</span><br><span class="line">    return new Itr();//返回一个内部类对象</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private class Itr implements Iterator&lt;E&gt; &#123;</span><br><span class="line">    //标记位：标记遍历到哪一个元素</span><br><span class="line">    int cursor = 0;</span><br><span class="line">    //标记位：用于判断是否在遍历的过程中，是否发生了add、remove操作</span><br><span class="line">    int expectedModCount = modCount;</span><br><span class="line">    //检测对象数组是否还有元素</span><br><span class="line">    public boolean hasNext() &#123;</span><br><span class="line">        //如果cursor==size，说明已经遍历完了，上一次遍历的是最后一个元素</span><br><span class="line">        return cursor != size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //获取元素</span><br><span class="line">    public E next() &#123;</span><br><span class="line">        //检测在遍历的过程中，是否发生了add、remove操作</span><br><span class="line">        checkForComodification();</span><br><span class="line">        try &#123;</span><br><span class="line">            E next = get(cursor++);</span><br><span class="line">            return next;</span><br><span class="line">            //捕获get(cursor++)方法的IndexOutOfBoundsException</span><br><span class="line">        &#125; catch (IndexOutOfBoundsException e) &#123;</span><br><span class="line">            checkForComodification();</span><br><span class="line">            throw new NoSuchElementException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //检测在遍历的过程中，是否发生了add、remove等操作</span><br><span class="line">    final void checkForComodification() &#123;</span><br><span class="line">        //发生了add、remove操作,这个我们可以查看add等的源代码，发现会出现modCount++</span><br><span class="line">        if (modCount != expectedModCount)</span><br><span class="line">            throw new ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>遍历的整个流程结合”使用方式”与”Itr的注释”来看。注：上述的Itr我去掉了一个此时用不到的方法和属性。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>ArrayList基于数组方式实现，无容量的限制（会扩容）</li><li>添加元素时可能要扩容（所以最好预判一下），删除元素时不会减少容量（若希望减少容量，trimToSize()），删除元素时，将删除掉的位置元素置为null，下次gc就会回收这些元素所占的内存空间。  </li><li>线程不安全</li><li>add(int index, E element)：添加元素到数组中指定位置的时候，需要将该位置及其后边所有的元素都整块向后复制一位</li><li>get(int index)：获取指定位置上的元素时，可以通过索引直接获取（O(1)）</li><li>remove(Object o)需要遍历数组</li><li>remove(int index)不需要遍历数组，只需判断index是否符合条件即可，效率比remove(Object o)高</li><li>contains(E)需要遍历数组<br>做以上总结，主要是为了与后边的LinkedList作比较。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;对于ArrayList需要掌握的七点内容&quot;&gt;&lt;a href=&quot;#对于ArrayList需要掌握的七点内容&quot; class=&quot;headerlink&quot; title=&quot;对于ArrayList需要掌握的七点内容&quot;&gt;&lt;/a&gt;对于ArrayList需要掌握的七点内容&lt;/h2&gt;&lt;
      
    
    </summary>
    
      <category term="java集合框架源码" scheme="http://yoursite.com/categories/java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="java集合框架源码" scheme="http://yoursite.com/tags/java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>Executor框架</title>
    <link href="http://yoursite.com/2018/07/04/Executor%E6%A1%86%E6%9E%B6/"/>
    <id>http://yoursite.com/2018/07/04/Executor框架/</id>
    <published>2018-07-04T01:19:00.000Z</published>
    <updated>2018-07-06T01:42:46.263Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Eexecutor作为灵活且强大的异步执行框架，其支持多种不同类型的任务执行策略，提供了一种标准的方法将任务的提交过程和执行过程解耦开发，基于生产者-消费者模式，其提交任务的线程相当于生产者，执行任务的线程相当于消费者，并用Runnable来表示任务，Executor的实现还提供了对生命周期的支持，以及统计信息收集，应用程序管理机制和性能监视等机制。</p></blockquote><h2 id="Exexctor简介"><a href="#Exexctor简介" class="headerlink" title="Exexctor简介"></a>Exexctor简介</h2><p>如下为Executor的UML图</p><p><img src="http://owq01tqh9.bkt.clouddn.com/Executor%E7%9A%84UML%E5%9B%BE.png" alt="image"></p><p>Executor：一个接口，其定义了一个接收Runnable对象的方法executor，其方法签名为executor(Runnable command)</p><p>ExecutorService：是一个比Executor使用更广泛的子类接口，其提供了生命周期管理的方法，以及可跟踪一个或多个异步任务执行状况返回Future的方法</p><p>AbstractExecutorService：ExecutorService执行方法的默认实现</p><p>ScheduledExecutorService：一个可定时调度任务的接口</p><p>ScheduledThreadPoolExecutor：ScheduledExecutorService的实现，一个可定时调度任务的线程池</p><p>ThreadPoolExecutor：线程池，可以通过调用Executors静态工厂方法来创建线程池并返回一个ExecutorService对象</p><h2 id="ThreadPoolExecutor构造函数的各个参数说明"><a href="#ThreadPoolExecutor构造函数的各个参数说明" class="headerlink" title="ThreadPoolExecutor构造函数的各个参数说明"></a>ThreadPoolExecutor构造函数的各个参数说明</h2><p>ThreadPoolExecutor方法签名：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public ThreadPoolExecutor(int corePoolSize,</span><br><span class="line">                          int maximumPoolSize,</span><br><span class="line">                          long keepAliveTime,</span><br><span class="line">                          TimeUnit unit,</span><br><span class="line">                          BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="line">                          ThreadFactory threadFactory,</span><br><span class="line">                          RejectedExecutionHandler handler) //后两个参数为可选参数</span><br></pre></td></tr></table></figure><p>corePoolSize：核心线程数，如果运行的线程少于corePoolSize，则创建新线程来执行新任务，即使线程池中的其他线程是空闲的</p><p>maximumPoolSize:最大线程数，可允许创建的线程数，corePoolSize和maximumPoolSize设置的边界自动调整池大小：<br>corePoolSize &lt;运行的线程数&lt; maximumPoolSize:仅当队列满时才创建新线程<br>corePoolSize=运行的线程数= maximumPoolSize：创建固定大小的线程池</p><p>keepAliveTime:如果线程数多于corePoolSize,则这些多余的线程的空闲时间超过keepAliveTime时将被终止</p><p>unit:keepAliveTime参数的时间单位</p><p>workQueue:保存任务的阻塞队列，与线程池的大小有关：<br>  当运行的线程数少于corePoolSize时，在有新任务时直接创建新线程来执行任务而无需再进队列<br>  当运行的线程数等于或多于corePoolSize，在有新任务添加时则选加入队列，不直接创建线程<br>  当队列满时，在有新任务时就创建新线程</p><p>threadFactory:使用ThreadFactory创建新线程，默认使用defaultThreadFactory创建线程</p><p>handle:定义处理被拒绝任务的策略，默认使用ThreadPoolExecutor.AbortPolicy,任务被拒绝时将抛出RejectExecutorException</p><h2 id="Executors：提供了一系列静态工厂方法用于创建各种线程池"><a href="#Executors：提供了一系列静态工厂方法用于创建各种线程池" class="headerlink" title="Executors：提供了一系列静态工厂方法用于创建各种线程池"></a>Executors：提供了一系列静态工厂方法用于创建各种线程池</h2><h3 id="newFixedThreadPool"><a href="#newFixedThreadPool" class="headerlink" title="newFixedThreadPool"></a>newFixedThreadPool</h3><p>创建可重用且固定线程数的线程池，如果线程池中的所有线程都处于活动状态，此时再提交任务就在队列中等待，直到有可用线程；如果线程池中的某个线程由于异常而结束时，线程池就会再补充一条新线程。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static ExecutorService newFixedThreadPool(int nThreads) &#123;</span><br><span class="line">    return new ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                  0L, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  //使用一个基于FIFO排序的阻塞队列，在所有corePoolSize线程都忙时新任务将在队列中等待</span><br><span class="line">                                  new LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="newSingleThreadExecutor"><a href="#newSingleThreadExecutor" class="headerlink" title="newSingleThreadExecutor"></a>newSingleThreadExecutor</h3><p>创建一个单线程的Executor，如果该线程因为异常而结束就新建一条线程来继续执行后续的任务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static ExecutorService newSingleThreadExecutor() &#123;</span><br><span class="line">   return new FinalizableDelegatedExecutorService</span><br><span class="line">                     //corePoolSize和maximumPoolSize都等于，表示固定线程池大小为1</span><br><span class="line">                        (new ThreadPoolExecutor(1, 1,</span><br><span class="line">                                                0L, TimeUnit.MILLISECONDS,</span><br><span class="line">                                                new LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="newScheduledThreadPool"><a href="#newScheduledThreadPool" class="headerlink" title="newScheduledThreadPool"></a>newScheduledThreadPool</h3><p>创建一个可延迟执行或定期执行的线程池</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize, ThreadFactory threadFactory) &#123;</span><br><span class="line">        return new ScheduledThreadPoolExecutor(corePoolSize, threadFactory);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public ScheduledThreadPoolExecutor(int corePoolSize) &#123;</span><br><span class="line">    super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS, new DelayedWorkQueue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例1：（使用newScheduledThreadPool来模拟心跳机制）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class HeartBeat &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ScheduledExecutorService executor = Executors.newScheduledThreadPool(5);</span><br><span class="line">        Runnable task = new Runnable() &#123;</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                System.out.println(&quot;HeartBeat.........................&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        executor.scheduleAtFixedRate(task,5,3, TimeUnit.SECONDS);   //5秒后第一次执行，之后每隔3秒执行一次</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HeartBeat....................... //5秒后第一次输出</span><br><span class="line">HeartBeat....................... //每隔3秒输出一个</span><br></pre></td></tr></table></figure><h3 id="newCachedThreadPool"><a href="#newCachedThreadPool" class="headerlink" title="newCachedThreadPool"></a>newCachedThreadPool</h3><p>创建可缓存的线程池，如果线程池中的线程在60秒未被使用就将被移除，在执行新的任务时，当线程池中有之前创建的可用线程就重用可用线程，否则就新建一条线程。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static ExecutorService newCachedThreadPool() &#123;</span><br><span class="line">    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,</span><br><span class="line">                                  60L, TimeUnit.SECONDS,</span><br><span class="line">                                  //使用同步队列，将任务直接提交给线程</span><br><span class="line">                                  new SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class ThreadPoolTest &#123;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">     ExecutorService threadPool = Executors.newCachedThreadPool();//线程池里面的线程数会动态变化，并可在线程线被移除前重用</span><br><span class="line">        for (int i = 1; i &lt;= 3; i ++) &#123;</span><br><span class="line">            final  int task = i;   //10个任务</span><br><span class="line">            //TimeUnit.SECONDS.sleep(1);</span><br><span class="line">            threadPool.execute(new Runnable() &#123;    //接受一个Runnable实例</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                        System.out.println(&quot;线程名字： &quot; + Thread.currentThread().getName() +  &quot;  任务名为： &quot;+task);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：（为每个任务新建一条线程，共创建了3条线程）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">线程名字： pool-1-thread-1 任务名为： 1</span><br><span class="line">线程名字： pool-1-thread-2 任务名为： 2</span><br><span class="line">线程名字： pool-1-thread-3 任务名为： 3</span><br></pre></td></tr></table></figure><p>去掉第6行的注释其输出如下：（始终重复利用一条线程，因为newCachedThreadPool能重用可用线程）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">线程名字： pool-1-thread-1 任务名为： 1</span><br><span class="line">线程名字： pool-1-thread-1 任务名为： 2</span><br><span class="line">线程名字： pool-1-thread-1 任务名为： 3</span><br></pre></td></tr></table></figure><p>通过使用Executor可以很轻易的实现各种调优、管理、监视、记录日志和错误报告等待。</p><h2 id="Executor的生命周期"><a href="#Executor的生命周期" class="headerlink" title="Executor的生命周期"></a>Executor的生命周期</h2><p>ExecutorService提供了管理Eecutor生命周期的方法，ExecutorService的生命周期包括了：运行，关闭和终止三种状态。</p><p>ExecutorService在初始化创建时处于运行状态<br>shutdown方法等待提交的任务执行完成并不再接受新任务，在完成全部提交的任务后关闭<br>shutdownNow方法将强制终止所有运行中的任务并不再允许提交新任务</p><p>可以将一个Runnable（如例2）或Callable（如例3）提交给ExecutorService的submit方法执行，最终返回一个Future用来获得任务的执行结果或取消任务</p><p>例3：（任务执行完成后并返回执行结果）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class CallableAndFuture &#123;</span><br><span class="line">    public static void main(String[] args) throws ExecutionException, InterruptedException &#123;</span><br><span class="line">        ExecutorService executor = Executors.newSingleThreadExecutor();</span><br><span class="line">        Future&lt;String&gt; future = executor.submit(new Callable&lt;String&gt;() &#123;   //接受一上callable实例</span><br><span class="line">            public String call() throws Exception &#123;</span><br><span class="line">                return &quot;MOBIN&quot;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(&quot;任务的执行结果：&quot;+future.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">任务的执行结果：MOBIN</span><br></pre></td></tr></table></figure></p><h2 id="ExecutorCompletionService"><a href="#ExecutorCompletionService" class="headerlink" title="ExecutorCompletionService"></a>ExecutorCompletionService</h2><p>实现了CompletionService，将执行完成的任务放到阻塞队列中，通过take或poll方法来获得执行结果</p><p>例4：（启动10条线程，谁先执行完成就返回谁）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class CompletionServiceTest &#123;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException, ExecutionException &#123;</span><br><span class="line">        ExecutorService executor = Executors.newFixedThreadPool(10);        //创建含10.条线程的线程池</span><br><span class="line">        CompletionService completionService = new ExecutorCompletionService(executor);</span><br><span class="line">        for (int i =1; i &lt;=10; i ++) &#123;</span><br><span class="line">            final  int result = i;</span><br><span class="line">            completionService.submit(new Callable() &#123;</span><br><span class="line">                public Object call() throws Exception &#123;</span><br><span class="line">                    Thread.sleep(new Random().nextInt(5000));   //让当前线程随机休眠一段时间</span><br><span class="line">                    return result;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(completionService.take().get());   //获取执行结果</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果可能每次都不同（在1到10之间）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><p>通过Executor来设计应用程序可以简化开发过程，提高开发效率，并有助于实现并发，在开发中如果需要创建线程可优先考虑使用Executor</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;Eexecutor作为灵活且强大的异步执行框架，其支持多种不同类型的任务执行策略，提供了一种标准的方法将任务的提交过程和执行过程解耦开发，基于生产者-消费者模式，其提交任务的线程相当于生产者，执行任务的线程相当于消费者，并用Runnable来表示任
      
    
    </summary>
    
      <category term="java并发" scheme="http://yoursite.com/categories/java%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="java并发" scheme="http://yoursite.com/tags/java%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>动态规划（2）</title>
    <link href="http://yoursite.com/2018/06/30/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%882%EF%BC%89/"/>
    <id>http://yoursite.com/2018/06/30/动态规划（2）/</id>
    <published>2018-06-30T09:17:00.000Z</published>
    <updated>2018-07-08T02:21:15.243Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>整理一下经典动态规划题目</p></blockquote><h3 id="台阶问题"><a href="#台阶问题" class="headerlink" title="台阶问题"></a>台阶问题</h3><p>题目：<br>有n级台阶，一个人每次上一级或者两级，问有多少种走完n级台阶的方法。为了防止溢出，请将结果Mod 1000000007</p><p>分析：<br>假设第i层台阶的方法数为f(i)，则f(i)=f(i-1)+f(i-2)，第i层只能等于i-1层上一阶加上i-2层上两阶，因此：<br>f(1)=1<br>f(2)=2<br>f(i)=f(i-1)+f(i-2) </p><h4 id="暴力递归方法"><a href="#暴力递归方法" class="headerlink" title="暴力递归方法"></a>暴力递归方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">jumpStep1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span> || n == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> jumpStep1(n - <span class="number">1</span>) + jumpStep1(n - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="轮询遍历"><a href="#轮询遍历" class="headerlink" title="轮询遍历"></a>轮询遍历</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">jumpStep2</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span> || n == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当前值</span></span><br><span class="line">    <span class="keyword">int</span> pre = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 前一个值</span></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        temp = res;</span><br><span class="line">        res = res + pre;</span><br><span class="line">        pre = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">jumpStep3</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span> || n == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    res[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    res[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        res[i] = res[i-<span class="number">1</span>] + res[i-<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="矩阵的最小路径和"><a href="#矩阵的最小路径和" class="headerlink" title="矩阵的最小路径和"></a>矩阵的最小路径和</h3><p>题目：<br>给定一个矩阵m，从左上角开始每次只能向右或者向下走，最后到达右下角的为止，路径上所有的数字累加起来就是路径和，返回所有路径中的最小的路径和。<br>举例：<br>1 3 5 9<br>8 1 3 4<br>5 0 6 1<br>8 8 4 0<br>路径1,3,1,0,6,1,0是所有路径中路径和最小的，所以返回12.  </p><p><img src="http://owq01tqh9.bkt.clouddn.com/%E7%9F%A9%E9%98%B5%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C.png" alt="image"></p><p>代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getMin</span><span class="params">(<span class="keyword">int</span>[][] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length == <span class="number">0</span> || arr[<span class="number">0</span>] == <span class="keyword">null</span> || arr[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> rows = arr.length;</span><br><span class="line">    <span class="keyword">int</span> cols = arr[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[rows][cols];</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = arr[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; rows; ++i) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] =  arr[i][<span class="number">0</span>] + dp[i-<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; cols; ++j) &#123;</span><br><span class="line">        dp[<span class="number">0</span>][j] += arr[<span class="number">0</span>][j] + dp[<span class="number">0</span>][j-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; rows; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; cols; ++j) &#123;</span><br><span class="line">            dp[i][j] = arr[i][j] + Math.min(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[rows - <span class="number">1</span>][cols - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="最长递增子序列问题"><a href="#最长递增子序列问题" class="headerlink" title="最长递增子序列问题"></a>最长递增子序列问题</h3><p>题目：<br>给定一个整数序列，找到最长上升子序列（LIS），返回LIS的长度。</p><p>最长上升子序列的定义：<br>最长上升子序列问题是在一个无序的给定序列中找到一个尽可能长的由低到高排列的子序列，这种子序列不一定是连续的或者唯一的。</p><p>样例<br>给出 [5,4,1,2,3]，LIS 是 [1,2,3]，返回 3<br>给出 [4,2,4,5,3,7]，LIS 是 [2,4,5,7]，返回 4  </p><p>分析：  </p><p><img src="http://owq01tqh9.bkt.clouddn.com/%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97%E9%95%BF%E5%BA%A6.png" alt="image"></p><p>代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public int longestIncreasingSubsequence(int[] nums) &#123;</span><br><span class="line">    int[] dp = new int[nums.length];</span><br><span class="line">    // 生成dp数组</span><br><span class="line">    for (int i = 0; i &lt; nums.length; ++i) &#123;</span><br><span class="line">        dp[i] = 1;</span><br><span class="line">        for (int j = 0; j &lt; i; ++j) &#123;</span><br><span class="line">            if (nums[j] &lt; nums[i]) &#123;</span><br><span class="line">                dp[i] = Math.max(dp[i], dp[j] + 1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 遍历数组得到最长递增子序列长度</span><br><span class="line">    int max = 0;</span><br><span class="line">    for (int i = 0; i &lt; nums.length; ++i) &#123;</span><br><span class="line">        max = Math.max(max, dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    return max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h3><p>题目：<br>给出两个字符串，找到最长公共子序列(LCS)，返回LCS的长度。</p><p>最长公共子序列的定义：<br>最长公共子序列问题是在一组序列（通常2个）中找到最长公共子序列（注意：不同于子串，LCS不需要是连续的子串）。该问题是典型的计算机科学问题，是文件差异比较程序的基础，在生物信息学中也有所应用。</p><p>样例：<br>给出”ABCD” 和 “EDCA”，这个LCS是 “A” (或 D或C)，返回1<br>给出 “ABCD” 和 “EACB”，这个LCS是”AC”返回2</p><p>分析：    </p><p><img src="http://owq01tqh9.bkt.clouddn.com/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97.png" alt="image"></p><p>代码： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(String A, String B)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lengthA = A.length();</span><br><span class="line">    <span class="keyword">int</span> lengthB = B.length();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(lengthA == <span class="number">0</span> || lengthB == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[lengthA][lengthB];</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = A.charAt(<span class="number">0</span>) == B.charAt(<span class="number">0</span>) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lengthA; ++i) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = Math.max(dp[i-<span class="number">1</span>][<span class="number">0</span>], A.charAt(i) == B.charAt(<span class="number">0</span>) ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; lengthB; ++j) &#123;</span><br><span class="line">        dp[<span class="number">0</span>][j] = Math.max(dp[<span class="number">0</span>][j], A.charAt(<span class="number">0</span>) == B.charAt(j) ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; lengthA; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; lengthB; ++j) &#123;</span><br><span class="line">            dp[i][j] = Math.max(dp[i-<span class="number">1</span>][j], dp[i][j-<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">if</span> (A.charAt(i) == B.charAt(j)) &#123;</span><br><span class="line">                dp[i][j] = Math.max(dp[i][j], dp[i-<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[lengthA - <span class="number">1</span>][lengthB - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h3><p>题目： </p><p>一个背包有一定的承重W,有N件物品,每件都有自己的价值,记录在数组v中,也都有自己的重量,记录在数组w中,每件物品只能选择要装入背包还是不装入背包,要求在不超过背包承重的前提下,选出物品的总价值最大。</p><p>分析：<br><img src="http://owq01tqh9.bkt.clouddn.com/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98.png" alt="image"></p><p>代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public static int backpack(int[] w, int[] v, int W, int N) &#123;</span><br><span class="line">    int[][] dp = new int[N+1][W+1];</span><br><span class="line">    for (int x = 1 ; x &lt;= N; ++x) &#123;</span><br><span class="line">        for (int y = 1; y &lt;= W; ++y) &#123;</span><br><span class="line">            if (y &gt;= w[x-1]) &#123;</span><br><span class="line">                dp[x][y] = Math.max(dp[x-1][y], dp[x-1][y-w[x-1]] + v[x-1]);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                dp[x][y] = dp[x-1][y];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[N][W];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="最优编辑问题"><a href="#最优编辑问题" class="headerlink" title="最优编辑问题"></a>最优编辑问题</h3><p>题目：</p><p>给定两个字符串str1和str2，再给定三个整数ic，dc和rc，分别代表插入，删除和替换一个字符的代价。返回将str1编辑成str2的最小代价。比如，str1=”abc”,str2=adc”,ic=5,dc=3,rc=2。从”abc”编辑成”adc”，把’b’替换成’d’是代价最小的，所以返回2。再比如，str1=”abc”,str2=adc”,ic=5,dc=3,C=100。从”abc”编辑成”adc”,先删除’b’,然后插入’d’是代价最小的，所以返回8。</p><p>分析：</p><p>假设A,B的长度分布为N和M，那么建立一个大小为(N+1)*(M+1)的矩阵dp，==其中dp[i][j]表示的含义是将A[0,…,i-1]编辑成B[0,…,j-1]的最小代价==</p><p><img src="http://owq01tqh9.bkt.clouddn.com/%E6%9C%80%E5%B0%8F%E7%BC%96%E8%BE%91%E4%BB%A3%E4%BB%B7.png" alt="image"></p><p>dp[0][0]=0</p><p>dp[i][0]=dc*i</p><p>dp[0][j]=ic*i</p><p>dp[i][j]有四种情况分别如下：</p><ol><li><p>dp[i][j]=dp[i-1][j]+dc    </p></li><li><p>dp[i][j]=dp[i][j-1]+ic </p></li><li><p>当A[i-1]==B[j-1]时，dp[i][j]=dp[i-1][j-1]   </p></li><li><p>当A[i-1]!=B[j-1]时，dp[i][j]=dp[i-1][j-1]+rc</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getMinEditCost</span><span class="params">(String str1, <span class="keyword">int</span> m, String str2, <span class="keyword">int</span> n,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="keyword">int</span> ic, <span class="keyword">int</span> dc, <span class="keyword">int</span> rc)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 第一列</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = i * dc;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 第一行</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">        dp[<span class="number">0</span>][j] = j * ic;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// dp[i][j]</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = Math.min(dp[i - <span class="number">1</span>][j] + dc, dp[i][j - <span class="number">1</span>] + ic);</span><br><span class="line">            <span class="keyword">if</span> (str1.charAt(i - <span class="number">1</span>) == str2.charAt(j - <span class="number">1</span>)) &#123;</span><br><span class="line">                dp[i][j] = Math.min(temp, dp[i - <span class="number">1</span>][j - <span class="number">1</span>]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = Math.min(temp, dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + rc);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m][n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;整理一下经典动态规划题目&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;台阶问题&quot;&gt;&lt;a href=&quot;#台阶问题&quot; class=&quot;headerlink&quot; title=&quot;台阶问题&quot;&gt;&lt;/a&gt;台阶问题&lt;/h3&gt;&lt;p&gt;题目：&lt;br&gt;有n级台阶，一个
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>动态规划（1）</title>
    <link href="http://yoursite.com/2018/06/30/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%881%EF%BC%89/"/>
    <id>http://yoursite.com/2018/06/30/动态规划（1）/</id>
    <published>2018-06-30T06:08:00.000Z</published>
    <updated>2018-06-30T08:54:43.053Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>给定数组arr，arr中所有的值都为整数且不重复。每个值代表一种面值的货币，每种货币有无数张，再给定一个整数aim代表要找的钱数，求换钱的方法有多少种。</p><h2 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h2><p>这道题的经典之处在于它可以体现暴力递归、记忆搜索、动态规划之间的关系，并可以在动态规划的基础上再进行一次优化。</p><p>首先介绍暴力递归的方法。如果arr = [5, 10, 25, 1]，aim = 1000，分析过程如下：</p><ul><li>用０张５元的货币，让[10, 25, 1]组成剩下的1000，最终方法数记为res1。  </li><li>用１张５元的货币，让[10, 25, 1]组成剩下的995，最终方法数记为res2。  </li><li>用２张５元的货币，让[10, 25, 1]组成剩下的990，最终方法数记为res3。<br>……  </li><li>用201张５元的货币，让[10, 25, 1]组成剩下的0，最终方法数记为res201。</li></ul><p>那么res1 + res2 + res3 + …… +res201的值就是中的方法数。根据如上的分析过程定义递归函数process1(arr, index, aim)它的含义是如果用arr[index..N-1]这些面值的钱组成aim，返回总的方法数。最坏情况下时间复杂度为O(aim^N)，N表示数组的长度。</p><h2 id="暴力搜索方法"><a href="#暴力搜索方法" class="headerlink" title="暴力搜索方法"></a>暴力搜索方法</h2><p>下面是用java实现的代码（时间复杂度O(aim^N)）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">coins1</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> aim)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length == <span class="number">0</span> || aim &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> process1(arr, <span class="number">0</span>, aim);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 它的含义是如果用arr[index..N-1]这些面值的钱组成aim，返回总的方法数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">process1</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> index, <span class="keyword">int</span> aim)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 终止条件</span></span><br><span class="line">    <span class="keyword">if</span> (index == arr.length) &#123;</span><br><span class="line">        res = (aim == <span class="number">0</span>) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; arr[index] * i &lt;= aim; ++i) &#123;</span><br><span class="line">            res += process1(arr, index + <span class="number">1</span>, aim - arr[index] * i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="记忆搜索方法"><a href="#记忆搜索方法" class="headerlink" title="记忆搜索方法"></a>记忆搜索方法</h2><p>在暴力递归中，有很多的重复计算，比如使用0张5元+1张10元的情况和使用2张5元+0张10元的情况，都需要求[25, 1]组成剩下的990的方法数。记忆搜索就是使用一张记录表将递归过程中的结果进行记录，当下次再遇到同样的递归过程，就直接使用表中的数据，这样就对暴力递归进行了优化。 </p><p>下面是用java实现的代码（时间复杂度为O(N*aim^2)，空间复杂度O(N*aim)）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">// 记忆搜索方法</span><br><span class="line">public static int coins2(int[] arr, int aim) &#123;</span><br><span class="line">    if (arr == null || arr.length == 0 || aim &lt; 0) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    // 定义一张表来记录计算过的值，从而避免重复计算</span><br><span class="line">    // map[i][j] == 0 表示没有计算过</span><br><span class="line">    // map[i][j] == -1 表示计算过，但是值为0</span><br><span class="line">    // map[i][j] == a 表示计算过，值为a</span><br><span class="line">    int[][] map = new int[arr.length + 1][aim + 1];</span><br><span class="line">    return process2(arr, 0, aim, map);</span><br><span class="line">&#125;</span><br><span class="line">public static int process2(int[] arr, int index, int aim, int[][] map) &#123;</span><br><span class="line">    int res = 0;</span><br><span class="line">    if (index == arr.length) &#123;</span><br><span class="line">        res = (aim == 0) ? 1 : 0;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        int mapValue = 0;</span><br><span class="line">        for (int i = 0; arr[index] * i &lt;= aim; ++i) &#123;</span><br><span class="line">            mapValue = map[index + 1][aim - arr[index] * i];</span><br><span class="line">            if (mapValue != 0) &#123;</span><br><span class="line">                res += mapValue == -1 ? 0 : mapValue;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                res += process2(arr, index + 1, aim - arr[index] * i, map);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    map[index][aim] = res == 0 ? -1 : res;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p><img src="http://owq01tqh9.bkt.clouddn.com/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%96%B9%E6%B3%95.png" alt="image"></p><p>下面是用java实现的代码（时间复杂度为O(N*aim^2)，空间复杂度O(N*aim)）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 动态规划方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">coins3</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> aim)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length == <span class="number">0</span> || aim &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// dp[i][j]的含义是在使用arr[0..i]货币的情况下，组成钱数j有多少种方法</span></span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length][aim + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; ++i) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j * arr[<span class="number">0</span>] &lt;= aim; j++) &#123;</span><br><span class="line">        dp[<span class="number">0</span>][j * arr[<span class="number">0</span>]] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= aim; ++j) &#123;</span><br><span class="line">            <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; j - k * arr[i] &gt;= <span class="number">0</span>; ++k) &#123;</span><br><span class="line">                num += dp[i - <span class="number">1</span>][j - k * arr[i]];</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i][j] = num;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[arr.length - <span class="number">1</span>][aim];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="动态规划引入"><a href="#动态规划引入" class="headerlink" title="动态规划引入"></a>动态规划引入</h2><p><img src="http://owq01tqh9.bkt.clouddn.com/%E4%BB%80%E4%B9%88%E6%98%AF%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%96%B9%E6%B3%95.png" alt="image"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// 优化后的动态规划方法</span><br><span class="line">public static int coins4(int[] arr, int aim) &#123;</span><br><span class="line">    if (arr == null || arr.length == 0 || aim &lt; 0) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    // dp[i][j]的含义是在使用arr[0..i]货币的情况下，组成钱数j有多少种方法</span><br><span class="line">    int[][] dp = new int[arr.length][aim + 1];</span><br><span class="line">    for (int i = 0; i &lt; arr.length; ++i) &#123;</span><br><span class="line">        dp[i][0] = 1;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int j = 0; j * arr[0] &lt;= aim; j++) &#123;</span><br><span class="line">        dp[0][j * arr[0]] = 1;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 1; i &lt; arr.length; ++i) &#123;</span><br><span class="line">        for (int j = 1; j &lt;= aim; ++j) &#123;</span><br><span class="line">            // 简化枚举过程</span><br><span class="line">            dp[i][j] = dp[i - 1][j] + (j - arr[i] &gt;= 0 ? dp[i][j - arr[i]] : 0);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[arr.length - 1][aim];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="记忆搜索与动态规划的联系"><a href="#记忆搜索与动态规划的联系" class="headerlink" title="记忆搜索与动态规划的联系"></a>记忆搜索与动态规划的联系</h2><ol><li><p>记忆化搜索方法就是某种形态的动态规划方法。</p></li><li><p>记忆化搜索方法不关心到达某一个递归过程的路径,只是单纯地对计算过的递归过程进行记录,避免重复的递归过程。  </p></li><li><p>动态规划的方法则是规定好每一个递归过程的计算顺序,依次进行计算,后面的计算过程严格依赖前面的计算过程。  </p></li><li><p>两者都是空间换时间的方法,也都有校举!的过程,区别就在于动态规划规定计算顺序,而记忆搜索不用规定。</p></li></ol><h2 id="解决动态规划问题的过程"><a href="#解决动态规划问题的过程" class="headerlink" title="解决动态规划问题的过程"></a>解决动态规划问题的过程</h2><ol><li><p>实现暴力递归方法。</p></li><li><p>在暴力搜索方法的函数中看看哪些参数可!以代表递归过程</p></li><li><p>找到代表递归过程的参数之后,记忆化搜索的方法非常容易实现。</p></li><li><p>通过分析记忆化搜索的依赖路径,进而实视动态规划。</p></li><li><p>根据记忆化搜索方法改出动态规划方法,进而看看是否能化简,如果能化简,还能实现时间复杂度更低的动态规划方法。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h2&gt;&lt;p&gt;给定数组arr，arr中所有的值都为整数且不重复。每个值代表一种面值的货币，每种货币有无数张，再给定一个整数aim代表要找的钱数，求换钱的方
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>编码规范整理</title>
    <link href="http://yoursite.com/2018/06/27/%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83%E6%95%B4%E7%90%86/"/>
    <id>http://yoursite.com/2018/06/27/编码规范整理/</id>
    <published>2018-06-27T07:20:00.000Z</published>
    <updated>2018-06-27T07:59:43.580Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>最近在根据<strong>阿里规范插件</strong>整理代码规范，总结下遇到的问题</p></blockquote><h2 id="Critical级别"><a href="#Critical级别" class="headerlink" title="Critical级别"></a>Critical级别</h2><h3 id="不使用过时的类或方法"><a href="#不使用过时的类或方法" class="headerlink" title="不使用过时的类或方法"></a>不使用过时的类或方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> JSONObject <span class="title">sendHttpRequest</span><span class="params">(String url, List&lt;NameValuePair&gt; nvps)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// DefaultHttpClient是添加了@Deprecated注解的类</span></span><br><span class="line">    DefaultHttpClient httpClient = <span class="keyword">new</span> DefaultHttpClient();</span><br><span class="line">    HttpPost httpPost = <span class="keyword">new</span> HttpPost(url);</span><br><span class="line">    <span class="comment">// ............</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="建线程或线程池时请指定有意义的线程名称，方便出错时回溯"><a href="#建线程或线程池时请指定有意义的线程名称，方便出错时回溯" class="headerlink" title="建线程或线程池时请指定有意义的线程名称，方便出错时回溯"></a>建线程或线程池时请指定有意义的线程名称，方便出错时回溯</h3><p>说明：创建线程池的时候使用带ThreadFactory的构造函数，并且提供自定义ThreadFactory实现或者使用第三方实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Guava提供</span></span><br><span class="line">ThreadFactory namedThreadFactory = <span class="keyword">new</span> ThreadFactoryBuilder().setNameFormat(<span class="string">"demo-pool-%d"</span>).build();</span><br><span class="line">    ExecutorService singleThreadPool = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>, <span class="number">0L</span>, TimeUnit.MILLISECONDS, <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(<span class="number">1024</span>), namedThreadFactory, <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy());</span><br><span class="line"></span><br><span class="line">    singleThreadPool.execute(()-&gt; System.out.println(Thread.currentThread().getName()));</span><br><span class="line">    singleThreadPool.shutdown();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimerTaskThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">TimerTaskThread</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.setName(<span class="string">"TimerTaskThread"</span>); </span><br><span class="line">        ......    </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="Major级别"><a href="#Major级别" class="headerlink" title="Major级别"></a>Major级别</h2><h3 id="不允许任何魔法值（即未经定义的常量）直接出现在代码中"><a href="#不允许任何魔法值（即未经定义的常量）直接出现在代码中" class="headerlink" title="不允许任何魔法值（即未经定义的常量）直接出现在代码中"></a>不允许任何魔法值（即未经定义的常量）直接出现在代码中</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Negative example:</span><br><span class="line">    //Magic values, except for predefined, are forbidden in coding.</span><br><span class="line">    if (key.equals(&quot;Id#taobao_1&quot;)) &#123;</span><br><span class="line">            //...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">Positive example:</span><br><span class="line">    String KEY_PRE = &quot;Id#taobao_1&quot;;  </span><br><span class="line">    if (KEY_PRE.equals(key)) &#123;</span><br><span class="line">            //...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="事务场景中，抛出异常被catch后，如果需要回滚，一定要手动回滚事务"><a href="#事务场景中，抛出异常被catch后，如果需要回滚，一定要手动回滚事务" class="headerlink" title="事务场景中，抛出异常被catch后，如果需要回滚，一定要手动回滚事务"></a>事务场景中，抛出异常被catch后，如果需要回滚，一定要手动回滚事务</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">Positive example <span class="number">1</span>：</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> caikang</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span> 2017/04/07</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Service</span></span><br><span class="line">    <span class="meta">@Transactional</span>(rollbackFor = Exception.class)</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//some code</span></span><br><span class="line">            <span class="comment">//db operation</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">Positive example <span class="number">2</span>：</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> caikang</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span> 2017/04/07</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Service</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="meta">@Transactional</span>(rollbackFor = Exception.class)</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//some code</span></span><br><span class="line">            <span class="comment">//db operation</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">Positive example <span class="number">3</span>：</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> caikang</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span> 2017/04/07</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Service</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Autowired</span></span><br><span class="line">        <span class="keyword">private</span> DataSourceTransactionManager transactionManager;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="meta">@Transactional</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">            DefaultTransactionDefinition def = <span class="keyword">new</span> DefaultTransactionDefinition();</span><br><span class="line">            <span class="comment">// explicitly setting the transaction name is something that can only be done programmatically</span></span><br><span class="line">            def.setName(<span class="string">"SomeTxName"</span>);</span><br><span class="line">            def.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);</span><br><span class="line"></span><br><span class="line">            TransactionStatus status = transactionManager.getTransaction(def);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// execute your business logic here</span></span><br><span class="line">                <span class="comment">//db operation</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                transactionManager.rollback(status);</span><br><span class="line">                <span class="keyword">throw</span> ex;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="关于基本数据类型与包装数据类型的使用标准"><a href="#关于基本数据类型与包装数据类型的使用标准" class="headerlink" title="关于基本数据类型与包装数据类型的使用标准"></a>关于基本数据类型与包装数据类型的使用标准</h3><ol><li>所有的POJO类属性必须使用包装数据类型。</li><li>RPC方法的返回值和参数必须使用包装数据类型。</li><li>所有的局部变量推荐使用基本数据类型。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public class DemoDO &#123;</span><br><span class="line">    String str;</span><br><span class="line">    Integer a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="及时清理不再使用的代码段或配置信息"><a href="#及时清理不再使用的代码段或配置信息" class="headerlink" title="及时清理不再使用的代码段或配置信息"></a>及时清理不再使用的代码段或配置信息</h3><p>说明：对于垃圾代码或过时配置，坚决清理干净，避免程序过度臃肿，代码冗余</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Positive example: </span><br><span class="line">public static void hello() &#123;</span><br><span class="line">    /// Business is stopped temporarily by the owner.</span><br><span class="line">    // Business business = new Business();</span><br><span class="line">    // business.active();</span><br><span class="line">    System.out.println(&quot;it&apos;s finished&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="定义DO-DTO-VO等POJO类时，不要加任何属性默认值"><a href="#定义DO-DTO-VO等POJO类时，不要加任何属性默认值" class="headerlink" title="定义DO/DTO/VO等POJO类时，不要加任何属性默认值"></a>定义DO/DTO/VO等POJO类时，不要加任何属性默认值</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoDO</span> </span>&#123;</span><br><span class="line">    String str;</span><br><span class="line">    Integer a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="所有的类都必须添加创建者信息"><a href="#所有的类都必须添加创建者信息" class="headerlink" title="所有的类都必须添加创建者信息"></a>所有的类都必须添加创建者信息</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Demo class</span><br><span class="line"> * </span><br><span class="line"> * @author keriezhang</span><br><span class="line"> * @date 2016/10/31</span><br><span class="line"> */</span><br><span class="line">public class CodeNoteDemo &#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="类、类属性、类方法的注释必须使用javadoc规范"><a href="#类、类属性、类方法的注释必须使用javadoc规范" class="headerlink" title="类、类属性、类方法的注释必须使用javadoc规范"></a>类、类属性、类方法的注释必须使用javadoc规范</h3><p>说明：注释使用/**内容*/格式，不得使用//xxx方式和/*xxx*/方式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * </span><br><span class="line"> * XXX class function description.</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class XxClass implements Serializable &#123;</span><br><span class="line">    private static final long serialVersionUID = 113323427779853001L;</span><br><span class="line">    /**</span><br><span class="line">     * id</span><br><span class="line">     */</span><br><span class="line">    private Long id;</span><br><span class="line">    /**</span><br><span class="line">     * title</span><br><span class="line">     */</span><br><span class="line">    private String title;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * find by id</span><br><span class="line">     * </span><br><span class="line">     * @param ruleId rule id</span><br><span class="line">     * @param page start from 1</span><br><span class="line">     * @return Result&lt;Xxxx&gt;</span><br><span class="line">     */</span><br><span class="line">    public Result&lt;Xxxx&gt; funcA(Long ruleId, Integer page) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="不要在条件判断中执行复杂的语句"><a href="#不要在条件判断中执行复杂的语句" class="headerlink" title="不要在条件判断中执行复杂的语句"></a>不要在条件判断中执行复杂的语句</h3><p>说明：除常用方法（如getXxx/isXxx）等外，不要在条件判断中执行复杂的语句，将复杂逻辑判断的结果赋值给一个有意义的布尔变量，以提高可读性。说明：很多if语句内的逻辑相当复杂，阅读者需要分析条件表达式的最终结果，才能明确什么样的条件执行什么样的语句，那么，如果阅读者分析逻辑表达式错误呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Negative example:</span><br><span class="line">    if ((file.open(fileName, &quot;w&quot;) != null) &amp;&amp; (...) || (...)) &#123;</span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">Positive example:</span><br><span class="line">    boolean existed = (file.open(fileName, &quot;w&quot;) != null) &amp;&amp; (...) || (...);</span><br><span class="line">    if (existed) &#123;</span><br><span class="line">        //...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="集合初始化时，指定集合初始值大小。"><a href="#集合初始化时，指定集合初始值大小。" class="headerlink" title="集合初始化时，指定集合初始值大小。"></a>集合初始化时，指定集合初始值大小。</h3><p>说明：HashMap使用如下构造方法进行初始化，如果暂时无法确定集合大小，那么指定默认值（16）即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Negative example:   </span><br><span class="line">   Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();</span><br><span class="line"> </span><br><span class="line"> Positive example: </span><br><span class="line">   Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;(16);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;最近在根据&lt;strong&gt;阿里规范插件&lt;/strong&gt;整理代码规范，总结下遇到的问题&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;Critical级别&quot;&gt;&lt;a href=&quot;#Critical级别&quot; class=&quot;headerlink&quot; t
      
    
    </summary>
    
      <category term="代码规范" scheme="http://yoursite.com/categories/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    
    
      <category term="代码规范" scheme="http://yoursite.com/tags/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    
  </entry>
  
  <entry>
    <title>KMP字符串匹配（java）</title>
    <link href="http://yoursite.com/2018/06/22/KMP%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/"/>
    <id>http://yoursite.com/2018/06/22/KMP字符串匹配/</id>
    <published>2018-06-22T11:45:00.000Z</published>
    <updated>2018-06-22T11:58:04.963Z</updated>
    
    <content type="html"><![CDATA[<h3 id="KMP算法介绍"><a href="#KMP算法介绍" class="headerlink" title="KMP算法介绍"></a>KMP算法介绍</h3><p>参考：<a href="https://blog.csdn.net/u013289254/article/details/60597339" target="_blank" rel="noopener">字符串匹配的KMP算法</a></p><h3 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h3><blockquote></blockquote><p>对于一个给定的 source 字符串和一个 target 字符串，你应该在 source 字符串中找出 target 字符串出现的第一个位置(从0开始)。如果不存在，则返回 -1。</p><p>样例<br>如果 source = “source” 和 target = “target”，返回 -1。</p><p>如果 source = “abcdabcdefg” 和 target = “bcd”，返回 1。</p><h3 id="暴力解法"><a href="#暴力解法" class="headerlink" title="暴力解法"></a>暴力解法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">strStr</span><span class="params">(String source, String target)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write your code here</span></span><br><span class="line">    <span class="keyword">if</span> (source == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (target == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (target.length() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> sourceLength = source.length();</span><br><span class="line">    <span class="keyword">int</span> targetLength = target.length();</span><br><span class="line">    <span class="keyword">char</span>[] sourceCharArray = source.toCharArray();</span><br><span class="line">    <span class="keyword">char</span>[] targetCharArray = target.toCharArray();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sourceLength; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sourceCharArray[i] == targetCharArray[<span class="number">0</span>]) &#123;</span><br><span class="line">            <span class="keyword">int</span> tempI = i;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; targetLength &amp;&amp; tempI &lt; sourceLength; ++j, ++tempI) &#123;</span><br><span class="line">                <span class="keyword">if</span> (sourceCharArray[tempI] != targetCharArray[j]) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (tempI == (i + targetCharArray.length)) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取字符串部分匹配表</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] getPartMatchTable(String str) &#123;</span><br><span class="line">    <span class="keyword">if</span> (str == <span class="keyword">null</span> || str.length() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> length = str.length();</span><br><span class="line">    <span class="keyword">char</span>[] charArray = str.toCharArray();</span><br><span class="line">    <span class="keyword">int</span>[] table = <span class="keyword">new</span> <span class="keyword">int</span>[str.length()];</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    table[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; length) &#123;</span><br><span class="line">        <span class="keyword">if</span> (charArray[i] == charArray[j]) &#123;</span><br><span class="line">            ++count;</span><br><span class="line">            table[i] = count;</span><br><span class="line">            ++i;</span><br><span class="line">            ++j;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            count = <span class="number">0</span>;</span><br><span class="line">            table[i] = count;</span><br><span class="line">            j = <span class="number">0</span>;</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> table;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">strStr</span><span class="params">(String source, String target)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write your code here</span></span><br><span class="line">    <span class="keyword">if</span> (source == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (target == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (target.length() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> sourceLength = source.length();</span><br><span class="line">    <span class="keyword">int</span> targetLength = target.length();</span><br><span class="line">    <span class="keyword">char</span>[] sourceCharArray = source.toCharArray();</span><br><span class="line">    <span class="keyword">char</span>[] targetCharArray = target.toCharArray();</span><br><span class="line">    <span class="comment">// 获取字符串部分匹配表</span></span><br><span class="line">    <span class="keyword">int</span>[] table = getPartMatchTable(target);</span><br><span class="line">    <span class="comment">// 遍历标记</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 记录已经匹配的字符数</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 定义临时标记</span></span><br><span class="line">    <span class="keyword">int</span> tempI = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; sourceLength) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sourceCharArray[i] == targetCharArray[<span class="number">0</span>]) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">            tempI = i;</span><br><span class="line">            <span class="keyword">while</span> (j &lt; targetLength &amp;&amp; tempI &lt; sourceLength) &#123;</span><br><span class="line">                <span class="keyword">if</span> (sourceCharArray[tempI] == targetCharArray[j]) &#123;</span><br><span class="line">                   ++count;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                ++tempI;</span><br><span class="line">                ++j;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (tempI == (i + targetCharArray.length)) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 关键代码</span></span><br><span class="line">                i = i + (count - table[j]);</span><br><span class="line">                count = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;KMP算法介绍&quot;&gt;&lt;a href=&quot;#KMP算法介绍&quot; class=&quot;headerlink&quot; title=&quot;KMP算法介绍&quot;&gt;&lt;/a&gt;KMP算法介绍&lt;/h3&gt;&lt;p&gt;参考：&lt;a href=&quot;https://blog.csdn.net/u013289254/artic
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>线程池</title>
    <link href="http://yoursite.com/2018/06/21/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <id>http://yoursite.com/2018/06/21/线程池/</id>
    <published>2018-06-21T08:20:00.000Z</published>
    <updated>2018-06-25T03:56:14.768Z</updated>
    
    <content type="html"><![CDATA[<h2 id="为什么使用线程池？"><a href="#为什么使用线程池？" class="headerlink" title="为什么使用线程池？"></a>为什么使用线程池？</h2><ol><li><p>可以降低资源的消耗。线程池通过重复利用资源来避免创建和销毁线程带来的资源消耗。</p></li><li><p>提高响应速度。不需要新创建线程来执行任务，直接利用线程池中已经创建好的线程来执行任务。</p></li><li><p>保证线程可管理。线程不能无限创建和销毁，通过线程池可以进行统一分配、调优和监控。</p></li></ol><h2 id="线程池原理"><a href="#线程池原理" class="headerlink" title="线程池原理"></a>线程池原理</h2><p><img src="http://owq01tqh9.bkt.clouddn.com/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B.png" alt="image"></p><p>从图中可以看出，当提交一个新任务到线程池时，线程池的处理流程如下。<br>1）线程池判断核心线程池里的线程是否都在执行任务。如果不是，则创建一个新的工作线程来执行任务。如果核心线程池里的线程都在执行任务，则进入下个流程。<br>2）线程池判断工作队列是否已经满。如果工作队列没有满，则将新提交的任务存储在这个工作队列里。如果工作队列满了，则进入下个流程。<br>3）线程池判断线程池的线程是否都处于工作状态。如果没有，则创建一个新的工作线程来执行任务。如果已经满了，则交给饱和策略来处理这个任务。 </p><h2 id="ThreadPoolExecutor执行execute步骤"><a href="#ThreadPoolExecutor执行execute步骤" class="headerlink" title="ThreadPoolExecutor执行execute步骤"></a>ThreadPoolExecutor执行execute步骤</h2><p><img src="http://owq01tqh9.bkt.clouddn.com/ThreadPoolExecutor%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.png" alt="image"></p><p>ThreadPoolExecutor执行execute方法分下面4种情况。<br>1）如果当前运行的线程少于corePoolSize，则创建新线程来执行任务（注意，执行这一步骤需要获取全局锁）。<br>2）如果运行的线程等于或多于corePoolSize，则将任务加入BlockingQueue。<br>3）如果无法将任务加入BlockingQueue（队列已满），则创建新的线程来处理任务（注意，执行这一步骤需要获取全局锁）。<br>4）如果创建新线程将使当前运行的线程超出maximumPoolSize，任务将被拒绝，并调用RejectedExecutionHandler.rejectedExecution()方法。  </p><p>ThreadPoolExecutor采取上述步骤的总体设计思路，是为了在执行execute()方法时，尽可能地避免获取全局锁（那将会是一个严重的可伸缩瓶颈）。在ThreadPoolExecutor完成预热之后（当前运行的线程数大于等于corePoolSize），几乎所有的execute()方法调用都是执行步骤2，而步骤2不需要获取全局锁。</p><h2 id="线程池使用"><a href="#线程池使用" class="headerlink" title="线程池使用"></a>线程池使用</h2><h3 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ThreadPoolExecutor(<span class="keyword">int</span> corePoolSize,</span><br><span class="line">                   <span class="keyword">int</span> maximumPoolSize,</span><br><span class="line">                   <span class="keyword">long</span> keepAliveTime,</span><br><span class="line">                   TimeUnit unit,</span><br><span class="line">                   BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="line">                   ThreadFactory threadFactory,</span><br><span class="line">                   RejectedExecutionHandler handler)</span><br></pre></td></tr></table></figure><p>对各参数说明：</p><ol><li><p>corePoolSize（线程池的基本大小）： 当提交一个任务到线程池时，线程池会创建一个线程来执行任务，即使其他空闲的基本线程能够执行新任务也会创建线程，等到需要执行的任务数大于线程池基本大小时就不再创建。如果调用了线程池的prestartAllCoreThreads()方法，线程池会提前创建并启动所有基本线程。  </p></li><li><p>maximumPoolSize（线程池最大数量）：线程池允许创建的最大线程数。如果队列满了，并且已创建的线程数小于最大线程数，则线程池会再创建新的线程执行任务。值得注意的是，如果使用了无界的任务队列这个参数就没什么效果。（ps:无界的任务队列，队列不会满，该参数自然无效）</p></li><li><p>keepAliveTime（线程活动保持时间）：线程池的工作线程空闲后，保持存活的时间。所以，如果任务很多，并且每个任务执行的时间比较短，可以调大时间，提高线程的利用率。</p></li></ol><blockquote><p>这个说的让人感觉比较模糊，总结一下大概意思为：比如说线程池中最大的线程数为50，而其中只有40个线程任务在跑，相当于有10个空闲线程，这10个空闲线程不能让他一直在开着，因为线程的存在也会特别好资源的，所有就需要设置一个这个空闲线程的存活时间，这么解释应该就很清楚了。</p></blockquote><ol start="4"><li><p>unit（线程活动保持时间的单位）：可选的单位有天（DAYS）、小时（HOURS）、分钟（MINUTES）、毫秒（MILLISECONDS）、微秒（MICROSECONDS，千分之一毫秒）和纳秒（NANOSECONDS，千分之一微秒）。</p></li><li><p>workQueue（任务队列）：用于保存等待执行的任务的阻塞队列。可以选择以下几个阻塞队列。</p></li></ol><ul><li>ArrayBlockingQueue：是一个基于数组结构的有界阻塞队列，此队列按FIFO（先进先出）原<br>则对元素进行排序。</li><li>LinkedBlockingQueue：一个基于链表结构的阻塞队列，此队列按FIFO排序元素，吞吐量通常要高于ArrayBlockingQueue。静态工厂方法Executors.newFixedThreadPool()使用了这个队列。</li><li>SynchronousQueue：一个不存储元素的阻塞队列。每个插入操作必须等到另一个线程调用<br>移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于Linked-BlockingQueue，静态工厂方法Executors.newCachedThreadPool使用了这个队列。</li><li>PriorityBlockingQueue：一个具有优先级的无限阻塞队列。</li></ul><ol start="6"><li>threadFactory：用于设置创建线程的工厂，可以通过线程工厂给每个创建出来的线程设<br>置更有意义的名字。使用开源框架guava提供的ThreadFactoryBuilder可以快速给线程池里的线<br>程设置有意义的名字，代码如下。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> ThreadFactoryBuilder().setNameFormat(<span class="string">"XX-task-%d"</span>).build();</span><br></pre></td></tr></table></figure><ol start="7"><li>handler:（饱和策略）：当队列和线程池都满了，说明线程池处于饱和状态，那么必须采取一种策略处理提交的新任务。这个策略默认情况下是AbortPolicy，表示无法处理新任务时抛出异常。在JDK 1.5中Java线程池框架提供了以下4种策略。  </li></ol><ul><li>AbortPolicy：直接抛出异常。</li><li>CallerRunsPolicy：只用调用者所在线程来运行任务。</li><li>DiscardOldestPolicy：丢弃队列里最近的一个任务，并执行当前任务。</li><li>DiscardPolicy：不处理，丢弃掉。<br>当然，也可以根据应用场景需要来实现RejectedExecutionHandler接口自定义策略。如记录日志或持久化存储不能处理的任务。</li></ul><h3 id="向线程池提交任务"><a href="#向线程池提交任务" class="headerlink" title="向线程池提交任务"></a>向线程池提交任务</h3><p>可以使用两个方法向线程池提交任务，分别为execute()和submit()方法。</p><p>execute()方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功。<br>通过以下代码可知execute()方法输入的任务是一个Runnable类的实例。 </p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">threadsPool.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">                        &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>submit()方法用于提交需要返回值的任务。线程池会返回一个future类型的对象，通过这个future对象可以判断任务是否执行成功，并且可以通过future的get()方法来获取返回值，get()方法会阻塞当前线程直到任务完成，而使用get（long timeout，TimeUnit unit）方法则会阻塞当前线<br>程一段时间后立即返回，这时候有可能任务没有执行完。</p><pre><code class="java">Future&lt;Object&gt; future = executor.submit(harReturnValuetask);<span class="keyword">try</span> {      Object s = future.get();      } <span class="keyword">catch</span> (InterruptedException e) {      <span class="comment">// 处理中断异常</span>      } <span class="keyword">catch</span> (ExecutionException e) {      <span class="comment">// 处理无法执行任务异常</span>      } <span class="keyword">finally</span> {      <span class="comment">// 关闭线程池    </span>      executor.shutdown();   }</code></pre><h3 id="关闭线程池"><a href="#关闭线程池" class="headerlink" title="关闭线程池"></a>关闭线程池</h3><p>可以通过调用线程池的shutdown或shutdownNow方法来关闭线程池。它们的原理是遍历线程池中的工作线程，然后逐个调用线程的interrupt方法来中断线程，所以无法响应中断的任务可能永远无法终止。但是它们存在一定的区别，shutdownNow首先将线程池的状态设置成STOP，然后尝试停止所有的正在执行或暂停任务的线程，并返回等待执行任务的列表，而shutdown只是将线程池的状态设置成SHUTDOWN状态，然后中断所有没有正在执行任务的线程。  </p><p>只要调用了这两个关闭方法中的任意一个，isShutdown方法就会返回true。当所有的任务都已关闭后，才表示线程池关闭成功，这时调用isTerminaed方法会返回true。至于应该调用哪一种方法来关闭线程池，应该由提交到线程池的任务特性决定，通常调用shutdown方法来关闭线程池，如果任务不一定要执行完，则可以调用shutdownNow方法。</p><h3 id="合理配置线程池"><a href="#合理配置线程池" class="headerlink" title="合理配置线程池"></a>合理配置线程池</h3><p>要想合理地配置线程池，就必须首先分析任务特性，可以从以下几个角度来分析。 </p><p>任务的性质：CPU密集型任务、IO密集型任务和混合型任务。</p><ul><li>任务的优先级：高、中和低。</li><li>任务的执行时间：长、中和短。</li><li>任务的依赖性：是否依赖其他系统资源，如数据库连接。  </li></ul><p>性质不同的任务可以用不同规模的线程池分开处理。CPU密集型任务应配置尽可能小的线程，如配置Ncpu+1个线程的线程池。由于IO密集型任务线程并不是一直在执行任务，则应配置尽可能多的线程，如2*Ncpu。混合型的任务，如果可以拆分，将其拆分成一个CPU密集型任务和一个IO密集型任务，只要这两个任务执行的时间相差不是太大，那么分解后执行的吞吐量将高于串行执行的吞吐量。如果这两个任务执行时间相差太大，则没必要进行分解。可以通过Runtime.getRuntime().availableProcessors()方法获得当前设备的CPU个数。</p><p>优先级不同的任务可以使用优先级队列PriorityBlockingQueue来处理。它可以让优先级高<br>的任务先执行。</p><p>注意： 如果一直有优先级高的任务提交到队列里，那么优先级低的任务可能永远不能执行。</p><p>执行时间不同的任务可以交给不同规模的线程池来处理，或者可以使用优先级队列，让执行时间短的任务先执行。  </p><p>依赖数据库连接池的任务，因为线程提交SQL后需要等待数据库返回结果，等待的时间越长，则CPU空闲时间就越长，那么线程数应该设置得越大，这样才能更好地利用CPU。</p><p>建议使用有界队列。有界队列能增加系统的稳定性和预警能力，可以根据需要设大一点儿，比如几千。有一次，我们系统里后台任务线程池的队列和线程池全满了，不断抛出抛弃任务的异常，通过排查发现是数据库出现了问题，导致执行SQL变得非常缓慢，因为后台任务线程池里的任务全是需要向数据库查询和插入数据的，所以导致线程池里的工作线程全部阻塞，任务积压在线程池里。如果当时我们设置成无界队列，那么线程池的队列就会越来越多，有可能会撑满内存，导致整个系统不可用，而不只是后台任务出现问题。当然，我们的系统所有的任务是用单独的服务器部署的，我们使用不同规模的线程池完成不同类型的任务，但是出现这样问题时也会影响到其他任务。</p><h3 id="监控线程池"><a href="#监控线程池" class="headerlink" title="监控线程池"></a>监控线程池</h3><p>如果在系统中大量使用线程池，则有必要对线程池进行监控，方便在出现问题时，可以根据线程池的使用状况快速定位问题。可以通过线程池提供的参数进行监控，在监控线程池的时候可以使用以下属性。</p><ul><li>taskCount：线程池需要执行的任务数量。</li><li>completedTaskCount：线程池在运行过程中已完成的任务数量，小于或等于taskCount。</li><li>largestPoolSize：线程池里曾经创建过的最大线程数量。通过这个数据可以知道线程池是否曾经满过。如该数值等于线程池的最大大小，则表示线程池曾经满过。</li><li>getPoolSize：线程池的线程数量。如果线程池不销毁的话，线程池里的线程不会自动销毁，所以这个大小只增不减。</li><li>getActiveCount：获取活动的线程数。</li></ul><p>通过扩展线程池进行监控。可以通过继承线程池来自定义线程池，重写线程池的beforeExecute、afterExecute和terminated方法，也可以在任务执行前、执行后和线程池关闭前执行一些代码来进行监控。例如，监控任务的平均执行时间、最大执行时间和最小执行时间等。这几个方法在线程池里是空方法。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;为什么使用线程池？&quot;&gt;&lt;a href=&quot;#为什么使用线程池？&quot; class=&quot;headerlink&quot; title=&quot;为什么使用线程池？&quot;&gt;&lt;/a&gt;为什么使用线程池？&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;可以降低资源的消耗。线程池通过重复利用资源来避免创建和销毁线程带来
      
    
    </summary>
    
      <category term="java并发" scheme="http://yoursite.com/categories/java%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="java并发" scheme="http://yoursite.com/tags/java%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Exchanger使用</title>
    <link href="http://yoursite.com/2018/06/15/Exchanger%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2018/06/15/Exchanger使用/</id>
    <published>2018-06-15T10:46:00.000Z</published>
    <updated>2018-06-15T10:46:53.567Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Exchanger（交换者）是一个用于线程间协作的工具类。</p></blockquote><p>Exchanger用于进行线程间的数据交换。它提供一个同步点，在这个同步点，两个线程可以交换彼此的数据。这两个线程通过exchange方法交换数据，如果第一个线程先执行exchange()方法，它会一直等待第二个线程也执行exchange方法，当两个线程都到达同步点时，这两个线程就可以交换数据，将本线程生产出来的数据传递给对方。</p><p><strong>应用场景</strong>：</p><p>Exchanger可以用于遗传算法，遗传算法里需要选出两个人作为交配对象，这时候会交换两人的数据，并使用交叉规则得出2个交配结果。Exchanger也可以用于校对工作，比如我们需要将纸制银行流水通过人工的方式录入成电子银行流水，为了避免错误，采用AB岗两人进行录入，录入到Excel之后，系统需要加载这两个Excel，并对两个Excel数据进行校对，看看是否录入一致。</p><p><strong>代码</strong>： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> EigthChapter.Exchanger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Exchanger;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExchangerTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Exchanger&lt;String&gt; exgr = <span class="keyword">new</span> Exchanger&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ExecutorService threadPool = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        threadPool.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    String A = <span class="string">"银行流水A"</span>;<span class="comment">// A录入银行流水数据</span></span><br><span class="line">                    exgr.exchange(A);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        threadPool.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    String B = <span class="string">"银行流水B"</span>;<span class="comment">// B录入银行流水数据</span></span><br><span class="line">                    String A = exgr.exchange(<span class="string">"B"</span>);</span><br><span class="line">                    System.out.println(<span class="string">"A和B数据是否一致："</span> + A.equals(B) + <span class="string">"，A录入的是："</span> + A + <span class="string">"，B录入是："</span> + B);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        threadPool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>执行结果</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A和B数据是否一致：false，A录入的是：银行流水A，B录入是：银行流水B</span><br></pre></td></tr></table></figure><p>如果两个线程有一个没有执行exchange()方法，则会一直等待，如果担心有特殊情况发生，避免一直等待，可以使用exchange（V x，longtimeout，TimeUnit unit）设置最大等待时长。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;Exchanger（交换者）是一个用于线程间协作的工具类。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Exchanger用于进行线程间的数据交换。它提供一个同步点，在这个同步点，两个线程可以交换彼此的数据。这两个线程通过exchange方法交换数据
      
    
    </summary>
    
      <category term="java并发" scheme="http://yoursite.com/categories/java%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="java并发" scheme="http://yoursite.com/tags/java%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Semaphore使用</title>
    <link href="http://yoursite.com/2018/06/15/Semaphore/"/>
    <id>http://yoursite.com/2018/06/15/Semaphore/</id>
    <published>2018-06-15T09:36:00.000Z</published>
    <updated>2018-06-15T09:41:07.611Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Semaphore（信号量）是用来控制同时访问特定资源的线程数量，它通过协调各个线程，以保证合理的使用公共资源。</p></blockquote><p><strong>理解</strong>：</p><blockquote><p>比如××马路要限制流量，只允许同时有一百辆车在这条路上行使，其他的都必须在路口等待，所以前一百辆车会看到绿灯，可以开进这条马路，后面的车会看到红灯，不能驶入××马路，但是如果前一百辆中有5辆车已经离开了××马路，那么后面就允许有5辆车驶入马路，这个例子里说的车就是线程，驶入马路就表示线程在执行，离开马路就表示线程执行完成，看见红灯就表示线程被阻塞，不能执行。</p></blockquote><p><strong>应用场景</strong>：</p><blockquote><p>Semaphore可以用于做流量控制，特别是公用资源有限的应用场景，比如数据库连接。假如有一个需求，要读取几万个文件的数据，因为都是IO密集型任务，我们可以启动几十个线程并发地读取，但是如果读到内存后，还需要存储到数据库中，而数据库的连接数只有10个，这时我们必须控制只有10个线程同时获取数据库连接保存数据，否则会报错无法获取数据库连接。这个时候，就可以使用Semaphore来做流量控制。</p></blockquote><p><strong>代码</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> EigthChapter.Semaphore;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Semaphore;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THREAD_COUNT = <span class="number">30</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ExecutorService threadPool = Executors.newFixedThreadPool(THREAD_COUNT);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Semaphore s = <span class="keyword">new</span> Semaphore(<span class="number">10</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; THREAD_COUNT; ++i) &#123;</span><br><span class="line">            threadPool.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    s.acquire();</span><br><span class="line">                    System.out.println(<span class="string">"save data"</span>);</span><br><span class="line">                    s.release();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        threadPool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">save data</span><br><span class="line">save data</span><br><span class="line">save data</span><br><span class="line">save data</span><br><span class="line">.........</span><br></pre></td></tr></table></figure><p>在代码中，虽然有30个线程在执行，但是只允许10个并发执行。Semaphore的构造方法Semaphore（int permits）接受一个整型的数字，表示可用的许可证数量。Semaphore（10）表示允许10个线程获取许可证，也就是最大并发数是10。Semaphore的用法也很简单，首先线程使用Semaphore的acquire()方法获取一个许可证，使用完之后调用release()方法归还许可证。还可以用tryAcquire()方法尝试获取许可证。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;Semaphore（信号量）是用来控制同时访问特定资源的线程数量，它通过协调各个线程，以保证合理的使用公共资源。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;理解&lt;/strong&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;比如××马
      
    
    </summary>
    
      <category term="java并发" scheme="http://yoursite.com/categories/java%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="java并发" scheme="http://yoursite.com/tags/java%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>CyclicBarrier使用</title>
    <link href="http://yoursite.com/2018/06/14/CyclicBarrier%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2018/06/14/CyclicBarrier使用/</id>
    <published>2018-06-14T11:40:00.000Z</published>
    <updated>2018-06-14T12:09:57.320Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>CyclicBarrier的字面意思是可循环使用（Cyclic）的屏障（Barrier）。它要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续运行。</p></blockquote><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><p>CyclicBarrier默认的构造方法是CyclicBarrier(int parties)，其参数表示屏障拦截的线程数<br>量，每个线程调用await方法告诉CyclicBarrier我已经到达了屏障，然后当前线程被阻塞。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> EigthChapter.CyclicBarrier;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BrokenBarrierException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CyclicBarrier;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> CyclicBarrier c = <span class="keyword">new</span> CyclicBarrier(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    c.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            c.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">1</span><br><span class="line">-----</span><br><span class="line">1</span><br><span class="line">2</span><br></pre></td></tr></table></figure><p>因为主线程和子线程的调度是由CPU决定的，两个线程都有可能先执行，所以会产生两种输出</p><h2 id="进阶用法"><a href="#进阶用法" class="headerlink" title="进阶用法"></a>进阶用法</h2><p>CyclicBarrier还提供一个更高级的构造函数CyclicBarrier(int parties,Runnable barrierAction)，用于在线程到达屏障时，优先执行barrierAction，方便处理更复杂的业务场景</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> EigthChapter.CyclicBarrier;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BrokenBarrierException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CyclicBarrier;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierTest2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> CyclicBarrier c = <span class="keyword">new</span> CyclicBarrier(<span class="number">2</span>, <span class="keyword">new</span> A());</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    c.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        ).start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            c.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="number">3</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">1</span><br><span class="line">2</span><br></pre></td></tr></table></figure></p><p>因为CyclicBarrier设置了拦截线程的数量是2，所以必须等代码中的第一个线程和线程A都执行完之后，才会继续执行主线程，然后输出2</p><h2 id="CyclicBarrier的应用场景"><a href="#CyclicBarrier的应用场景" class="headerlink" title="CyclicBarrier的应用场景"></a>CyclicBarrier的应用场景</h2><p>CyclicBarrier可以用于多线程计算数据，最后合并计算结果的场景。</p><h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><p>用一个Excel保存了用户所有银行流水，每个Sheet保存一个账户近一年的每笔银行流水，现在需要统计用户的日均银行流水，先用多线程处理每个sheet里的银行流水，都执行完之后，得到每个sheet的日均银行流水，最后，再用barrierAction用这些线程的计算结果，计算出整个Excel的日均银行流水</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> EigthChapter.CyclicBarrier;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BankWaterService</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建4个屏障，处理完之后执行当前类的run方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> CyclicBarrier c = <span class="keyword">new</span> CyclicBarrier(<span class="number">4</span>, <span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 假设只有4个sheet，所以只启动4个线程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Executor executor = Executors.newFixedThreadPool(<span class="number">4</span>);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 保存每个sheet计算出的银流结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> ConcurrentHashMap&lt;String, Integer&gt; sheetBankWaterCount = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">count</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">            executor.execute(() -&gt; &#123;</span><br><span class="line">                 <span class="comment">//计算当前sheet的银流数据，计算代码省略</span></span><br><span class="line">                sheetBankWaterCount.put(Thread.currentThread().getName(), <span class="number">1</span>);</span><br><span class="line">                 <span class="comment">// 银流计算完成，插入一个屏障</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    c.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 汇总每个sheet计算出的结果</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, Integer&gt; entry : sheetBankWaterCount.entrySet()) &#123;</span><br><span class="line">            result += entry.getValue();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 输出结果</span></span><br><span class="line">        sheetBankWaterCount.put(<span class="string">"result"</span>, result);</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BankWaterService bankWaterService = <span class="keyword">new</span> BankWaterService();</span><br><span class="line">        bankWaterService.count();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用线程池创建4个线程，分别计算每个sheet里的数据，每个sheet计算结果是1，再由<br>BankWaterService线程汇总4个sheet计算出的结果</p><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure><h2 id="CyclicBarrier和CountDownLatch的区别"><a href="#CyclicBarrier和CountDownLatch的区别" class="headerlink" title="CyclicBarrier和CountDownLatch的区别"></a>CyclicBarrier和CountDownLatch的区别</h2><p>CountDownLatch的计数器只能使用一次，而CyclicBarrier的计数器可以使用reset()方法重置。所以CyclicBarrier能处理更为复杂的业务场景。例如，如果计算发生错误，可以重置计数器，并让线程重新执行一次。 </p><p>CyclicBarrier还提供其他有用的方法，比如getNumberWaiting方法可以获得Cyclic-Barrier阻塞的线程数量。isBroken()方法用来了解阻塞的线程是否被中断。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">package EigthChapter.CyclicBarrier;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.CyclicBarrier;</span><br><span class="line"></span><br><span class="line">public class CyclicBarrierTest3 &#123;</span><br><span class="line">    static CyclicBarrier c = new CyclicBarrier(2);</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Thread thread = new Thread(() -&gt; &#123;</span><br><span class="line">           try &#123;</span><br><span class="line">               c.await();</span><br><span class="line">           &#125; catch (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">           &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread.start();</span><br><span class="line">        thread.interrupt();</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            c.await();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            System.out.println(c.isBroken());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">true</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;CyclicBarrier的字面意思是可循环使用（Cyclic）的屏障（Barrier）。它要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续运行。&lt;/p&gt;
&lt;/b
      
    
    </summary>
    
      <category term="java并发" scheme="http://yoursite.com/categories/java%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="java并发" scheme="http://yoursite.com/tags/java%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>CountDownLatch使用</title>
    <link href="http://yoursite.com/2018/06/13/CountDownLatch%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2018/06/13/CountDownLatch使用/</id>
    <published>2018-06-13T12:20:00.000Z</published>
    <updated>2018-06-13T12:22:30.155Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>CountDownLatch允许一个或多个线程等待其他线程完成操作。</p></blockquote><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><blockquote><p>我们需要解析一个Excel里多个sheet的数据，此时可以考虑使用多<br>线程，每个线程解析一个sheet里的数据，等到所有的sheet都解析完之后，程序需要提示解析完成。</p></blockquote><h2 id="使用join方法实现"><a href="#使用join方法实现" class="headerlink" title="使用join方法实现"></a>使用join方法实现</h2><p>测试代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> EigthChapter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JoinCountDownLatchTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread parser1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"parser1 finished"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread parser2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"parser2 finished"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        parser1.start();</span><br><span class="line">        parser2.start();</span><br><span class="line">        parser1.join();</span><br><span class="line">        parser2.join();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"parser all finished"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">parser2 finished</span><br><span class="line">parser1 finished</span><br><span class="line">parser all finished</span><br></pre></td></tr></table></figure></p><p>join用于让当前执行线程等待join线程执行结束。其实现原理是不停检查join线程是否存<br>活，如果join线程存活则让当前线程永远等待。其中，wait（0）表示永远等待下去，代码片段如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">while (isAlive()) &#123;</span><br><span class="line">    wait(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用CountDownLatch方法实现"><a href="#使用CountDownLatch方法实现" class="headerlink" title="使用CountDownLatch方法实现"></a>使用CountDownLatch方法实现</h2><p>测试代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">package EigthChapter;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.CountDownLatch;</span><br><span class="line"></span><br><span class="line">public class CountDownLatchTest &#123;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException&#123;</span><br><span class="line">        CountDownLatch c = new CountDownLatch(2);</span><br><span class="line">        new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                System.out.println(1);</span><br><span class="line">                c.countDown();</span><br><span class="line">                System.out.println(2);</span><br><span class="line">                c.countDown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        c.await();</span><br><span class="line">        System.out.println(3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure><p>CountDownLatch的构造函数接收一个int类型的参数作为计数器，如果你想等待N个点完成，这里就传入N。</p><p>当我们调用CountDownLatch的countDown方法时，N就会减1，CountDownLatch的await方法会阻塞当前线程，直到N变成零。由于countDown方法可以用在任何地方，所以这里说的N个点，可以是N个线程，也可以是1个线程里的N个执行步骤。用在多个线程时，只需要把这个CountDownLatch的引用传递到线程里即可。</p><p>如果有某个解析sheet的线程处理得比较慢，我们不可能让主线程一直等待，所以可以使用另外一个带指定时间的await方法——await（long time，TimeUnit unit），这个方法等待特定时间后，就会不再阻塞当前线程。join也有类似的方法。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;CountDownLatch允许一个或多个线程等待其他线程完成操作。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h2&gt;&lt;blo
      
    
    </summary>
    
      <category term="java并发" scheme="http://yoursite.com/categories/java%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="java并发" scheme="http://yoursite.com/tags/java%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>SpringAop日志埋点</title>
    <link href="http://yoursite.com/2018/06/08/SpringAop%E6%97%A5%E5%BF%97%E5%9F%8B%E7%82%B9/"/>
    <id>http://yoursite.com/2018/06/08/SpringAop日志埋点/</id>
    <published>2018-06-08T03:13:00.000Z</published>
    <updated>2018-06-08T05:51:24.194Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>最近项目中使用了springAop来统一处理日志，总结下用法</p></blockquote><h2 id="springAop用法"><a href="#springAop用法" class="headerlink" title="springAop用法"></a>springAop用法</h2><h3 id="maven导入aspectj-jar包"><a href="#maven导入aspectj-jar包" class="headerlink" title="maven导入aspectj jar包"></a>maven导入aspectj jar包</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.aspectj&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;1.8.9&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h3 id="定义切面类"><a href="#定义切面类" class="headerlink" title="定义切面类"></a>定义切面类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Aspect</span><br><span class="line">@Component</span><br><span class="line">public class LoggingAspect &#123;</span><br><span class="line">........</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：需要通过@Component注解把切面类添加进容器中。</p><h3 id="定义切面类中的相关方法"><a href="#定义切面类中的相关方法" class="headerlink" title="定义切面类中的相关方法"></a>定义切面类中的相关方法</h3><h4 id="定义切入点表达式"><a href="#定义切入点表达式" class="headerlink" title="定义切入点表达式"></a>定义切入点表达式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 定义一个方法, 用于声明切入点表达式. 一般地, 该方法中再不需要添入其他的代码. </span><br><span class="line"> * 使用 @Pointcut 来声明切入点表达式. </span><br><span class="line"> * 后面的其他通知直接使用方法名来引用当前的切入点表达式. </span><br><span class="line"> */</span><br><span class="line">@Pointcut(&quot;execution(public int com.atguigu.spring.aop.ArithmeticCalculator.*(..))&quot;)</span><br><span class="line">public void declareJointPointExpression()&#123;&#125;</span><br></pre></td></tr></table></figure><p>定义切入点表达式是为了方便后面“通知方法的调用”，也相当于在写代码时候定义一个变量，来避免后面冗余的代码。</p><p>==定义切入点表达式有个小技巧：==</p><p>可以定义一个注解类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@Target(&#123; ElementType.METHOD, ElementType.TYPE &#125;)</span><br><span class="line">@Retention(RUNTIME)</span><br><span class="line">public @interface AopLog &#123;&#125;</span><br></pre></td></tr></table></figure></p><p>在需要植入通知的方法上加上该注解<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(value = &quot;/api/text/trans&quot;, method = RequestMethod.POST)</span><br><span class="line">@AopLog</span><br><span class="line">public ResponseResult transText(@RequestBody TransArticleAO transArticleAO,</span><br><span class="line">        @RequestHeader(&quot;appkey&quot;) String appKey) &#123;&#125;</span><br></pre></td></tr></table></figure></p><p>定义切入点表达式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@Pointcut(&quot;@annotation(com.atguigu.spring.annotation.AopLog)&quot;)</span><br><span class="line">public void OpenApiAopLogPoint() &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样可以更加灵活的给需要植入通知的方法植入通知</p><h4 id="定义前置通知方法"><a href="#定义前置通知方法" class="headerlink" title="定义前置通知方法"></a>定义前置通知方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 在 com.atguigu.spring.aop.ArithmeticCalculator 接口的每一个实现类的每一个方法开始之前执行一段代码</span><br><span class="line"> */</span><br><span class="line">@Before(&quot;declareJointPointExpression()&quot;)</span><br><span class="line">public void beforeMethod(JoinPoint joinPoint)&#123;</span><br><span class="line">String methodName = joinPoint.getSignature().getName();</span><br><span class="line">Object [] args = joinPoint.getArgs();</span><br><span class="line">System.out.println(&quot;The method &quot; + methodName + &quot; begins with &quot; + Arrays.asList(args));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="定义后置通知方法"><a href="#定义后置通知方法" class="headerlink" title="定义后置通知方法"></a>定义后置通知方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 在方法执行之后执行的代码. 无论该方法是否出现异常</span><br><span class="line"> */</span><br><span class="line">@After(&quot;declareJointPointExpression()&quot;)</span><br><span class="line">public void afterMethod(JoinPoint joinPoint)&#123;</span><br><span class="line">String methodName = joinPoint.getSignature().getName();</span><br><span class="line">System.out.println(&quot;The method &quot; + methodName + &quot; ends&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="定义返回通知方法"><a href="#定义返回通知方法" class="headerlink" title="定义返回通知方法"></a>定义返回通知方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 在方法法正常结束后执行的代码</span><br><span class="line"> * 返回通知是可以访问到方法的返回值的!</span><br><span class="line"> */</span><br><span class="line">@AfterReturning(value=&quot;declareJointPointExpression()&quot;,</span><br><span class="line">returning=&quot;result&quot;)</span><br><span class="line">public void afterReturning(JoinPoint joinPoint, Object result)&#123;</span><br><span class="line">String methodName = joinPoint.getSignature().getName();</span><br><span class="line">System.out.println(&quot;The method &quot; + methodName + &quot; ends with &quot; + result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="定义异常通知方法"><a href="#定义异常通知方法" class="headerlink" title="定义异常通知方法"></a>定义异常通知方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 在目标方法出现异常时会执行的代码.</span><br><span class="line"> * 可以访问到异常对象; 且可以指定在出现特定异常时再执行通知代码</span><br><span class="line"> */</span><br><span class="line">@AfterThrowing(value=&quot;declareJointPointExpression()&quot;,</span><br><span class="line">throwing=&quot;e&quot;)</span><br><span class="line">public void afterThrowing(JoinPoint joinPoint, Exception e)&#123;</span><br><span class="line">String methodName = joinPoint.getSignature().getName();</span><br><span class="line">System.out.println(&quot;The method &quot; + methodName + &quot; occurs excetion:&quot; + e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="定义环绕通知方法"><a href="#定义环绕通知方法" class="headerlink" title="定义环绕通知方法"></a>定义环绕通知方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 环绕通知需要携带 ProceedingJoinPoint 类型的参数. </span><br><span class="line"> * 环绕通知类似于动态代理的全过程: ProceedingJoinPoint 类型的参数可以决定是否执行目标方法.</span><br><span class="line"> * 且环绕通知必须有返回值, 返回值即为目标方法的返回值</span><br><span class="line"> */</span><br><span class="line">/*</span><br><span class="line">@Around(&quot;execution(public int com.atguigu.spring.aop.ArithmeticCalculator.*(..))&quot;)</span><br><span class="line">public Object aroundMethod(ProceedingJoinPoint pjd)&#123;</span><br><span class="line"></span><br><span class="line">Object result = null;</span><br><span class="line">String methodName = pjd.getSignature().getName();</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line">//前置通知</span><br><span class="line">System.out.println(&quot;The method &quot; + methodName + &quot; begins with &quot; + Arrays.asList(pjd.getArgs()));</span><br><span class="line">//执行目标方法</span><br><span class="line">result = pjd.proceed();</span><br><span class="line">//返回通知</span><br><span class="line">System.out.println(&quot;The method &quot; + methodName + &quot; ends with &quot; + result);</span><br><span class="line">&#125; catch (Throwable e) &#123;</span><br><span class="line">//异常通知</span><br><span class="line">System.out.println(&quot;The method &quot; + methodName + &quot; occurs exception:&quot; + e);</span><br><span class="line">throw new RuntimeException(e);</span><br><span class="line">&#125;</span><br><span class="line">//后置通知</span><br><span class="line">System.out.println(&quot;The method &quot; + methodName + &quot; ends&quot;);</span><br><span class="line"></span><br><span class="line">return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>环绕通知是前面几种通知的融合。但是需要注意的是环绕通知方法是有返回值的，如果不设置返回值，会影响目标方法的结果返回。</p><p>上面几种方法可以根据实际情况在代码中使用。</p><h2 id="log4j配置日志单独打印到独立文件中"><a href="#log4j配置日志单独打印到独立文件中" class="headerlink" title="log4j配置日志单独打印到独立文件中"></a>log4j配置日志单独打印到独立文件中</h2><p>在log4j配置文件中添加如下配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//配置单独打印到的日志目录别名，日志级别等</span><br><span class="line">log4j.logger.com.netease.mind.nmt.aop=$&#123;log4j.level&#125;, aop</span><br><span class="line">log4j.additivity.com.netease.mind.nmt.aop=false</span><br><span class="line">log4j.appender.aop=org.apache.log4j.DailyRollingFileAppender</span><br><span class="line">log4j.appender.aop.DatePattern=&apos;_&apos;yyyy-MM-dd</span><br><span class="line">log4j.appender.aop.File=$&#123;log4j.path&#125;/nmtp_aop.log</span><br><span class="line">log4j.appender.aop.Append=true</span><br><span class="line">log4j.appender.aop.Threshold=$&#123;log4j.level&#125;</span><br><span class="line">log4j.appender.aop.layout=org.apache.log4j.PatternLayout</span><br><span class="line">log4j.appender.aop.layout.ConversionPattern=%m%n</span><br></pre></td></tr></table></figure><p>日志具体参数参考：<a href="https://blog.csdn.net/foreverling/article/details/51385128" target="_blank" rel="noopener">https://blog.csdn.net/foreverling/article/details/51385128</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;最近项目中使用了springAop来统一处理日志，总结下用法&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;springAop用法&quot;&gt;&lt;a href=&quot;#springAop用法&quot; class=&quot;headerlink&quot; title=&quot;sprin
      
    
    </summary>
    
      <category term="日志" scheme="http://yoursite.com/categories/%E6%97%A5%E5%BF%97/"/>
    
    
      <category term="springAop" scheme="http://yoursite.com/tags/springAop/"/>
    
      <category term="日志" scheme="http://yoursite.com/tags/%E6%97%A5%E5%BF%97/"/>
    
  </entry>
  
  <entry>
    <title>日志组件slf4j结合log4j使用</title>
    <link href="http://yoursite.com/2018/06/01/%E6%97%A5%E5%BF%97%E7%BB%84%E4%BB%B6slfj4%E7%BB%93%E5%90%88log4j%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2018/06/01/日志组件slfj4结合log4j使用/</id>
    <published>2018-06-01T08:56:00.000Z</published>
    <updated>2018-06-08T05:41:51.006Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>总结下slf4j和log4j日志框架的使用</p></blockquote><p>参考：<a href="https://www.cnblogs.com/ywlaker/p/6124067.html" target="_blank" rel="noopener">java日志框架log4j详细配置及与slf4j联合使用教程</a></p><p>参考：<a href="https://www.cnblogs.com/yidaxia/p/5820036.html" target="_blank" rel="noopener">Log4j将不同Package的日志输出到不同的文件</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;总结下slf4j和log4j日志框架的使用&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;参考：&lt;a href=&quot;https://www.cnblogs.com/ywlaker/p/6124067.html&quot; target=&quot;_blank&quot; rel=&quot;
      
    
    </summary>
    
    
      <category term="日志" scheme="http://yoursite.com/tags/%E6%97%A5%E5%BF%97/"/>
    
  </entry>
  
  <entry>
    <title>Quartz任务调度框架简单使用</title>
    <link href="http://yoursite.com/2018/05/31/Quartz%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E6%A1%86%E6%9E%B6%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2018/05/31/Quartz任务调度框架简单使用/</id>
    <published>2018-05-31T08:59:00.000Z</published>
    <updated>2018-05-31T11:32:32.996Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Quartz是什么？"><a href="#Quartz是什么？" class="headerlink" title="Quartz是什么？"></a>Quartz是什么？</h2><p>Quartz是一个任务调度框架！<br><br>Quartz是一个任务调度框架!!<br><br>Quartz是一个任务调度框架!!!  </p><h2 id="为什么使用Quartz？"><a href="#为什么使用Quartz？" class="headerlink" title="为什么使用Quartz？"></a>为什么使用Quartz？</h2><p>你可能遇到这样的问题：</p><ol><li>想每月25号，信用卡自动还款</li><li>想每年4月1日自己给当年暗恋女神发一封匿名贺卡</li><li>想每隔1小时，备份一下自己的学习笔记到云盘  </li></ol><p>这些问题总结起来就是：在某一个有规律的时间点干某件事。并且时间的触发的条件可以非常复杂（比如每月最后一个工作日的17:50），复杂到需要一个专门的框架来干这个事。 Quartz就是来干这样的事，你给它一个触发条件的定义，它负责到了时间点，触发相应的Job起来干活。</p><h2 id="搭建一个简单demo？"><a href="#搭建一个简单demo？" class="headerlink" title="搭建一个简单demo？"></a>搭建一个简单demo？</h2><h3 id="maven导入jar包"><a href="#maven导入jar包" class="headerlink" title="maven导入jar包"></a>maven导入jar包</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.quartz-scheduler&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;quartz&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;2.2.1&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.quartz-scheduler&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;quartz-jobs&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;2.2.1&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure><h3 id="编写测试用例"><a href="#编写测试用例" class="headerlink" title="编写测试用例"></a>编写测试用例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> top.miao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.quartz.JobBuilder.newJob;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.quartz.SimpleScheduleBuilder.simpleSchedule;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.quartz.TriggerBuilder.newTrigger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.quartz.JobDetail;</span><br><span class="line"><span class="keyword">import</span> org.quartz.Scheduler;</span><br><span class="line"><span class="keyword">import</span> org.quartz.Trigger;</span><br><span class="line"><span class="keyword">import</span> org.quartz.impl.StdSchedulerFactory;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zhangmiao3</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: quartz测试</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 11:47 2018/5/30</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuartzTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建scheduler</span></span><br><span class="line">            Scheduler scheduler = StdSchedulerFactory.getDefaultScheduler();</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 定义一个Trigger</span></span><br><span class="line"><span class="comment">               1、定义name/group</span></span><br><span class="line"><span class="comment">               2、一旦加入scheduler，立即生效</span></span><br><span class="line"><span class="comment">               3、使用SimpleTrigger</span></span><br><span class="line"><span class="comment">               4、一直执行，奔腾到老不停歇</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            Trigger trigger = newTrigger().withIdentity(<span class="string">"trigger1"</span>, <span class="string">"group1"</span>)</span><br><span class="line">                    .startNow()</span><br><span class="line">                    .withSchedule(simpleSchedule()</span><br><span class="line">                            .withIntervalInSeconds(<span class="number">1</span>)</span><br><span class="line">                            .repeatForever())</span><br><span class="line">                    .build();</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 定义一个JobDetail</span></span><br><span class="line"><span class="comment">               1、定义Job类为HelloQuartz类，这是真正的执行逻辑所在</span></span><br><span class="line"><span class="comment">               2、定义name/group</span></span><br><span class="line"><span class="comment">               3、定义属性</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            JobDetail job = newJob(HelloQuartz.class)</span><br><span class="line">                    .withIdentity(<span class="string">"job1"</span>, <span class="string">"group1"</span>)</span><br><span class="line">                    .usingJobData(<span class="string">"name"</span>, <span class="string">"quartz"</span>)</span><br><span class="line">                    .build();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//加入这个调度</span></span><br><span class="line">            scheduler.scheduleJob(job, trigger);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//启动之</span></span><br><span class="line">            scheduler.start();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//运行一段时间后关闭</span></span><br><span class="line">            Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">            scheduler.shutdown(<span class="keyword">true</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">package top.miao;</span><br><span class="line">import java.util.Date;</span><br><span class="line"></span><br><span class="line">import org.quartz.Job;</span><br><span class="line">import org.quartz.JobDetail;</span><br><span class="line">import org.quartz.JobExecutionContext;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author zhangmiao3</span><br><span class="line"> * @Description:</span><br><span class="line"> * @date 11:49 2018/5/30</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">public class HelloQuartz implements Job &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void execute(JobExecutionContext context) &#123;</span><br><span class="line">        JobDetail detail = context.getJobDetail();</span><br><span class="line">        String name = detail.getJobDataMap().getString(&quot;name&quot;);</span><br><span class="line">        System.out.println(&quot;say hello to &quot; + name + &quot; at &quot; + new Date());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h3><p><img src="http://owq01tqh9.bkt.clouddn.com/quartz1.png" alt="image"></p><p>job每秒执行一次</p><h3 id="分析说明"><a href="#分析说明" class="headerlink" title="分析说明"></a>分析说明</h3><p>这个例子很好的覆盖了Quartz最重要的3个基本要素：</p><ol><li>Scheduler：调度器。所有的调度都是由它控制。</li><li>Trigger： 定义触发的条件。例子中，它的类型是SimpleTrigger，每隔1秒中执行一次（什么是SimpleTrigger下面会有详述）。</li><li>JobDetail &amp; Job： JobDetail 定义的是任务数据，而真正的执行逻辑是在Job中，例子中是HelloQuartz。 为什么设计成JobDetail + Job，不直接使用Job？这是因为任务是有可能并发执行，如果Scheduler直接使用Job，就会存在对同一个Job实例并发访问的问题。而JobDetail &amp; Job 方式，sheduler每次执行，都会根据JobDetail创建一个新的Job实例，这样就可以规避并发访问的问题。</li></ol><p>参考： <a href="https://www.cnblogs.com/drift-ice/p/3817269.html" target="_blank" rel="noopener">Quartz使用总结</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Quartz是什么？&quot;&gt;&lt;a href=&quot;#Quartz是什么？&quot; class=&quot;headerlink&quot; title=&quot;Quartz是什么？&quot;&gt;&lt;/a&gt;Quartz是什么？&lt;/h2&gt;&lt;p&gt;Quartz是一个任务调度框架！&lt;br&gt;&lt;br&gt;Quartz是一个任务调度框
      
    
    </summary>
    
      <category term="Quartz" scheme="http://yoursite.com/categories/Quartz/"/>
    
    
      <category term="Quartz" scheme="http://yoursite.com/tags/Quartz/"/>
    
  </entry>
  
  <entry>
    <title>spring websocket使用总结</title>
    <link href="http://yoursite.com/2018/05/29/spring-websocket%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2018/05/29/spring-websocket使用总结/</id>
    <published>2018-05-29T08:02:00.000Z</published>
    <updated>2018-05-30T02:14:28.640Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>最近使用了下websocket，总结下~</p></blockquote><h2 id="websocket原理概念"><a href="#websocket原理概念" class="headerlink" title="websocket原理概念"></a>websocket原理概念</h2><p>WebSocket是HTML5提供的一种全双工通信的协议，通常是浏览器（或其他客户端）与Web服务器之间的通信。这使得它适合于高度交互的Web应用程序，如及时通讯聊天等。<br>相比较于Http的短连接，Websocket的作用是可以保持长连接，也就是服务器也能够向客户端发送信息。从而实现了全双工通讯。</p><p>具体原理可以参考：<a href="http://www.ruanyifeng.com/blog/2017/05/websocket.html" target="_blank" rel="noopener">阮一峰的websocket原理讲解</a></p><h2 id="实现websocket客户端的两种方式"><a href="#实现websocket客户端的两种方式" class="headerlink" title="实现websocket客户端的两种方式"></a>实现websocket客户端的两种方式</h2><h3 id="js实现"><a href="#js实现" class="headerlink" title="js实现"></a>js实现</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">    <span class="keyword">var</span> websocket = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">//判断当前浏览器是否支持WebSocket</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="string">'WebSocket'</span> <span class="keyword">in</span> <span class="built_in">window</span>) &#123;</span><br><span class="line">        <span class="comment">//websocket协议格式用ws / wss(加密)开始，可以类比http协议</span></span><br><span class="line">        websocket = <span class="keyword">new</span> WebSocket(<span class="string">"ws://localhost:8088/ws/api/audiostream?appkey=zzzz&amp;lan=zh&amp;trans=0"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//连接成功建立的回调方法</span></span><br><span class="line">        websocket.onopen = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="comment">//给ws服务端发送消息</span></span><br><span class="line">            websocket.send(<span class="string">"客户端链接成功"</span>);</span><br><span class="line">            websocket.send(<span class="string">"Hello"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//接收到消息的回调方法</span></span><br><span class="line">        websocket.onmessage = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">            <span class="comment">//处理接收到的消息</span></span><br><span class="line">            doSomething(event.data);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//连接发生错误的回调方法</span></span><br><span class="line">        websocket.onerror = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            alert(<span class="string">"WebSocket连接发生错误"</span>);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//连接关闭的回调方法</span></span><br><span class="line">        websocket.onclose = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        alert(<span class="string">"WebSocket连接关闭"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//监听窗口关闭事件，当窗口关闭时，主动去关闭websocket连接，防止连接还没断开就关闭窗口，server端会抛异常。</span></span><br><span class="line">        <span class="built_in">window</span>.onbeforeunload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            closeWebSocket();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        alert(<span class="string">'当前浏览器 Not support websocket'</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//处理消息</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params">innerHTML</span>) </span>&#123;</span><br><span class="line">        <span class="comment">//......</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//关闭WebSocket连接</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">closeWebSocket</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        websocket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><h3 id="java实现"><a href="#java实现" class="headerlink" title="java实现"></a>java实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.java_websocket.client.WebSocketClient;</span><br><span class="line"><span class="keyword">import</span> org.java_websocket.drafts.Draft_17;</span><br><span class="line"><span class="keyword">import</span> org.java_websocket.WebSocket.READYSTATE;</span><br><span class="line"><span class="keyword">import</span> org.java_websocket.handshake.ServerHandshake;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSocketClientTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> WebSocketClient client;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> URISyntaxException, NotYetConnectedException, UnsupportedEncodingException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// new Draft_17()一定要加上</span></span><br><span class="line">        client = <span class="keyword">new</span> WebSocketClient(<span class="keyword">new</span> URI(<span class="string">"ws://localhost:8088/ws/api/audiostream?appkey=zzzz&amp;lan=zh&amp;trans=0"</span>), <span class="keyword">new</span> Draft_17()) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onOpen</span><span class="params">(ServerHandshake serverHandshake)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"打开链接"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(String arg0)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"收到消息:"</span> + arg0);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Exception arg0)</span> </span>&#123;</span><br><span class="line">                arg0.printStackTrace();</span><br><span class="line">                System.out.println(<span class="string">"发生错误已关闭"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClose</span><span class="params">(<span class="keyword">int</span> arg0, String arg1, <span class="keyword">boolean</span> arg2)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"链接已关闭"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(ByteBuffer bytes)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="keyword">new</span> String(bytes.array(), <span class="string">"utf-8"</span>));</span><br><span class="line">                &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        client.connect();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!client.getReadyState().equals(READYSTATE.OPEN)) &#123;</span><br><span class="line">            System.out.println(<span class="string">"还没有打开"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">"打开了"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//发送json文本信息</span></span><br><span class="line">        sendTextMessage(JSON.toJSONString(<span class="string">"hello"</span>));</span><br><span class="line">        <span class="comment">//发送二进制信息</span></span><br><span class="line">        sendByte(<span class="string">""</span>.getBytes());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sendByte</span><span class="params">(<span class="keyword">byte</span>[] bytes)</span> </span>&#123;</span><br><span class="line">        client.send(bytes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sendTextMessage</span><span class="params">(String jsonString)</span> </span>&#123;</span><br><span class="line">        client.send(jsonString);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="用spring-websocket处理websocket客户端发送过来的信息"><a href="#用spring-websocket处理websocket客户端发送过来的信息" class="headerlink" title="用spring websocket处理websocket客户端发送过来的信息"></a>用spring websocket处理websocket客户端发送过来的信息</h2><h3 id="导入-maven-jar包"><a href="#导入-maven-jar包" class="headerlink" title="导入 maven jar包"></a>导入 maven jar包</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-websocket&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h3 id="添加配置类"><a href="#添加配置类" class="headerlink" title="添加配置类"></a>添加配置类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableWebSocket</span><br><span class="line">public class WebSocketConfig implements WebSocketConfigurer &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void registerWebSocketHandlers(WebSocketHandlerRegistry registry) &#123;</span><br><span class="line">        // 注册拦截器</span><br><span class="line">        // 注册webSocket url和处理器映射关系</span><br><span class="line">        registry.addHandler(audioStreamWebSocketHandler(), &quot;/ws/audiostream&quot;)</span><br><span class="line">                .addHandler(audioStreamOpenApiWebSocketHandler(), &quot;/ws/api/audiostream&quot;)</span><br><span class="line">                .addInterceptors(myAudioStreamInterceptor());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public AudioStreamWebSocketHandler audioStreamWebSocketHandler() &#123;</span><br><span class="line">        return new AudioStreamWebSocketHandler();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public AudioStreamOpenApiWebSocketHandler audioStreamOpenApiWebSocketHandler() &#123;</span><br><span class="line">        return new AudioStreamOpenApiWebSocketHandler();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public AudioStreamWebSocketHandshakeInterceptor myAudioStreamInterceptor() &#123;</span><br><span class="line">        return new AudioStreamWebSocketHandshakeInterceptor();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="配置拦截器和处理器"><a href="#配置拦截器和处理器" class="headerlink" title="配置拦截器和处理器"></a>配置拦截器和处理器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">// 拦截器</span><br><span class="line">public class AudioStreamWebSocketHandshakeInterceptor implements HandshakeInterceptor &#123;</span><br><span class="line"></span><br><span class="line">    private static final Logger LOGGER = Logger.getLogger(AudioStreamWebSocketHandshakeInterceptor.class);</span><br><span class="line"></span><br><span class="line">    //握手前处理请求</span><br><span class="line">    @Override</span><br><span class="line">    public boolean beforeHandshake(ServerHttpRequest request, ServerHttpResponse response, WebSocketHandler wsHandler,</span><br><span class="line">            Map&lt;String, Object&gt; attributes) throws Exception &#123;</span><br><span class="line">        if (request instanceof ServletServerHttpRequest) &#123;</span><br><span class="line">            ServletServerHttpRequest serverHttpRequest = (ServletServerHttpRequest) request;</span><br><span class="line">            ServletServerHttpResponse serverHttpResponse = (ServletServerHttpResponse) response;</span><br><span class="line">            // 转化为servlet request和response</span><br><span class="line">            HttpServletRequest servletRequest = serverHttpRequest.getServletRequest();</span><br><span class="line">            HttpServletResponse servletResponse = serverHttpResponse.getServletResponse();</span><br><span class="line">            // 获取http session</span><br><span class="line">            HttpSession httpSession = servletRequest.getSession();</span><br><span class="line">            String uri = servletRequest.getRequestURI();</span><br><span class="line">            if (&quot;/ws/api/audiostream&quot;.equals(uri)) &#123;</span><br><span class="line">                String appkey = servletRequest.getParameter(&quot;appkey&quot;);</span><br><span class="line">                String lan = servletRequest.getParameter(&quot;lan&quot;);</span><br><span class="line">                String trans = servletRequest.getParameter(&quot;trans&quot;);</span><br><span class="line">                if (StringUtils.isBlank(appkey) || StringUtils.isBlank(lan) || StringUtils.isBlank(trans)) &#123;</span><br><span class="line">                    LOGGER.error(&quot;直播ws开放接口传参错误！&quot;);</span><br><span class="line">                    return false;</span><br><span class="line">                &#125;</span><br><span class="line">                attributes.put(&quot;appkey&quot;, appkey);</span><br><span class="line">                attributes.put(&quot;lan&quot;, lan);</span><br><span class="line">                attributes.put(&quot;trans&quot;, trans);</span><br><span class="line">            &#125; else if (&quot;/ws/audiostream&quot;.equals(uri)) &#123;</span><br><span class="line">                String liveId = servletRequest.getParameter(&quot;liveId&quot;);</span><br><span class="line">                if (StringUtils.isBlank(liveId)) &#123;</span><br><span class="line">                    LOGGER.error(&quot;直播id不能为空！&quot;);</span><br><span class="line">                    return false;</span><br><span class="line">                &#125;</span><br><span class="line">                attributes.put(&quot;liveId&quot;, liveId);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void afterHandshake(ServerHttpRequest request, ServerHttpResponse response, WebSocketHandler wsHandler,</span><br><span class="line">            Exception exception) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AudioStreamWebSocketHandler</span> <span class="keyword">extends</span> <span class="title">TextWebSocketHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听连接状态</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterConnectionEstablished</span><span class="params">(WebSocketSession session)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"websocket建立连接成功"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理接收到的文本信息</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleTextMessage</span><span class="params">(WebSocketSession session, TextMessage message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!session.isOpen())</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        System.out.println(<span class="string">"收到的文本信息为: "</span> + message.getPayload());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断心跳，检查服务器状态</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">handlePongMessage</span><span class="params">(WebSocketSession session, PongMessage message)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!session.isOpen())</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">super</span>.handlePongMessage(session, message);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 处理接收到的二进制信息</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">handleBinaryMessage</span><span class="params">(WebSocketSession session, BinaryMessage message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!session.isOpen())</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        ByteBuffer byteBuffer = message.getPayload();</span><br><span class="line">        <span class="keyword">byte</span>[] data = byteBuffer.array();</span><br><span class="line">        System.out.println(<span class="string">"收到的二进制消息为: "</span> + data)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听连接异常信息</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleTransportError</span><span class="params">(WebSocketSession session, Throwable exception)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (session.isOpen()) &#123;</span><br><span class="line">            session.close();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"websocket连接出错！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听连接关闭信息</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterConnectionClosed</span><span class="params">(WebSocketSession session, CloseStatus status)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (status.getCode() == MyCloseStatus.LIVE_REPEATABLE_ERROR.getCode()</span><br><span class="line">                || status.getCode() == MyCloseStatus.LIVE_END_NORMALLY.getCode()</span><br><span class="line">                || status.getCode() == MyCloseStatus.LIVE_STATUS_ERROR.getCode()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 处理一些释放资源操作</span></span><br><span class="line">        ..............</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送消息返回给客户端</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(WebSocketSession session, String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (session.isOpen()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                session.sendMessage(<span class="keyword">new</span> TextMessage(message));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                LOGGER.error(<span class="string">"发送消息失败"</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;最近使用了下websocket，总结下~&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;websocket原理概念&quot;&gt;&lt;a href=&quot;#websocket原理概念&quot; class=&quot;headerlink&quot; title=&quot;websocket原理
      
    
    </summary>
    
      <category term="websocket" scheme="http://yoursite.com/categories/websocket/"/>
    
    
      <category term="websocket" scheme="http://yoursite.com/tags/websocket/"/>
    
  </entry>
  
  <entry>
    <title>hexo博客搭建</title>
    <link href="http://yoursite.com/2018/04/29/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    <id>http://yoursite.com/2018/04/29/hexo博客搭建/</id>
    <published>2018-04-29T13:16:00.000Z</published>
    <updated>2018-05-21T09:11:41.686Z</updated>
    
    <content type="html"><![CDATA[<p> <a href="http://www.cnblogs.com/liuxianan/p/build-blog-website-by-hexo-github.html" target="_blank" rel="noopener">1、搭建博客</a>  </p><ul><li>软件安装(git、nodejs、github配置、hexo安装、域名配置)</li><li>参数设置（具体参数设置参考<a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">Hexo官方文档</a>）</li><li>主题配置  </li></ul><p><a href="https://blog.csdn.net/qq_33699981/article/details/72716951" target="_blank" rel="noopener">2、Next主题个性化</a>　  </p><p><a href="https://www.jianshu.com/p/68e727dda16d" target="_blank" rel="noopener">3、安装Hexo-admin方便管理博客</a></p><p><a href="https://www.zhihu.com/question/21193762" target="_blank" rel="noopener">4、利用分支策略来实现多机编辑博客</a></p><p><a href="https://segmentfault.com/q/1010000011773268" target="_blank" rel="noopener">5、给域名添加https(小绿锁)</a></p><p>博客效果如下：<br><img src="http://owq01tqh9.bkt.clouddn.com/hexo%E5%8D%9A%E5%AE%A2%E6%95%88%E6%9E%9C%E6%88%AA%E5%9B%BE.png" alt="图片飞走啦~"></p>]]></content>
    
    <summary type="html">
    
      将之前搭建博客的过程记录下，方便大家自己搭建博客。
    
    </summary>
    
      <category term="搭博客" scheme="http://yoursite.com/categories/%E6%90%AD%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="Hexo博客" scheme="http://yoursite.com/tags/Hexo%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>mysql必知必会读书笔记</title>
    <link href="http://yoursite.com/2018/04/25/mysql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2018/04/25/mysql必知必会笔记/</id>
    <published>2018-04-25T02:26:00.000Z</published>
    <updated>2018-05-21T09:11:41.691Z</updated>
    
    <content type="html"><![CDATA[<h3 id="基本知识"><a href="#基本知识" class="headerlink" title="基本知识"></a>基本知识</h3><ol><li><p>关系数据库设计把数据存储在多个表中，使数据更容易操纵、维护和重用。不用深究如何以及为什么进行关系数据库设计，在某种程度上说，设计良好的数据库模式都是关联的。</p></li><li><p>help show | select | update …; 查看相关命令的帮助</p></li><li><p>MySql语句都以（；）结尾。（多条SQL语句必须以分号（；）分隔。 MySQL如同多数DBMS一样，不需要在单条SQL语句后加分号。但特定的DBMS可能必须在单条SQL语句后加上分号。当然，如果愿意可以总是加上分号。事实上，即使不一定需要，但加上分号肯定没有坏处。如果你使用的是mysql命令行，必须加上分号来结束SQL语句。）</p></li><li><p>对所有SQL关键字使用大写，而对所有列和表名使用小写。（SQL语句不区分大小写，因此SELECT与select是相同的。同样，写成Select也没有关系。许多SQL开发人员喜欢对所有SQL关键字使用大写，而对所有列和表名使用小写，这样做使代码更易于阅读和调试。）</p></li><li><p>将SQL语句分成多行更容易阅读和调试。（使用空格 在处理SQL语句时，其中所有空格都被忽略。 SQL语句可以在一行上给出，也可以分成许多行。多数SQL开发人员认为将SQL语句分成多行更容易阅读和调试。）</p></li></ol><hr><h3 id="连接MySQL数据库"><a href="#连接MySQL数据库" class="headerlink" title="连接MySQL数据库"></a>连接MySQL数据库</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql –u用户名 [–h主机名或者IP地址] –p密码</span><br></pre></td></tr></table></figure><p>说明：用户名是你登录的用户，主机名或者IP地址为可选项，如果是本地连接则不需要，远程连接需要填写，端口默认是3306，否则需要填写端口号，密码是对应用户的密码。</p><p>注意：</p><ol><li>该命令是在Windows命令行窗口下执行，而不是MySQL的命令行；  </li><li>输入-p后可以直接跟上密码，也可以按回车，会提示你输入密码，二者都是相同的效果；</li><li>–p密码选项不一定是要在最后；</li><li>–u、-h、-p后无空格。</li></ol><hr><h3 id="数据库基本操作"><a href="#数据库基本操作" class="headerlink" title="数据库基本操作"></a>数据库基本操作</h3><h4 id="选择数据库"><a href="#选择数据库" class="headerlink" title="选择数据库"></a>选择数据库</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">USE</span> 数据库名; </span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">注意： 必须先使用<span class="keyword">USE</span>打开数据库，才能读取其中的数据。</span><br><span class="line"></span><br><span class="line">#### <span class="number">2.</span> 显示数据库和表</span><br><span class="line"><span class="string">``</span><span class="string">`SQL</span></span><br><span class="line"><span class="string">SHOW DATABASES;</span></span><br></pre></td></tr></table></figure><p>说明：返回可用数据库的一个列表。包含在这个列<br>表中的可能有MySQL内部使用的数据库。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">TABLES</span>;</span><br></pre></td></tr></table></figure><p>说明：返回当前选择的数据库内可用表的列表。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">COLUMNS</span> <span class="keyword">FROM</span> 表名;  </span><br><span class="line"><span class="keyword">DESCRIBE</span> 表名;（更快捷的方式）</span><br></pre></td></tr></table></figure><p>说明：要求给出一个表名，它对每个字段返回一行，行中包含字段名、数据类型、是否允许NULL、键信息、默认值以及其他信息。</p><hr><h3 id="数据查询"><a href="#数据查询" class="headerlink" title="数据查询"></a>数据查询</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 列名 <span class="keyword">FROM</span> 表名;</span><br></pre></td></tr></table></figure><p>说明：上述语句利用SELECT语句从表中检索一列。所需的列名在SELECT关键字之后给出， FROM关键字指出从其中检索数据的表名。</p><p>注意：如果没有明确排序查询结果，则返回的数据的顺序没有特殊意义。返回数据的顺序可能是数据被添加到表中的顺序，也可能不是。只要返回相同数目的行，就是正常的。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 列名<span class="number">1</span>, 列名<span class="number">2</span>, 列名<span class="number">3</span> <span class="keyword">FROM</span> 表名;</span><br></pre></td></tr></table></figure><p>说明：这条语句使用SELECT语句从表中选择数据。在这个例子中，指定了3个列名，列名之间用逗号分隔。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> 表名;</span><br></pre></td></tr></table></figure><p>说明：如果给定一个通配符（*），则返回表中所有列。列的顺序一般是列在表定义中出现的顺序。但有时候并不是这样的，表的模式的变化（如添加或删除列）可能会导致顺序的变化。</p><p>注意：</p><ol><li>一般，除非你确实需要表中的每个列，否则最好别使用*通配符。虽然使用通配符可能会使你自己省事，不用明确列出所需列，但检索不需要的列通常会降低检索和应用程序的性能。</li><li>使用通配符有一个大优点。由于不明确指定列名（因为星号检索每个列），所以能检索出名字未知的列。</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> 列名 <span class="keyword">FROM</span> 表名;</span><br></pre></td></tr></table></figure><p>说明：SELECT DISTINCT列名告诉MySQL只返回不同（唯一）的对应列名的行，去掉重复行，如果使用DISTINCT关键字，它必须直接放在列名的前面。</p><p>注意：不能部分使用DISTINCT，DISTINCT关键字应用于所有列而不仅是前置它的列。如果给出SELECT DISTINCT 列1,列2，除非指定的两个列都不同，否则所有行都将被检索出来。 </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 列名 <span class="keyword">FROM</span> 表名 <span class="keyword">LIMIT</span> <span class="number">5</span>, <span class="number">5</span>;   </span><br><span class="line"><span class="keyword">SELECT</span> 列名 <span class="keyword">FROM</span> 表名 <span class="keyword">LIMIT</span> <span class="number">5</span>;</span><br></pre></td></tr></table></figure><p>说明：</p><ol><li>LIMIT 5, 5指示MySQL返回从行5开始的5行。第一个数为开始位置，第二个数为要检索的行数。</li><li>LIMIT 5 指示MySQL返回不多于5行。</li></ol><p>注意：</p><ol><li>行0检索出来的第一行为行0而不是行1。因此，LIMIT 1, 1将检索出第二行而不是第一行。</li><li>在行数不够时，LIMIT中指定要检索的行数为检索的最大行数。如果没有足够的行（例如，给出LIMIT 10, 5，但只有13行），MySQL将只返回它能返回的那么多行。</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 表名.列名 <span class="keyword">FROM</span> 数据库名.表名;</span><br></pre></td></tr></table></figure><p>说明：指定了一个完全限定的列名和表名。</p><h3 id="排序查询数据"><a href="#排序查询数据" class="headerlink" title="排序查询数据"></a>排序查询数据</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 列名 <span class="keyword">FROM</span> 表名 <span class="keyword">ORDER</span> <span class="keyword">BY</span> 列名;</span><br></pre></td></tr></table></figure><p>说明：将输出的结果根据列进行排序。 </p><p>注意：通过非选择列进行排序。通常，ORDER BY子句中使用的列将是为显示所选择的列。但是，实际上并不一定要这样，用非检索的列排序数据是完全合法的。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 列名<span class="number">1</span>, 列名<span class="number">2</span>, 列名<span class="number">3</span> <span class="keyword">FROM</span> 表名 <span class="keyword">ORDER</span> <span class="keyword">BY</span> 列名<span class="number">1</span>, 列名<span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>说明：上面的代码将检索3个列，并按其中两个列对结果进行排序，首先按<br>列1，然后再按列2排序。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 列名<span class="number">1</span>, 列名<span class="number">2</span>, 列名<span class="number">3</span> <span class="keyword">FROM</span> 表名 <span class="keyword">ORDER</span> <span class="keyword">BY</span> 列名<span class="number">1</span> <span class="keyword">DESC</span>, 列名<span class="number">2</span> ;</span><br></pre></td></tr></table></figure><p>说明：DESC关键字只应用到直接位于其前面的列名。在上例中，只对列名1指定DESC，对列名2不指定。因此，列名1以降序排序，而列名2（在每个价格内）仍然按标准的升序排序。</p><p>注意：在多个列上降序排序，如果想在多个列上进行降序排序，必须对每个列指定DESC关键字。</p><p>应用：使用ORDER BY和LIMIT的组合，能够找出一个列中最高或最低的值。 </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_price <span class="keyword">FROM</span> products <span class="keyword">ORDER</span> <span class="keyword">BY</span> prod_price <span class="keyword">DESC</span> <span class="keyword">LIMIT</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>分析：prod_price DESC保证行是按照由最昂贵到最便宜检索的，而LIMIT 1告诉MySQL仅返回一行。</p><h3 id="过滤查询数据"><a href="#过滤查询数据" class="headerlink" title="过滤查询数据"></a>过滤查询数据</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 列名<span class="number">1</span>, 列名<span class="number">2</span> <span class="keyword">FROM</span> 表名 <span class="keyword">WHERE</span> 列名 [ = | &lt; | &lt;= | &gt; | &gt;= | &lt;&gt; | != ] 值;  </span><br><span class="line"><span class="keyword">SELECT</span> 列名<span class="number">1</span>, 列名<span class="number">2</span> <span class="keyword">FROM</span> 表名 <span class="keyword">WHERE</span> 列名 <span class="keyword">BETWEEN</span> 值<span class="number">1</span> <span class="keyword">AND</span> 值<span class="number">2</span>; </span><br><span class="line"><span class="keyword">SELECT</span> 列名<span class="number">1</span>, 列名<span class="number">2</span> <span class="keyword">FROM</span> 表名 <span class="keyword">WHERE</span> 列名 <span class="keyword">IS</span> <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure><p>说明：单引号用来限定字符串。如果将值与串类型的列进行比较，则需要限定引号。用来与数值列进行比较的值不用引号。</p><p>注意：不匹配不会返回空值（不匹配的前提表示有值，而NULL值根本就没有值，所以不会在有值的范围内，因此需要对无值进行单独处理。）</p><p>参考：<a href="http://blog.csdn.net/mediocre117/article/details/53453866" target="_blank" rel="noopener">过滤数据</a></p><h3 id="复合的过滤查询数据"><a href="#复合的过滤查询数据" class="headerlink" title="复合的过滤查询数据"></a>复合的过滤查询数据</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 列名<span class="number">1</span>, 列名<span class="number">2</span> <span class="keyword">FROM</span> 表名 <span class="keyword">WHERE</span> 条件<span class="number">1</span> <span class="keyword">AND</span> 条件<span class="number">2</span>; </span><br><span class="line"><span class="keyword">SELECT</span> 列名<span class="number">1</span>, 列名<span class="number">2</span> <span class="keyword">FROM</span> 表名 <span class="keyword">WHERE</span> 条件<span class="number">1</span> <span class="keyword">OR</span> 条件<span class="number">2</span>; </span><br><span class="line"><span class="keyword">SELECT</span> 列名<span class="number">1</span>, 列名<span class="number">2</span> <span class="keyword">FROM</span> 表名 <span class="keyword">WHERE</span> 条件<span class="number">1</span> <span class="keyword">OR</span> 条件<span class="number">2</span> <span class="keyword">AND</span> 条件<span class="number">3</span>; </span><br><span class="line"><span class="keyword">SELECT</span> 列名<span class="number">1</span>, 列名<span class="number">2</span> <span class="keyword">FROM</span> 表名 <span class="keyword">WHERE</span> (条件<span class="number">1</span> <span class="keyword">OR</span> 条件<span class="number">2</span>) <span class="keyword">AND</span> 条件<span class="number">3</span>;</span><br><span class="line"><span class="keyword">SELECT</span> 列名<span class="number">1</span>, 列名<span class="number">2</span> <span class="keyword">FROM</span> 表名 <span class="keyword">WHERE</span> 列名 <span class="keyword">IN</span> (值<span class="number">1</span>,值<span class="number">2</span>) <span class="keyword">ORDER</span> <span class="keyword">BY</span> 列名;</span><br><span class="line"><span class="keyword">SELECT</span> 列名<span class="number">1</span>, 列名<span class="number">2</span> <span class="keyword">FROM</span> 表名 <span class="keyword">WHERE</span> 列名 <span class="keyword">NOT</span> <span class="keyword">IN</span> (值<span class="number">1</span>,值<span class="number">2</span>) <span class="keyword">ORDER</span> <span class="keyword">BY</span> 列名;</span><br></pre></td></tr></table></figure><p>说明：</p><ol><li>SQL（像多数语言一样）在处理OR操作符前，优先处理AND操作符。</li><li>IN操作符和OR操作符完成相同功能</li></ol><p>IN 操作符的优点：</p><ol><li>在使用长的合法选项清单时，IN操作符的语法更清楚且更直观。</li><li>在使用IN时，计算的次序更容易管理（因为使用的操作符更少）。</li><li>IN操作符一般比OR操作符清单执行更快。</li><li>IN的最大优点是可以包含其他SELECT语句，使得能够更动态地建立WHERE子句。</li></ol><p>NOT操作符：<br>对于简单的WHERE子句，使用NOT确实没有什么优势。但在更复杂的子句中，NOT是非常有用的。例如，在与IN操作符联合使用时，NOT使找出与条件列表不匹配的行非常简单。</p><h3 id="通配符过滤查询数据"><a href="#通配符过滤查询数据" class="headerlink" title="通配符过滤查询数据"></a>通配符过滤查询数据</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 列名<span class="number">1</span>, 列名<span class="number">2</span> <span class="keyword">FROM</span> 表名 <span class="keyword">WHERE</span> 列名 <span class="keyword">LIKE</span> <span class="string">'jet%'</span>;</span><br></pre></td></tr></table></figure><p>说明：在执行这条子句时，将检索任意以jet起头的词。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 列名<span class="number">1</span>, 列名<span class="number">2</span> <span class="keyword">FROM</span> 表名 <span class="keyword">WHERE</span> 列名 <span class="keyword">LIKE</span> <span class="string">'_ ton anvil'</span>;</span><br></pre></td></tr></table></figure><p>说明：在执行这条子句时，将检索任意以一个字符开头， ton anvil结尾的词。</p><p>通配符：<br>%： 代表搜索模式中给定位置的0个、1个或多个字符。<br>_ : 与%能匹配0个字符不一样，_总是匹配一个字符，不能多也不能少。</p><p>注意：</p><ol><li>MySQL的通配符很有用。但是通配符搜索的处理一般要比前面讨论的其他搜索所花时间更长。</li><li>根据MySQL的配置方式，搜索可以是区分大小写的。如果区分大小写，’jet%’与JetPack 1000将不匹配。</li></ol><p>技巧：  </p><ol><li>不要过度使用通配符。如果其他操作符能达到相同的目的，应该使用其他操作符。</li><li>在确实需要使用通配符时，除非绝对有必要，否则不要把它们用在搜索模式的开始处。把通配符置于搜索模式的开始处，搜索起来是最慢的。</li><li>仔细注意通配符的位置。如果放错地方，可能不会返回想要的数</li></ol><hr><h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><p>说明：  </p><ol><li>当出现复杂的过滤条件时，可以使用正则表达式。  </li><li>所有种类的程序设计语言、文本编辑器、操作系统等都支持正则表达式。</li><li>MySQL仅支持多数正则表达式实现的一个很小的子集。</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_name <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> prod_name REGEXP <span class="string">'.000'</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> prod_name;</span><br></pre></td></tr></table></figure><p>结果：<br>JetPack 1000<br>JetPack 2000</p><p>分析：<br>这里使用了正则表达式.000。 .是正则表达式语言中一个特殊的字符。它表示匹配任意一个字符，因此， 1000和2000都匹配<br>且返回。</p><p>LIKE与REGEXP区别：</p><ol><li>LIKE匹配整个列。如果被匹配的文本在列值中出现，LIKE将不会找到它，相应的行也不被返回（除非使用通配符）。  </li><li>REGEXP在列值内进行匹配，如果被匹配的文本在列值中出现，REGEXP将会找到它，相应的行将被返回。这是一个非常重要的差别。</li></ol><p>注意：<br>MySQL中的正则表达式匹配（自版本3.23.4后）不区分大小写（即，大写和小写都匹配）。为区分大小写，可使用BINARY关键字，如WHERE prod_name REGEXP BINARY ‘JetPack .000’。</p><ol><li><p>OR 匹配等价<br>‘1 | 2’     匹配含1或2的字符串<br>‘[123]’     匹配含1或2或3的字符串<br>‘[^123]’    非123其中的字符 </p></li><li><p>范围匹配<br>[1-3] [6-9] [a-z]</p></li><li><p>匹配特殊字符<br>‘\\.’用来匹配.  </p></li></ol><p>说明：<br>多数正则表达式实现使用单个反斜杠转义特殊字符，以便能使用这些字符本身。但MySQL要求两个反斜杠（ MySQL自己解释一个，正则表达式库解释另一个）。</p><p>匹配多个实例 </p><table><thead><tr><th style="text-align:center">符号</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">*</td><td style="text-align:center">0个或多个匹配 </td></tr><tr><td style="text-align:center">+</td><td style="text-align:center">1个或多个匹配（等于{1,}）</td></tr><tr><td style="text-align:center">?</td><td style="text-align:center">0个或1个匹配（等于{0,1}）</td></tr><tr><td style="text-align:center">{n}</td><td style="text-align:center">指定数目的匹配</td></tr><tr><td style="text-align:center">{n,}</td><td style="text-align:center">不少于指定数目的匹配</td></tr></tbody></table><p> <br><br>匹配特定位置  </p><table><thead><tr><th style="text-align:center">符号</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">^</td><td style="text-align:center">文本的开始</td></tr><tr><td style="text-align:center">+</td><td style="text-align:center">文本的结尾</td></tr><tr><td style="text-align:center">[[:&lt;:]]</td><td style="text-align:center">词的开始</td></tr><tr><td style="text-align:center">[[:&gt;:]]</td><td style="text-align:center">词的结尾  </td></tr></tbody></table><hr><h3 id="创建计算字段（别名）"><a href="#创建计算字段（别名）" class="headerlink" title="创建计算字段（别名）"></a>创建计算字段（别名）</h3><p>说明：计算字段并不实际存在于数据库表中。计算字段是运行时在SELECT语句内创建的。<br><br></p><ol><li>拼接字段（Concat()）</li></ol><p>注意：<br>多数DBMS使用+或||来实现拼接，MySQL则使用Concat()函数来实现。当把SQL语句转换成<br>MySQL语句时一定要把这个区别铭记在心。</p><p>删除多余空格<br>LTrim()  删除左边空格<br>RTrim()  删除右边空格<br>Trim()   同时删除左右空格<br><br></p><ol start="2"><li>AS 别名</li></ol><p>实例：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_id, quantity, item_price, quantity * item_price </span><br><span class="line"><span class="keyword">AS</span> expanded_price <span class="keyword">FROM</span> orderitems <span class="keyword">WHERE</span> order_num = <span class="number">200005</span>;</span><br></pre></td></tr></table></figure></p><hr><h3 id="高级查询"><a href="#高级查询" class="headerlink" title="高级查询"></a>高级查询</h3><p><br></p><ol><li>分组查询  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cust_id, <span class="keyword">COUNT</span>(*) <span class="keyword">AS</span> orders <span class="keyword">FROM</span> orders <span class="keyword">GROUP</span> <span class="keyword">BY</span> cust_id <span class="keyword">HAVING</span> <span class="keyword">COUNT</span>(*) &gt;= <span class="number">2</span>;</span><br></pre></td></tr></table></figure></li></ol><p>说明：通过GROUP BY关键字来分组，同时将分组后的数据通过HAVING关键字来过滤查询数据。</p><p>SELECT子句顺序</p><table><thead><tr><th style="text-align:center">子句</th><th style="text-align:center">说明</th><th style="text-align:center">是否必须使用</th></tr></thead><tbody><tr><td style="text-align:center">SELECT</td><td style="text-align:center">要返回的列或表达式</td><td style="text-align:center">是</td></tr><tr><td style="text-align:center">FROM</td><td style="text-align:center">从中检索的数据表</td><td style="text-align:center">仅在从表选择数据时使用</td></tr><tr><td style="text-align:center">WHERE</td><td style="text-align:center">行级过滤</td><td style="text-align:center">否</td></tr><tr><td style="text-align:center">GROUP BY</td><td style="text-align:center">分组说明</td><td style="text-align:center">仅在按组计算聚集时使用</td></tr><tr><td style="text-align:center">HAVING</td><td style="text-align:center">组级过滤</td><td style="text-align:center">否</td></tr><tr><td style="text-align:center">ORDER BY</td><td style="text-align:center">输出排序顺序</td><td style="text-align:center">否</td></tr><tr><td style="text-align:center">LIMIT</td><td style="text-align:center">要检索的行数</td><td style="text-align:center">否</td></tr></tbody></table><p><br></p><ol start="2"><li>子查询</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cust_name, cust_contact <span class="keyword">FROM</span> customers <span class="keyword">WHERE</span> cust_id <span class="keyword">IN</span> </span><br><span class="line">                (<span class="keyword">SELECT</span> cust_id <span class="keyword">FROM</span> orders <span class="keyword">WHERE</span> order_num <span class="keyword">IN</span> </span><br><span class="line">                (<span class="keyword">SELECT</span> order_num <span class="keyword">FROM</span> orderitems <span class="keyword">WHERE</span> prod_id = <span class="string">'TNT2'</span>));</span><br></pre></td></tr></table></figure><p>说明：为了执行上述SELECT语句， MySQL实际上必须执行3条SELECT语句。最里边的子查询返回订单号列表，此列表用于其外面的子查询的WHERE子句。外面的子查询返回客户ID列表，此客户ID列表用于最外层查询的WHERE子句。最外层查询确实返回所需的数据。</p><p><br></p><ol start="3"><li>联结查询<br>1) 内部联结<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> vend_name, prod_name, prod_price </span><br><span class="line"><span class="keyword">FROM</span> vendors <span class="keyword">INNER</span> <span class="keyword">JOIN</span> products </span><br><span class="line"><span class="keyword">ON</span> vendors.vend_id = products.vend_id;</span><br></pre></td></tr></table></figure></li></ol><p>说明：这里，两个表之间的关系是FROM子句的组成部分，以INNER JOIN指定。在使用这种语法时，联结条件用特定的ON子句而不是WHERE<br>子句给出。传递给ON的实际条件与传递给WHERE的相同。（无法检索出含有空的信息）。</p><p>2) 外部联结<br>定义：联结包含了那些在相关表中没有关联行的行。这种类型的联结称为外部联结。<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> customers.cust_id, orders.order_num <span class="keyword">FROM</span> customers </span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> orders <span class="keyword">ON</span> customers.cust_id = orders.cust_id;</span><br></pre></td></tr></table></figure></p><p>说明：在使用OUTER JOIN语法时，必须使用RIGHT或LEFT关键字<br>指定包括其所有行的表（RIGHT指出的是OUTER JOIN右边的表，而LEFT<br>指出的是OUTER JOIN左边的表）。</p><p>3) 自联结</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> p1.prod_id, p1.prod_name</span><br><span class="line"><span class="keyword">FROM</span> products <span class="keyword">AS</span> p1, products <span class="keyword">AS</span> p2</span><br><span class="line"><span class="keyword">WHERE</span> p1.vend_id = p2.vend_id</span><br><span class="line"><span class="keyword">AND</span> p2.prod_id = <span class="string">'DTNTR'</span>;</span><br></pre></td></tr></table></figure><p>说明： 此查询中需要的两个表实际上是相同的表，因此products表在FROM子句中出现了两次。虽然这是完全合法的，但对products的引用具有二义性，因为MySQL不知道你引用的是products表中的哪个实例。（也可以用子查询实现）</p><p>4) 自然联结<br>定义：自然联结排除多次出现，使每个列只返回一次。<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> c.*, o.order_num, o.order_date,</span><br><span class="line">oi.prod_id, oi.quantity, OI.item_price</span><br><span class="line"><span class="keyword">FROM</span> customers <span class="keyword">AS</span> c, orders <span class="keyword">AS</span> o, orderitems <span class="keyword">AS</span> oi</span><br><span class="line"><span class="keyword">WHERE</span> c.cust_id = o.cust_id</span><br><span class="line"><span class="keyword">AND</span> oi.order_num = o.order_num</span><br><span class="line"><span class="keyword">AND</span> prod_id = <span class="string">'FB'</span>;</span><br></pre></td></tr></table></figure></p><p>说明：在这个例子中，通配符只对第一个表使用。所有其他列明确列出，所以没有重复的列被检索出来。</p><p><a href="http://www.2cto.com/database/201604/497286.html" target="_blank" rel="noopener">高级联结</a>（博客帮助理解）</p><p>5) 组合查询<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> vend_id, prod_id, prod_price</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> prod_price &lt;= <span class="number">5</span></span><br><span class="line"><span class="keyword">UNION</span> </span><br><span class="line"><span class="keyword">SELECT</span> vend_id, prod_id, prod_price</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> vend_id <span class="keyword">IN</span> (<span class="number">1001</span>, <span class="number">1002</span>);</span><br></pre></td></tr></table></figure></p><p>说明：UNION指示MySQL执行两条SELECT语句，并把输出组合成单个查询结果集。对于更复杂的过滤条件，或者从多个表（而不是单个表）中检索数据的情形，使用UNION可能会使处理更简单。<br>注意：返回重复行，可使用UNION ALL而不是UNION。</p><p>6) 全文本搜索</p><ol><li>性能相比一般通配符，正则表达式效率要高。</li><li>可以将搜索出来的结果按照更好的匹配来排列它们，还可以匹配出不包含该词，但是包含其它词的记录。</li></ol><hr><h3 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> customers(</span><br><span class="line">    cust_name,</span><br><span class="line">    cust_email,</span><br><span class="line">    cust_address,</span><br><span class="line">    cust_city,</span><br><span class="line">    cust_state,</span><br><span class="line">    cust_zip,</span><br><span class="line">    cust_country)</span><br><span class="line"><span class="keyword">VALUES</span>(</span><br><span class="line">    <span class="string">'Pep E. LaPew'</span>,</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    <span class="string">'100 Main Street'</span>,</span><br><span class="line">    <span class="string">'Los Angeles'</span>,</span><br><span class="line">    <span class="string">'CA'</span>,</span><br><span class="line">    <span class="string">'90046'</span>,</span><br><span class="line">    <span class="string">'USA'</span>);</span><br></pre></td></tr></table></figure><p>说明：总是使用列的列表一般不要使用没有明确给出列的列表的INSERT语句。使用列的列表能使SQL代码继续发挥作用，即使表结构发生了变化。  </p><p>注意：INSERT操作可能很耗时（特别是有很多索引需要更新时），而且它可能降低等待处理的SELECT语句的性能。如果数据检索是最重要的（通常是这样），则可以通过在<br>INSERT和INTO之间添加关键字LOW_PRIORITY，指示MySQL降低INSERT语句的优先级。这也适合于UPDATE 和 DELETE 语句。</p><h3 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> customers </span><br><span class="line"><span class="keyword">SET</span> cust_email = <span class="string">'elmer@fudd.com'</span></span><br><span class="line"><span class="keyword">WHERE</span> cust_id = <span class="number">1005</span>;</span><br></pre></td></tr></table></figure><p>说明：UPDATE语句以WHERE子句结束，它告诉MySQL更新哪一行。没有WHERE子句，MySQL将会用这个电子邮件地址更新customers表中所有行。</p><p>注意：</p><ol><li>为了删除某个列的值，可设置它为NULL（假如表定义允许NULL值）</li><li>在更新多个列时，只需要使用单个SET命令，每个“列=值”对之间用逗号分隔（最后一列之后不用逗号）。</li></ol><h3 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> customers </span><br><span class="line"><span class="keyword">WHERE</span> cust_id = <span class="number">10006</span>;</span><br></pre></td></tr></table></figure><p>注意：</p><ol><li>ELETE不需要列名或通配符。DELETE删除整行而不是删除列。为了删除指定的列，请使用UPDATE语句。</li><li>如果想从表中删除所有行，不要使用DELETE。可使用TRUNCATETABLE语句，它完成相同的工作，但速度更快（ TRUNCATE实际是删除原来的表并重新创建一个表，而不<br>是逐行删除表中的数据）。</li></ol><hr><h3 id="表操作"><a href="#表操作" class="headerlink" title="表操作"></a>表操作</h3><h4 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> customers</span><br><span class="line">(</span><br><span class="line">    cust_id <span class="built_in">int</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">    cust_name <span class="built_in">char</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    cust_address <span class="built_in">char</span>(<span class="number">50</span>) <span class="literal">NULL</span>,</span><br><span class="line">    cust_city <span class="built_in">char</span>(<span class="number">50</span>) <span class="literal">NULL</span>,</span><br><span class="line">    cust_state <span class="built_in">char</span>(<span class="number">5</span>) <span class="literal">NULL</span>,</span><br><span class="line">    cust_zip <span class="built_in">char</span>(<span class="number">10</span>) <span class="literal">NULL</span>,</span><br><span class="line">    cust_country <span class="built_in">char</span>(<span class="number">50</span>) <span class="literal">NULL</span>,</span><br><span class="line">    cust_contact <span class="built_in">char</span>(<span class="number">50</span>) <span class="literal">NULL</span>,</span><br><span class="line">    cust_email <span class="built_in">char</span>(<span class="number">255</span>) <span class="literal">NULL</span>,</span><br><span class="line">    PRIMARY <span class="keyword">KEY</span> (cust_id)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span>;</span><br></pre></td></tr></table></figure><p>注意：在创建新表时，指定的表名必须不存在，否则将出错。如果要防止意外覆盖已有的表，SQL要求首先手工删除该表（请参阅后面的小节），然后再重建它，而不是简单地用创建表语句覆盖它。</p><h4 id="更新表"><a href="#更新表" class="headerlink" title="更新表"></a>更新表</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> vendors</span><br><span class="line"><span class="keyword">ADD</span> vend_phone <span class="built_in">CHAR</span>(<span class="number">20</span>);</span><br></pre></td></tr></table></figure><p>说明：这条语句给vendors表增加一个名为vend_phone的列，必须明确其数据类型。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> vendors</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">COLUMN</span> vend_phone;</span><br></pre></td></tr></table></figure><p>说明：删除某列。</p><p>ALTER TABLE的一种常见用途是定义外键<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> orderitems</span><br><span class="line"><span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> fk_orderitems_orders</span><br><span class="line">FOREIGN <span class="keyword">KEY</span> (order_num) <span class="keyword">REFERENCES</span> orders (order_num);</span><br></pre></td></tr></table></figure></p><p>说明：对单个表进行多个更改，可以使用单条ALTER TABLE语句，每个更改用逗号分隔。</p><h4 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> customers2;</span><br></pre></td></tr></table></figure><p>说明：这条语句删除customers2表（假设它存在）。删除表没有确认，也不能撤销，执行这条语句将永久删除该表。</p><h4 id="重命名表"><a href="#重命名表" class="headerlink" title="重命名表"></a>重命名表</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RENAME</span> <span class="keyword">TABLE</span> customers2 <span class="keyword">TO</span> customers;</span><br></pre></td></tr></table></figure><p>说明：将表customers2 重命名为customers.</p><hr><h3 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h3><p>定义：视图是虚拟的表。与包含数据的表不一样，视图只包含使用时动态检索数据的查询。</p><ol><li>视图用CREATE VIEW语句来创建。</li><li>使用SHOW CREATE VIEW viewname；来查看创建视图的语句。</li><li>用DROP删除视图，其语法为DROP VIEW viewname;。</li><li>更新视图时，可以先用DROP再用CREATE，也可以直接用CREATE OR REPLACE VIEW。如果要更新的视图不存在，则第2条更新语句会创建一个视图；如果要更新的视图存在，则第2条更新语句会替换原有视图。</li></ol><p>视图的最常见的应用之一是隐藏复杂的SQL，这通常都会涉及联结。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> productcustomers <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> cust_name, cust_contact, prod_id</span><br><span class="line"><span class="keyword">FROM</span> customers, orders, orderitems</span><br><span class="line"><span class="keyword">WHERE</span> customers.cust_id = orders.cust_id</span><br><span class="line"><span class="keyword">AND</span> orderitems.order_num = orders.order_num;</span><br></pre></td></tr></table></figure><p>说明：这条语句创建一个名为productcustomers的视图，它联结三个表，以返回已订购了任意产品的所有客户的列表。如果执行SELECT * FROM productcustomers，将列出订购了任意产品的客户。</p><h3 id="存储过程（函数）"><a href="#存储过程（函数）" class="headerlink" title="存储过程（函数）"></a>存储过程（函数）</h3><p>定义： 存储过程简单来说，就是为以后的使用而保存的一条或多条MySQL语句的集合。可将其视为批文件，虽然它们的作用不仅限于批处理。<br><br></p><ol><li>创建存储过程</li></ol><p>1） 简化版本</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> productpricing()</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">SELECT</span> <span class="keyword">Avg</span>(prod_price) <span class="keyword">AS</span> priceaverage</span><br><span class="line">    <span class="keyword">FROM</span> products;</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure><p>说明: 在MySQL处理这段代码时，它创建一个新的存储过程productpricing。没有返回数据，因为这段代码并未调用存储过程，这里只是为以后使用而创建它。</p><p>注意：如果是命令行实用程序要解释存储过程自身内的 ; 字符，它们不会成为存储过程的一部分，会出现语法错误。</p><p>可以如下操作(临时更改分隔符）：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER //</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> productpricing()</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">SELECT</span> <span class="keyword">Avg</span>(prod_price) <span class="keyword">AS</span> priceaverage</span><br><span class="line">    <span class="keyword">FROM</span> products;</span><br><span class="line"><span class="keyword">END</span> //</span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure></p><p>注意： 除\符号外，任何字符都可以用作语句分隔符。</p><p>2) 带参数版本</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> productpricing(</span><br><span class="line">    <span class="keyword">OUT</span> p1 <span class="built_in">DECIMAL</span>(<span class="number">8</span>,<span class="number">2</span>),</span><br><span class="line">    <span class="keyword">OUT</span> ph <span class="built_in">DECIMAL</span>(<span class="number">8</span>,<span class="number">2</span>),</span><br><span class="line">    <span class="keyword">OUT</span> pa <span class="built_in">DECIMAL</span>(<span class="number">8</span>,<span class="number">2</span>)</span><br><span class="line">)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">SELECT</span> <span class="keyword">Min</span>(prod_price)</span><br><span class="line">    <span class="keyword">INTO</span> p1</span><br><span class="line">    <span class="keyword">FROM</span> products;</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="keyword">Max</span>(prod_price)</span><br><span class="line">    <span class="keyword">INTO</span> ph</span><br><span class="line">    <span class="keyword">FROM</span> products;</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="keyword">Avg</span>(prod_price)</span><br><span class="line">    <span class="keyword">INTO</span> pa</span><br><span class="line">    <span class="keyword">FROM</span> products;</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure><p>说明： 此存储过程接受3个参数： pl存储产品最低价格， ph存储产品最高价格， pa存储产品平均价格。每个参数必须具有指定的类型，这里使用十进制值。关键字OUT指出相应的参数用来从存储过程传出一个值（返回给调用者）。MySQL支持IN（传递给存储过程）、 OUT（从存储过程传出，如这里所用）和INOUT（对存储过程传入和传出）类型的参数。存储过程的代码位于BEGIN和END语句内，如前所见，它们是一系列<br>SELECT语句，用来检索值，然后保存到相应的变量（通过指定INTO关键字）</p><p><br></p><ol start="2"><li>删除存储过程<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">PROCEDURE</span> productpricing;</span><br></pre></td></tr></table></figure></li></ol><p>注意：</p><ul><li>这条语句删除刚创建的存储过程。请注意没有使用后面的()，只给出存储过程名。</li><li>当过程存在想删除它时（如果过程不存在也不产生错误）可使用DROP PROCEDURE IF EXISTS。</li></ul><p><br></p><ol start="3"><li>执行存储过程<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CALL</span> productpricing(@pricelow, @pricehigh, @priceaverage);</span><br></pre></td></tr></table></figure></li></ol><p>说明： 由于此存储过程要求3个参数，因此必须正好传递3个参数，不多也不少。所以，这条CALL语句给出3个参数。它们是存储过程将保存结果的3个变量的名字。</p><p>注意： 所有MySQL变量都必须以@开始。</p><h3 id="游标"><a href="#游标" class="headerlink" title="游标"></a>游标</h3><p>来源：使用简单的SELECT语句，例如，没有办法得到第一行、下一行或前10行，也不存在每次一行地处理所有行的简单方法（相对于成批地处理它们）。有时，需要在检索出来的行中前进或后退一行或多行。这就是使用游标的原因。</p><p>定义：就自己的理解是，游标相当于一个指针，用来灵活的处理从表中查询出来的数据，通常是与存储过程结合起来一起使用的。</p><p>创建游标<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> productpricing()</span><br><span class="line"><span class="keyword">BEGIN</span> </span><br><span class="line">    <span class="keyword">DECLARE</span> ordernumbers <span class="keyword">CURSOR</span></span><br><span class="line">    <span class="keyword">FOR</span> </span><br><span class="line">    <span class="keyword">SELECT</span> order_num <span class="keyword">FROM</span> orders;</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure></p><p>打开和关闭游标<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 打开游标</span></span><br><span class="line">OPEN ordernumbers;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 关闭游标</span></span><br><span class="line">CLOSE rodernumbers;</span><br></pre></td></tr></table></figure></p><p>游标使用可参考:  <a href="http://www.cnblogs.com/mqxs/p/6018766.html" target="_blank" rel="noopener">游标的具体使用详解</a></p><h3 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h3><p>来源：想要某条语句（或某些语句）在事件发生时自动执行。<br>定义：触发器是MySQL响应以下任意语句而自动执行的一条MySQL语句（语句执行之前或者之后）（或位于BEGIN和END语句之间的一组语句）。<br>仅支持：  </p><ol><li>DELETE  </li><li>INSERT  </li><li>UPDATE  </li></ol><p>其他MySQL语句不支持触发器。</p><p>注意： </p><ol><li>在MySQL 5中，触发器名必须在每个表中唯一，但不是在每个数据库中唯一。</li><li>现在最好是在数据库范围内使用唯一的触发器名。</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> newproduct <span class="keyword">AFTER</span> <span class="keyword">INSERT</span> <span class="keyword">ON</span> products</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="keyword">ROW</span> <span class="keyword">SELECT</span> <span class="string">'Product added'</span>;</span><br></pre></td></tr></table></figure><p>说明：对每个成功的插入，控制台都会显示Product added信息。</p><p>各语句具体使用查阅相关资料。</p><h3 id="事务管理"><a href="#事务管理" class="headerlink" title="事务管理"></a>事务管理</h3><p>定义： 事务处理是一种机制，用来管理必须成批执行的MySQL操作，以保证数据库不包含不完整的操作结果。  </p><p>说明：利用事务处理，可以保证一组操作不会中途停止，它们或者作为整体执行，或者完全不执行（除非明确指示）。如果没有错误发生，整组语句提交给（写到）数据库表。如果发生错误，则进行回退（撤销）以恢复数据库到某个已知且安全的状态。</p><p>MyISAM引擎不支持事务处理  </p><p>InnoDB引擎支持事务处理</p><p>基本术语：</p><ol><li>事务（transaction）指一组SQL语句；</li><li>回退（rollback）指撤销指定SQL语句的过程；</li><li>提交（commit）指将未存储的SQL语句结果写入数据库表；</li><li>保留点（savepoint）指事务处理中设置的临时占位符（placeholder），你可以对它发布回退（与回退整个事务处理不同）。</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 事务开始</span></span><br><span class="line"><span class="keyword">START</span> <span class="keyword">TRANSACTION</span></span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 回退事务</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> ordertotals;</span><br><span class="line"><span class="keyword">START</span> <span class="keyword">TRANSACTION</span>;</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> ordertotals;</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> ordertotals;</span><br><span class="line"><span class="keyword">ROLLBACK</span>;</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> ordertotals;</span><br></pre></td></tr></table></figure><p>说明： 首先执行一条SELECT以显示该表不为空。然后开始一个事务处理，用一条DELETE语句删除ordertotals中的所有行。另一条SELECT语句验证ordertotals确实为空。这时用一条ROLLBACK语句回退START TRANSACTION之后的所有语句，最后一条SELECT语句显示该表不为空。  </p><p>注意： </p><ol><li>ROLLBACK只能在一个事务处理内使用（在执行一条START TRANSACTION命令之后）。</li><li>事务处理用来管理INSERT、 UPDATE和DELETE语句。你不能回退SELECT语句。（这样做也没有什么意义。）你不能回退CREATE或DROP操作。事务处理块中可以使用这两条语句，但如果你执行回退，它们不会被撤销。</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 提交事务</span></span><br><span class="line"><span class="keyword">START</span> <span class="keyword">TRANSACTION</span>;</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> orderitems <span class="keyword">WHERE</span> order_num = <span class="number">2010</span>;</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> orders <span class="keyword">WHERE</span> order_num = <span class="number">20010</span>;</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure><p>说明：在这个例子中，从系统中完全删除订单20010。因为涉及更新<br>两个数据库表orders和orderItems，所以使用事务处理块来<br>保证订单不被部分删除。最后的COMMIT语句仅在不出错时写出更改。如<br>果第一条DELETE起作用，但第二条失败，则DELETE不会提交（实际上，<br>它是被自动撤销的）。</p><p>注意：</p><ol><li>一般MySQL语句的使用都是隐含提交的，但是在事务处理中，提交不会隐含进行，需要使用COMMIT语句。</li><li>当COMMIT或ROLLBACK语句执行后，事务会自动关闭（将来的更改会隐含提交）。</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 保留点</span></span><br><span class="line"><span class="comment">-- 设置保留点</span></span><br><span class="line"><span class="keyword">SAVEPOINT</span> delete1;</span><br><span class="line"><span class="comment">-- 事务回退到保留点</span></span><br><span class="line"><span class="keyword">ROLLBACK</span> <span class="keyword">TO</span> delete1;</span><br></pre></td></tr></table></figure><p>说明：为了支持回退部分事务处理，必须能在事务处理块中合适的位置放置占位符。这样，如果需要回退，可以回退到某个占位符。</p><p>注意：保留点在事务处理完成（执行一条ROLLBACK或COMMIT）后自动释放。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 设置数据库不默认提交</span></span><br><span class="line"><span class="keyword">SET</span> autocommit=<span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>说明：autocommit标志决定是否自动提交更改，不管有没有COMMIT语句。设置autocommit为0（假）指示MySQL不自动提交更改（直到autocommit被设置为真为止）</p><p>注意： autocommit标志是针对每个连接而不是服务器的。</p><hr><h3 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建用户账号</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> ben <span class="keyword">IDENTIFIED</span> <span class="keyword">BY</span> <span class="string">'123456'</span>;</span><br></pre></td></tr></table></figure><p>说明：创建用户名为 ‘ben’, 密码为 ‘123456’的用户。</p><p>用户的账号信息存储在Mysql.user表中。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 重命名用户</span></span><br><span class="line"><span class="keyword">RENAME</span> <span class="keyword">USER</span> ben <span class="keyword">TO</span> bforta;</span><br><span class="line"><span class="comment">-- 删除用户账号</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">USER</span> bforta;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 显示用户的权限信息</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">GRANTS</span> <span class="keyword">FOR</span> bforta;</span><br><span class="line"><span class="comment">-- 此GRANT允许用户在crashcourse.*（crashcourse数据库的所有表）上使用SELECT。在所有表中只有只读访问权限。</span></span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span> <span class="keyword">ON</span> crashcourse.* <span class="keyword">TO</span> bforta;</span><br><span class="line"><span class="comment">-- 撤销特定访问权限</span></span><br><span class="line"><span class="keyword">REVOKE</span> <span class="keyword">SELECT</span> <span class="keyword">ON</span> crashcourse.* <span class="keyword">FROM</span> bforta;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 修改bforta账户密码</span></span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">PASSWORD</span> <span class="keyword">FOR</span> bforta = <span class="keyword">Password</span>(<span class="string">'root'</span>);</span><br><span class="line"><span class="comment">-- 修改登录账户密码</span></span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">PASSWORD</span> = <span class="keyword">Password</span>(<span class="string">'root'</span>);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      mysql必知必会读书笔记
    
    </summary>
    
      <category term="mysql" scheme="http://yoursite.com/categories/mysql/"/>
    
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>Redis基本操作</title>
    <link href="http://yoursite.com/2018/04/20/Redis%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
    <id>http://yoursite.com/2018/04/20/Redis基本操作/</id>
    <published>2018-04-20T02:24:00.000Z</published>
    <updated>2018-05-21T09:11:41.681Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Redis简介"><a href="#Redis简介" class="headerlink" title="Redis简介"></a>Redis简介</h2><p>Redis是一个速度非常快的非关系数据库（non-relational database），它可以存储键（key）与5种不同类型的值（value）之间的映射（mapping），可以将存储在内存的键值对数据持久化到硬盘，可以使用复制特性来扩展读性能，还可以使用客户端分片来扩展写性能<br><br></p><ol><li>与关系数据库对比<br>Redis属于人们常说的NoSQL数据库或者非关系数据库：Redis不使用表，它的数据库也不会预定义或者强制去要求用户对Redis存储的不同数据进行关联。</li><li>与memcached对比<br>这两者都可用于存储键值映射，彼此的性能也相差无几，但是Redis能够自动以两种不同的方式将数据写入硬盘，并且Redis除了能存储普通的字符串键之外，还可以存储其他4种数据结构，而memcached只能存储普通的字符串键。这些不同之处使得Redis可以用于解决更为广泛的问题，并且既可以用作主数据库（primary database）使用，又可以作为其他存储系统的辅助数据库（auxiliary database）使用。</li></ol><h2 id="Redis安装配置-windows版本"><a href="#Redis安装配置-windows版本" class="headerlink" title="Redis安装配置(windows版本)"></a>Redis安装配置(windows版本)</h2><p><a href="https://github.com/MSOpenTech/redis/releases" target="_blank" rel="noopener">下载地址</a> (Redis-x64-xxx.zip)<br><br></p><ol><li>打开cmd窗口<br>必须切换到存放Redis原文件的目录下（可以将目录设置到环境变量中），并运行如下命令来启动服务端<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server.exe redis.windows.conf</span><br></pre></td></tr></table></figure></li></ol><p><br></p><ol start="2"><li>打开另一个cmd窗口<br>切换到对应目录下运行如下命令（若设置了环境变量则不需要切换目录），就可以访问服务端了。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli.exe -h 127.0.0.1 -p 6379</span><br></pre></td></tr></table></figure></li></ol><h2 id="Redis命令"><a href="#Redis命令" class="headerlink" title="Redis命令"></a>Redis命令</h2><p><br></p><ol><li>连接远程redis服务<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//host:主机名 port:端口名 password:密码</span><br><span class="line">$ redis-cli -h host -p port -a password</span><br><span class="line">//默认连接本机，等同于下一条命令</span><br><span class="line">$ redis-cli</span><br><span class="line">$ redis-cli -h 127.0.0.1 -p 6379 -a &quot;mypass&quot;</span><br><span class="line">redis 127.0.0.1:6379&gt;</span><br><span class="line">redis 127.0.0.1:6379&gt; PING</span><br><span class="line">PONG</span><br></pre></td></tr></table></figure></li></ol><p>PING命令用于检测redis服务是否启动。</p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p><br></p><ol><li>Redis字符串(String)（<a href="https://redis.io/commands" target="_blank" rel="noopener">命令手册</a>）<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//语法</span><br><span class="line">redis 127.0.0.1:6379&gt; COMMAND KEY_NAME</span><br><span class="line">//实例</span><br><span class="line">redis 127.0.0.1:6379&gt; SET runoobkey redis</span><br><span class="line">OK</span><br><span class="line">redis 127.0.0.1:6379&gt; GET runoobkey</span><br><span class="line">&quot;redis&quot;</span><br></pre></td></tr></table></figure></li></ol><p><br></p><ol start="2"><li>Redis哈希(Hash)（<a href="https://redis.io/commands" target="_blank" rel="noopener">命令手册</a>）</li></ol><p>说明：Redis hash 是一个string类型的field和value的映射表，hash特别适合用于存储对象。Redis 中每个 hash 可以存储 232 - 1 键值对（40多亿）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//runoobkey为键名，后面的数据都是一对一对存储的，比如name和&quot;redis tutorial&quot;是一对键值对</span><br><span class="line">127.0.0.1:6379&gt;  HMSET runoobkey name &quot;redis tutorial&quot; description &quot;redis basic commands for caching&quot; likes 20 visitors 23000</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">//显示所有hash中的所有数据</span><br><span class="line">127.0.0.1:6379&gt;  HGETALL runoobkey</span><br><span class="line">1) &quot;name&quot;</span><br><span class="line">2) &quot;redis tutorial&quot;</span><br><span class="line">3) &quot;description&quot;</span><br><span class="line">4) &quot;redis basic commands for caching&quot;</span><br><span class="line">5) &quot;likes&quot;</span><br><span class="line">6) &quot;20&quot;</span><br><span class="line">7) &quot;visitors&quot;</span><br><span class="line">8) &quot;23000&quot;</span><br></pre></td></tr></table></figure></p><p><br></p><ol start="3"><li>Redis列表(List)（<a href="https://redis.io/commands" target="_blank" rel="noopener">命令手册</a>）<br>说明： Redis列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素导列表的头部（左边）或者尾部（右边）一个列表最多可以包含 232 - 1 个元素 (4294967295, 每个列表超过40亿个元素)。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//在runoobkey头插入值（LPUSH在头部插入，RPUSH在尾部插入）</span><br><span class="line">redis 127.0.0.1:6379&gt; LPUSH runoobkey redis</span><br><span class="line">(integer) 1</span><br><span class="line">redis 127.0.0.1:6379&gt; LPUSH runoobkey mongodb</span><br><span class="line">(integer) 2</span><br><span class="line">redis 127.0.0.1:6379&gt; LPUSH runoobkey mysql</span><br><span class="line">(integer) 3</span><br><span class="line">//返回第1个元素到第11个元素区间内的值</span><br><span class="line">redis 127.0.0.1:6379&gt; LRANGE runoobkey 0 10</span><br><span class="line"></span><br><span class="line">1) &quot;mysql&quot;</span><br><span class="line">2) &quot;mongodb&quot;</span><br><span class="line">3) &quot;redis&quot;</span><br></pre></td></tr></table></figure><p><br></p><ol start="4"><li>Redis集合(Set)（<a href="https://redis.io/commands" target="_blank" rel="noopener">命令手册</a>）<br>说明：Redis的Set是string类型的无序集合。集合成员是唯一的，这就意味着集合中不能出现重复的数据。Redis中集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)。集合中最大的成员数为 232 - 1 (4294967295, 每个集合可存储40多亿个成员)。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//向集合添加一个成员</span><br><span class="line">redis 127.0.0.1:6379&gt; SADD runoobkey redis</span><br><span class="line">(integer) 1</span><br><span class="line">redis 127.0.0.1:6379&gt; SADD runoobkey mongodb</span><br><span class="line">(integer) 1</span><br><span class="line">redis 127.0.0.1:6379&gt; SADD runoobkey mysql</span><br><span class="line">(integer) 1</span><br><span class="line">redis 127.0.0.1:6379&gt; SADD runoobkey mysql</span><br><span class="line">(integer) 0</span><br><span class="line">//返回集合中的所有成员</span><br><span class="line">redis 127.0.0.1:6379&gt; SMEMBERS runoobkey</span><br><span class="line"></span><br><span class="line">1) &quot;mysql&quot;</span><br><span class="line">2) &quot;mongodb&quot;</span><br><span class="line">3) &quot;redis&quot;</span><br></pre></td></tr></table></figure><p><br></p><ol start="5"><li>Redis有序集合(sorted set)（<a href="https://redis.io/commands" target="_blank" rel="noopener">命令手册</a>）<br>说明：Redis 有序集合和集合一样也是string类型元素的集合,且不允许重复的成员。不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。有序集合的成员是唯一的,但分数(score)却可以重复。集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)。 集合中最大的成员数为 232 - 1 (4294967295, 每个集合可存储40多亿个成员)。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; ZADD runoobkey 1 redis</span><br><span class="line">(integer) 1</span><br><span class="line">redis 127.0.0.1:6379&gt; ZADD runoobkey 2 mongodb</span><br><span class="line">(integer) 1</span><br><span class="line">redis 127.0.0.1:6379&gt; ZADD runoobkey 3 mysql</span><br><span class="line">(integer) 1</span><br><span class="line">redis 127.0.0.1:6379&gt; ZADD runoobkey 3 mysql</span><br><span class="line">(integer) 0</span><br><span class="line">redis 127.0.0.1:6379&gt; ZADD runoobkey 4 mysql</span><br><span class="line">(integer) 0</span><br><span class="line">redis 127.0.0.1:6379&gt; ZRANGE runoobkey 0 10 WITHSCORES</span><br><span class="line"></span><br><span class="line">1) &quot;redis&quot;</span><br><span class="line">2) &quot;1&quot;</span><br><span class="line">3) &quot;mongodb&quot;</span><br><span class="line">4) &quot;2&quot;</span><br><span class="line">5) &quot;mysql&quot;</span><br><span class="line">6) &quot;4&quot;</span><br></pre></td></tr></table></figure><p><br></p><ol start="6"><li>Redis HyperLogLog<br>1) Redis 在 2.8.9 版本添加了 HyperLogLog 结构。<br>2) Redis HyperLogLog 是用来做基数统计的算法，HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定 的、并且是很小的。<br>在 Redis 里面，每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基 数。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比。<br>3) 因为HyperLogLog只会根据输入元素来计算基数，而不会储存输入元素本身，所以 HyperLogLog 不能像集合那样，返回输入的各个元素。</li></ol><p>说明：<br>基数：集合中不同元素的数量。比如 {‘apple’, ‘banana’, ‘cherry’, ‘banana’, ‘apple’} 的基数就是3。<br>估算值：算法给出的基数并不是精确的，可能会比实际稍微多一些或者稍微少一些，但会控制在合理的范围之内。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//向HyperLogLog中添加元素</span><br><span class="line">redis 127.0.0.1:6379&gt; PFADD runoobkey &quot;redis&quot;</span><br><span class="line">1) (integer) 1</span><br><span class="line">redis 127.0.0.1:6379&gt; PFADD runoobkey &quot;mongodb&quot;</span><br><span class="line">1) (integer) 1</span><br><span class="line">redis 127.0.0.1:6379&gt; PFADD runoobkey &quot;mysql&quot;</span><br><span class="line">1) (integer) 1</span><br><span class="line">//统计基数的数量</span><br><span class="line">redis 127.0.0.1:6379&gt; PFCOUNT runoobkey</span><br><span class="line">(integer) 3</span><br></pre></td></tr></table></figure><h2 id="Redis发布订阅"><a href="#Redis发布订阅" class="headerlink" title="Redis发布订阅"></a>Redis发布订阅</h2><p><a href="http://www.runoob.com/redis/redis-pub-sub.html" target="_blank" rel="noopener">发布订阅—菜鸟教程</a></p><h2 id="Redis事务"><a href="#Redis事务" class="headerlink" title="Redis事务"></a>Redis事务</h2><p><a href="http://www.runoob.com/redis/redis-transactions.html" target="_blank" rel="noopener">Redis事务—菜鸟教程</a></p><h2 id="Java使用Redis"><a href="#Java使用Redis" class="headerlink" title="Java使用Redis"></a>Java使用Redis</h2><p><a href="http://www.runoob.com/redis/redis-java.html" target="_blank" rel="noopener">Java使用Redis—菜鸟教程</a></p>]]></content>
    
    <summary type="html">
    
      redis缓存基础知识
    
    </summary>
    
      <category term="redis" scheme="http://yoursite.com/categories/redis/"/>
    
    
      <category term="redis" scheme="http://yoursite.com/tags/redis/"/>
    
  </entry>
  
</feed>
