<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[mysql必知必会笔记]]></title>
    <url>%2F2018%2F04%2F25%2Fmysql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[基本知识 关系数据库设计把数据存储在多个表中，使数据更容易操纵、维护和重用。不用深究如何以及为什么进行关系数据库设计，在某种程度上说，设计良好的数据库模式都是关联的。 help show | select | update …; 查看相关命令的帮助 MySql语句都以（；）结尾。（多条SQL语句必须以分号（；）分隔。 MySQL如同多数DBMS一样，不需要在单条SQL语句后加分号。但特定的DBMS可能必须在单条SQL语句后加上分号。当然，如果愿意可以总是加上分号。事实上，即使不一定需要，但加上分号肯定没有坏处。如果你使用的是mysql命令行，必须加上分号来结束SQL语句。） 对所有SQL关键字使用大写，而对所有列和表名使用小写。（SQL语句不区分大小写，因此SELECT与select是相同的。同样，写成Select也没有关系。许多SQL开发人员喜欢对所有SQL关键字使用大写，而对所有列和表名使用小写，这样做使代码更易于阅读和调试。） 将SQL语句分成多行更容易阅读和调试。（使用空格 在处理SQL语句时，其中所有空格都被忽略。 SQL语句可以在一行上给出，也可以分成许多行。多数SQL开发人员认为将SQL语句分成多行更容易阅读和调试。） 连接MySQL数据库1mysql –u用户名 [–h主机名或者IP地址] –p密码 说明：用户名是你登录的用户，主机名或者IP地址为可选项，如果是本地连接则不需要，远程连接需要填写，端口默认是3306，否则需要填写端口号，密码是对应用户的密码。 注意： 该命令是在Windows命令行窗口下执行，而不是MySQL的命令行； 输入-p后可以直接跟上密码，也可以按回车，会提示你输入密码，二者都是相同的效果； –p密码选项不一定是要在最后； –u、-h、-p后无空格。 数据库基本操作1. 选择数据库12345678USE 数据库名; ``` 注意： 必须先使用USE打开数据库，才能读取其中的数据。#### 2. 显示数据库和表```SQLSHOW DATABASES; 说明：返回可用数据库的一个列表。包含在这个列表中的可能有MySQL内部使用的数据库。 1SHOW TABLES; 说明：返回当前选择的数据库内可用表的列表。 12SHOW COLUMNS FROM 表名; DESCRIBE 表名;（更快捷的方式） 说明：要求给出一个表名，它对每个字段返回一行，行中包含字段名、数据类型、是否允许NULL、键信息、默认值以及其他信息。 数据查询1SELECT 列名 FROM 表名; 说明：上述语句利用SELECT语句从表中检索一列。所需的列名在SELECT关键字之后给出， FROM关键字指出从其中检索数据的表名。 注意：如果没有明确排序查询结果，则返回的数据的顺序没有特殊意义。返回数据的顺序可能是数据被添加到表中的顺序，也可能不是。只要返回相同数目的行，就是正常的。 1SELECT 列名1, 列名2, 列名3 FROM 表名; 说明：这条语句使用SELECT语句从表中选择数据。在这个例子中，指定了3个列名，列名之间用逗号分隔。 1SELECT * FROM 表名; 说明：如果给定一个通配符（*），则返回表中所有列。列的顺序一般是列在表定义中出现的顺序。但有时候并不是这样的，表的模式的变化（如添加或删除列）可能会导致顺序的变化。 注意： 一般，除非你确实需要表中的每个列，否则最好别使用*通配符。虽然使用通配符可能会使你自己省事，不用明确列出所需列，但检索不需要的列通常会降低检索和应用程序的性能。 使用通配符有一个大优点。由于不明确指定列名（因为星号检索每个列），所以能检索出名字未知的列。 1SELECT DISTINCT 列名 FROM 表名; 说明：SELECT DISTINCT列名告诉MySQL只返回不同（唯一）的对应列名的行，去掉重复行，如果使用DISTINCT关键字，它必须直接放在列名的前面。 注意：不能部分使用DISTINCT，DISTINCT关键字应用于所有列而不仅是前置它的列。如果给出SELECT DISTINCT 列1,列2，除非指定的两个列都不同，否则所有行都将被检索出来。 12SELECT 列名 FROM 表名 LIMIT 5, 5; SELECT 列名 FROM 表名 LIMIT 5; 说明： LIMIT 5, 5指示MySQL返回从行5开始的5行。第一个数为开始位置，第二个数为要检索的行数。 LIMIT 5 指示MySQL返回不多于5行。 注意： 行0检索出来的第一行为行0而不是行1。因此，LIMIT 1, 1将检索出第二行而不是第一行。 在行数不够时，LIMIT中指定要检索的行数为检索的最大行数。如果没有足够的行（例如，给出LIMIT 10, 5，但只有13行），MySQL将只返回它能返回的那么多行。 1SELECT 表名.列名 FROM 数据库名.表名; 说明：指定了一个完全限定的列名和表名。 排序查询数据1SELECT 列名 FROM 表名 ORDER BY 列名; 说明：将输出的结果根据列进行排序。 注意：通过非选择列进行排序。通常，ORDER BY子句中使用的列将是为显示所选择的列。但是，实际上并不一定要这样，用非检索的列排序数据是完全合法的。 1SELECT 列名1, 列名2, 列名3 FROM 表名 ORDER BY 列名1, 列名2; 说明：上面的代码将检索3个列，并按其中两个列对结果进行排序，首先按列1，然后再按列2排序。 1SELECT 列名1, 列名2, 列名3 FROM 表名 ORDER BY 列名1 DESC, 列名2 ; 说明：DESC关键字只应用到直接位于其前面的列名。在上例中，只对列名1指定DESC，对列名2不指定。因此，列名1以降序排序，而列名2（在每个价格内）仍然按标准的升序排序。 注意：在多个列上降序排序，如果想在多个列上进行降序排序，必须对每个列指定DESC关键字。 应用：使用ORDER BY和LIMIT的组合，能够找出一个列中最高或最低的值。 1SELECT prod_price FROM products ORDER BY prod_price DESC LIMIT 1; 分析：prod_price DESC保证行是按照由最昂贵到最便宜检索的，而LIMIT 1告诉MySQL仅返回一行。 过滤查询数据123SELECT 列名1, 列名2 FROM 表名 WHERE 列名 [ = | &lt; | &lt;= | &gt; | &gt;= | &lt;&gt; | != ] 值; SELECT 列名1, 列名2 FROM 表名 WHERE 列名 BETWEEN 值1 AND 值2; SELECT 列名1, 列名2 FROM 表名 WHERE 列名 IS NULL; 说明：单引号用来限定字符串。如果将值与串类型的列进行比较，则需要限定引号。用来与数值列进行比较的值不用引号。 注意：不匹配不会返回空值（不匹配的前提表示有值，而NULL值根本就没有值，所以不会在有值的范围内，因此需要对无值进行单独处理。） 参考：过滤数据 复合的过滤查询数据123456SELECT 列名1, 列名2 FROM 表名 WHERE 条件1 AND 条件2; SELECT 列名1, 列名2 FROM 表名 WHERE 条件1 OR 条件2; SELECT 列名1, 列名2 FROM 表名 WHERE 条件1 OR 条件2 AND 条件3; SELECT 列名1, 列名2 FROM 表名 WHERE (条件1 OR 条件2) AND 条件3;SELECT 列名1, 列名2 FROM 表名 WHERE 列名 IN (值1,值2) ORDER BY 列名;SELECT 列名1, 列名2 FROM 表名 WHERE 列名 NOT IN (值1,值2) ORDER BY 列名; 说明： SQL（像多数语言一样）在处理OR操作符前，优先处理AND操作符。 IN操作符和OR操作符完成相同功能 IN 操作符的优点： 在使用长的合法选项清单时，IN操作符的语法更清楚且更直观。 在使用IN时，计算的次序更容易管理（因为使用的操作符更少）。 IN操作符一般比OR操作符清单执行更快。 IN的最大优点是可以包含其他SELECT语句，使得能够更动态地建立WHERE子句。 NOT操作符：对于简单的WHERE子句，使用NOT确实没有什么优势。但在更复杂的子句中，NOT是非常有用的。例如，在与IN操作符联合使用时，NOT使找出与条件列表不匹配的行非常简单。 通配符过滤查询数据1SELECT 列名1, 列名2 FROM 表名 WHERE 列名 LIKE 'jet%'; 说明：在执行这条子句时，将检索任意以jet起头的词。 1SELECT 列名1, 列名2 FROM 表名 WHERE 列名 LIKE '_ ton anvil'; 说明：在执行这条子句时，将检索任意以一个字符开头， ton anvil结尾的词。 通配符：%： 代表搜索模式中给定位置的0个、1个或多个字符。_ : 与%能匹配0个字符不一样，_总是匹配一个字符，不能多也不能少。 注意： MySQL的通配符很有用。但是通配符搜索的处理一般要比前面讨论的其他搜索所花时间更长。 根据MySQL的配置方式，搜索可以是区分大小写的。如果区分大小写，’jet%’与JetPack 1000将不匹配。 技巧： 不要过度使用通配符。如果其他操作符能达到相同的目的，应该使用其他操作符。 在确实需要使用通配符时，除非绝对有必要，否则不要把它们用在搜索模式的开始处。把通配符置于搜索模式的开始处，搜索起来是最慢的。 仔细注意通配符的位置。如果放错地方，可能不会返回想要的数 正则表达式说明： 当出现复杂的过滤条件时，可以使用正则表达式。 所有种类的程序设计语言、文本编辑器、操作系统等都支持正则表达式。 MySQL仅支持多数正则表达式实现的一个很小的子集。 1SELECT prod_name FROM products WHERE prod_name REGEXP '.000' ORDER BY prod_name; 结果：JetPack 1000JetPack 2000 分析：这里使用了正则表达式.000。 .是正则表达式语言中一个特殊的字符。它表示匹配任意一个字符，因此， 1000和2000都匹配且返回。 LIKE与REGEXP区别： LIKE匹配整个列。如果被匹配的文本在列值中出现，LIKE将不会找到它，相应的行也不被返回（除非使用通配符）。 REGEXP在列值内进行匹配，如果被匹配的文本在列值中出现，REGEXP将会找到它，相应的行将被返回。这是一个非常重要的差别。 注意：MySQL中的正则表达式匹配（自版本3.23.4后）不区分大小写（即，大写和小写都匹配）。为区分大小写，可使用BINARY关键字，如WHERE prod_name REGEXP BINARY ‘JetPack .000’。 OR 匹配等价‘1 | 2’ 匹配含1或2的字符串‘[123]’ 匹配含1或2或3的字符串‘[^123]’ 非123其中的字符 范围匹配[1-3] [6-9] [a-z] 匹配特殊字符‘\\.’用来匹配. 说明：多数正则表达式实现使用单个反斜杠转义特殊字符，以便能使用这些字符本身。但MySQL要求两个反斜杠（ MySQL自己解释一个，正则表达式库解释另一个）。 匹配多个实例 符号 说明 * 0个或多个匹配 + 1个或多个匹配（等于{1,}） ? 0个或1个匹配（等于{0,1}） {n} 指定数目的匹配 {n,} 不少于指定数目的匹配 匹配特定位置 符号 说明 ^ 文本的开始 + 文本的结尾 [[:&lt;:]] 词的开始 [[:&gt;:]] 词的结尾 创建计算字段（别名）说明：计算字段并不实际存在于数据库表中。计算字段是运行时在SELECT语句内创建的。 拼接字段（Concat()） 注意：多数DBMS使用+或||来实现拼接，MySQL则使用Concat()函数来实现。当把SQL语句转换成MySQL语句时一定要把这个区别铭记在心。 删除多余空格LTrim() 删除左边空格RTrim() 删除右边空格Trim() 同时删除左右空格 AS 别名 实例：12SELECT prod_id, quantity, item_price, quantity * item_price AS expanded_price FROM orderitems WHERE order_num = 200005; 高级查询 分组查询 1SELECT cust_id, COUNT(*) AS orders FROM orders GROUP BY cust_id HAVING COUNT(*) &gt;= 2; 说明：通过GROUP BY关键字来分组，同时将分组后的数据通过HAVING关键字来过滤查询数据。 SELECT子句顺序 子句 说明 是否必须使用 SELECT 要返回的列或表达式 是 FROM 从中检索的数据表 仅在从表选择数据时使用 WHERE 行级过滤 否 GROUP BY 分组说明 仅在按组计算聚集时使用 HAVING 组级过滤 否 ORDER BY 输出排序顺序 否 LIMIT 要检索的行数 否 子查询 123SELECT cust_name, cust_contact FROM customers WHERE cust_id IN (SELECT cust_id FROM orders WHERE order_num IN (SELECT order_num FROM orderitems WHERE prod_id = 'TNT2')); 说明：为了执行上述SELECT语句， MySQL实际上必须执行3条SELECT语句。最里边的子查询返回订单号列表，此列表用于其外面的子查询的WHERE子句。外面的子查询返回客户ID列表，此客户ID列表用于最外层查询的WHERE子句。最外层查询确实返回所需的数据。 联结查询1) 内部联结123SELECT vend_name, prod_name, prod_price FROM vendors INNER JOIN products ON vendors.vend_id = products.vend_id; 说明：这里，两个表之间的关系是FROM子句的组成部分，以INNER JOIN指定。在使用这种语法时，联结条件用特定的ON子句而不是WHERE子句给出。传递给ON的实际条件与传递给WHERE的相同。（无法检索出含有空的信息）。 2) 外部联结定义：联结包含了那些在相关表中没有关联行的行。这种类型的联结称为外部联结。12SELECT customers.cust_id, orders.order_num FROM customers LEFT OUTER JOIN orders ON customers.cust_id = orders.cust_id; 说明：在使用OUTER JOIN语法时，必须使用RIGHT或LEFT关键字指定包括其所有行的表（RIGHT指出的是OUTER JOIN右边的表，而LEFT指出的是OUTER JOIN左边的表）。 3) 自联结 1234SELECT p1.prod_id, p1.prod_nameFROM products AS p1, products AS p2WHERE p1.vend_id = p2.vend_idAND p2.prod_id = 'DTNTR'; 说明： 此查询中需要的两个表实际上是相同的表，因此products表在FROM子句中出现了两次。虽然这是完全合法的，但对products的引用具有二义性，因为MySQL不知道你引用的是products表中的哪个实例。（也可以用子查询实现） 4) 自然联结定义：自然联结排除多次出现，使每个列只返回一次。123456SELECT c.*, o.order_num, o.order_date,oi.prod_id, oi.quantity, OI.item_priceFROM customers AS c, orders AS o, orderitems AS oiWHERE c.cust_id = o.cust_idAND oi.order_num = o.order_numAND prod_id = 'FB'; 说明：在这个例子中，通配符只对第一个表使用。所有其他列明确列出，所以没有重复的列被检索出来。 高级联结（博客帮助理解） 5) 组合查询1234567SELECT vend_id, prod_id, prod_priceFROM productsWHERE prod_price &lt;= 5UNION SELECT vend_id, prod_id, prod_priceFROM productsWHERE vend_id IN (1001, 1002); 说明：UNION指示MySQL执行两条SELECT语句，并把输出组合成单个查询结果集。对于更复杂的过滤条件，或者从多个表（而不是单个表）中检索数据的情形，使用UNION可能会使处理更简单。注意：返回重复行，可使用UNION ALL而不是UNION。 6) 全文本搜索 性能相比一般通配符，正则表达式效率要高。 可以将搜索出来的结果按照更好的匹配来排列它们，还可以匹配出不包含该词，但是包含其它词的记录。 插入数据1234567891011121314151617INSERT INTO customers( cust_name, cust_email, cust_address, cust_city, cust_state, cust_zip, cust_country)VALUES( 'Pep E. LaPew', NULL, NULL, '100 Main Street', 'Los Angeles', 'CA', '90046', 'USA'); 说明：总是使用列的列表一般不要使用没有明确给出列的列表的INSERT语句。使用列的列表能使SQL代码继续发挥作用，即使表结构发生了变化。 注意：INSERT操作可能很耗时（特别是有很多索引需要更新时），而且它可能降低等待处理的SELECT语句的性能。如果数据检索是最重要的（通常是这样），则可以通过在INSERT和INTO之间添加关键字LOW_PRIORITY，指示MySQL降低INSERT语句的优先级。这也适合于UPDATE 和 DELETE 语句。 更新数据123UPDATE customers SET cust_email = 'elmer@fudd.com'WHERE cust_id = 1005; 说明：UPDATE语句以WHERE子句结束，它告诉MySQL更新哪一行。没有WHERE子句，MySQL将会用这个电子邮件地址更新customers表中所有行。 注意： 为了删除某个列的值，可设置它为NULL（假如表定义允许NULL值） 在更新多个列时，只需要使用单个SET命令，每个“列=值”对之间用逗号分隔（最后一列之后不用逗号）。 删除数据12DELETE FROM customers WHERE cust_id = 10006; 注意： ELETE不需要列名或通配符。DELETE删除整行而不是删除列。为了删除指定的列，请使用UPDATE语句。 如果想从表中删除所有行，不要使用DELETE。可使用TRUNCATETABLE语句，它完成相同的工作，但速度更快（ TRUNCATE实际是删除原来的表并重新创建一个表，而不是逐行删除表中的数据）。 表操作创建表12345678910111213CREATE TABLE customers( cust_id int NOT NULL AUTO_INCREMENT, cust_name char(50) NOT NULL, cust_address char(50) NULL, cust_city char(50) NULL, cust_state char(5) NULL, cust_zip char(10) NULL, cust_country char(50) NULL, cust_contact char(50) NULL, cust_email char(255) NULL, PRIMARY KEY (cust_id)) ENGINE=InnoDB; 注意：在创建新表时，指定的表名必须不存在，否则将出错。如果要防止意外覆盖已有的表，SQL要求首先手工删除该表（请参阅后面的小节），然后再重建它，而不是简单地用创建表语句覆盖它。 更新表12ALTER TABLE vendorsADD vend_phone CHAR(20); 说明：这条语句给vendors表增加一个名为vend_phone的列，必须明确其数据类型。 12ALTER TABLE vendorsDROP COLUMN vend_phone; 说明：删除某列。 ALTER TABLE的一种常见用途是定义外键123ALTER TABLE orderitemsADD CONSTRAINT fk_orderitems_ordersFOREIGN KEY (order_num) REFERENCES orders (order_num); 说明：对单个表进行多个更改，可以使用单条ALTER TABLE语句，每个更改用逗号分隔。 删除表1DROP TABLE customers2; 说明：这条语句删除customers2表（假设它存在）。删除表没有确认，也不能撤销，执行这条语句将永久删除该表。 重命名表1RENAME TABLE customers2 TO customers; 说明：将表customers2 重命名为customers. 视图定义：视图是虚拟的表。与包含数据的表不一样，视图只包含使用时动态检索数据的查询。 视图用CREATE VIEW语句来创建。 使用SHOW CREATE VIEW viewname；来查看创建视图的语句。 用DROP删除视图，其语法为DROP VIEW viewname;。 更新视图时，可以先用DROP再用CREATE，也可以直接用CREATE OR REPLACE VIEW。如果要更新的视图不存在，则第2条更新语句会创建一个视图；如果要更新的视图存在，则第2条更新语句会替换原有视图。 视图的最常见的应用之一是隐藏复杂的SQL，这通常都会涉及联结。 12345CREATE VIEW productcustomers ASSELECT cust_name, cust_contact, prod_idFROM customers, orders, orderitemsWHERE customers.cust_id = orders.cust_idAND orderitems.order_num = orders.order_num; 说明：这条语句创建一个名为productcustomers的视图，它联结三个表，以返回已订购了任意产品的所有客户的列表。如果执行SELECT * FROM productcustomers，将列出订购了任意产品的客户。 存储过程（函数）定义： 存储过程简单来说，就是为以后的使用而保存的一条或多条MySQL语句的集合。可将其视为批文件，虽然它们的作用不仅限于批处理。 创建存储过程 1） 简化版本 12345CREATE PROCEDURE productpricing()BEGIN SELECT Avg(prod_price) AS priceaverage FROM products;END; 说明: 在MySQL处理这段代码时，它创建一个新的存储过程productpricing。没有返回数据，因为这段代码并未调用存储过程，这里只是为以后使用而创建它。 注意：如果是命令行实用程序要解释存储过程自身内的 ; 字符，它们不会成为存储过程的一部分，会出现语法错误。 可以如下操作(临时更改分隔符）：123456789DELIMITER //CREATE PROCEDURE productpricing()BEGIN SELECT Avg(prod_price) AS priceaverage FROM products;END //DELIMITER ; 注意： 除\符号外，任何字符都可以用作语句分隔符。 2) 带参数版本 12345678910111213141516CREATE PROCEDURE productpricing( OUT p1 DECIMAL(8,2), OUT ph DECIMAL(8,2), OUT pa DECIMAL(8,2))BEGIN SELECT Min(prod_price) INTO p1 FROM products; SELECT Max(prod_price) INTO ph FROM products; SELECT Avg(prod_price) INTO pa FROM products;END; 说明： 此存储过程接受3个参数： pl存储产品最低价格， ph存储产品最高价格， pa存储产品平均价格。每个参数必须具有指定的类型，这里使用十进制值。关键字OUT指出相应的参数用来从存储过程传出一个值（返回给调用者）。MySQL支持IN（传递给存储过程）、 OUT（从存储过程传出，如这里所用）和INOUT（对存储过程传入和传出）类型的参数。存储过程的代码位于BEGIN和END语句内，如前所见，它们是一系列SELECT语句，用来检索值，然后保存到相应的变量（通过指定INTO关键字） 删除存储过程1DROP PROCEDURE productpricing; 注意： 这条语句删除刚创建的存储过程。请注意没有使用后面的()，只给出存储过程名。 当过程存在想删除它时（如果过程不存在也不产生错误）可使用DROP PROCEDURE IF EXISTS。 执行存储过程1CALL productpricing(@pricelow, @pricehigh, @priceaverage); 说明： 由于此存储过程要求3个参数，因此必须正好传递3个参数，不多也不少。所以，这条CALL语句给出3个参数。它们是存储过程将保存结果的3个变量的名字。 注意： 所有MySQL变量都必须以@开始。 游标来源：使用简单的SELECT语句，例如，没有办法得到第一行、下一行或前10行，也不存在每次一行地处理所有行的简单方法（相对于成批地处理它们）。有时，需要在检索出来的行中前进或后退一行或多行。这就是使用游标的原因。 定义：就自己的理解是，游标相当于一个指针，用来灵活的处理从表中查询出来的数据，通常是与存储过程结合起来一起使用的。 创建游标123456CREATE PROCEDURE productpricing()BEGIN DECLARE ordernumbers CURSOR FOR SELECT order_num FROM orders;END; 打开和关闭游标12345-- 打开游标OPEN ordernumbers;-- 关闭游标CLOSE rodernumbers; 游标使用可参考: 游标的具体使用详解 触发器来源：想要某条语句（或某些语句）在事件发生时自动执行。定义：触发器是MySQL响应以下任意语句而自动执行的一条MySQL语句（语句执行之前或者之后）（或位于BEGIN和END语句之间的一组语句）。仅支持： DELETE INSERT UPDATE 其他MySQL语句不支持触发器。 注意： 在MySQL 5中，触发器名必须在每个表中唯一，但不是在每个数据库中唯一。 现在最好是在数据库范围内使用唯一的触发器名。 12CREATE TRIGGER newproduct AFTER INSERT ON productsFOR EACH ROW SELECT 'Product added'; 说明：对每个成功的插入，控制台都会显示Product added信息。 各语句具体使用查阅相关资料。 事务管理定义： 事务处理是一种机制，用来管理必须成批执行的MySQL操作，以保证数据库不包含不完整的操作结果。 说明：利用事务处理，可以保证一组操作不会中途停止，它们或者作为整体执行，或者完全不执行（除非明确指示）。如果没有错误发生，整组语句提交给（写到）数据库表。如果发生错误，则进行回退（撤销）以恢复数据库到某个已知且安全的状态。 MyISAM引擎不支持事务处理 InnoDB引擎支持事务处理 基本术语： 事务（transaction）指一组SQL语句； 回退（rollback）指撤销指定SQL语句的过程； 提交（commit）指将未存储的SQL语句结果写入数据库表； 保留点（savepoint）指事务处理中设置的临时占位符（placeholder），你可以对它发布回退（与回退整个事务处理不同）。 12-- 事务开始START TRANSACTION 1234567-- 回退事务SELECT * FROM ordertotals;START TRANSACTION;DELETE FROM ordertotals;SELECT * FROM ordertotals;ROLLBACK;SELECT * FROM ordertotals; 说明： 首先执行一条SELECT以显示该表不为空。然后开始一个事务处理，用一条DELETE语句删除ordertotals中的所有行。另一条SELECT语句验证ordertotals确实为空。这时用一条ROLLBACK语句回退START TRANSACTION之后的所有语句，最后一条SELECT语句显示该表不为空。 注意： ROLLBACK只能在一个事务处理内使用（在执行一条START TRANSACTION命令之后）。 事务处理用来管理INSERT、 UPDATE和DELETE语句。你不能回退SELECT语句。（这样做也没有什么意义。）你不能回退CREATE或DROP操作。事务处理块中可以使用这两条语句，但如果你执行回退，它们不会被撤销。 12345-- 提交事务START TRANSACTION;DELETE FROM orderitems WHERE order_num = 2010;DELETE FROM orders WHERE order_num = 20010;COMMIT; 说明：在这个例子中，从系统中完全删除订单20010。因为涉及更新两个数据库表orders和orderItems，所以使用事务处理块来保证订单不被部分删除。最后的COMMIT语句仅在不出错时写出更改。如果第一条DELETE起作用，但第二条失败，则DELETE不会提交（实际上，它是被自动撤销的）。 注意： 一般MySQL语句的使用都是隐含提交的，但是在事务处理中，提交不会隐含进行，需要使用COMMIT语句。 当COMMIT或ROLLBACK语句执行后，事务会自动关闭（将来的更改会隐含提交）。 12345-- 保留点-- 设置保留点SAVEPOINT delete1;-- 事务回退到保留点ROLLBACK TO delete1; 说明：为了支持回退部分事务处理，必须能在事务处理块中合适的位置放置占位符。这样，如果需要回退，可以回退到某个占位符。 注意：保留点在事务处理完成（执行一条ROLLBACK或COMMIT）后自动释放。 12-- 设置数据库不默认提交SET autocommit=0; 说明：autocommit标志决定是否自动提交更改，不管有没有COMMIT语句。设置autocommit为0（假）指示MySQL不自动提交更改（直到autocommit被设置为真为止） 注意： autocommit标志是针对每个连接而不是服务器的。 用户管理12-- 创建用户账号CREATE USER ben IDENTIFIED BY '123456'; 说明：创建用户名为 ‘ben’, 密码为 ‘123456’的用户。 用户的账号信息存储在Mysql.user表中。 1234-- 重命名用户RENAME USER ben TO bforta;-- 删除用户账号DROP USER bforta; 123456-- 显示用户的权限信息SHOW GRANTS FOR bforta;-- 此GRANT允许用户在crashcourse.*（crashcourse数据库的所有表）上使用SELECT。在所有表中只有只读访问权限。GRANT SELECT ON crashcourse.* TO bforta;-- 撤销特定访问权限REVOKE SELECT ON crashcourse.* FROM bforta; 1234-- 修改bforta账户密码SET PASSWORD FOR bforta = Password('root');-- 修改登录账户密码SET PASSWORD = Password('root');]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis基本操作]]></title>
    <url>%2F2018%2F04%2F25%2FRedis%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[Redis简介Redis是一个速度非常快的非关系数据库（non-relational database），它可以存储键（key）与5种不同类型的值（value）之间的映射（mapping），可以将存储在内存的键值对数据持久化到硬盘，可以使用复制特性来扩展读性能，还可以使用客户端分片来扩展写性能 与关系数据库对比Redis属于人们常说的NoSQL数据库或者非关系数据库：Redis不使用表，它的数据库也不会预定义或者强制去要求用户对Redis存储的不同数据进行关联。 与memcached对比这两者都可用于存储键值映射，彼此的性能也相差无几，但是Redis能够自动以两种不同的方式将数据写入硬盘，并且Redis除了能存储普通的字符串键之外，还可以存储其他4种数据结构，而memcached只能存储普通的字符串键。这些不同之处使得Redis可以用于解决更为广泛的问题，并且既可以用作主数据库（primary database）使用，又可以作为其他存储系统的辅助数据库（auxiliary database）使用。 Redis安装配置(windows版本)下载地址 (Redis-x64-xxx.zip) 打开cmd窗口必须切换到存放Redis原文件的目录下（可以将目录设置到环境变量中），并运行如下命令来启动服务端1redis-server.exe redis.windows.conf 打开另一个cmd窗口切换到对应目录下运行如下命令（若设置了环境变量则不需要切换目录），就可以访问服务端了。1redis-cli.exe -h 127.0.0.1 -p 6379 Redis命令 连接远程redis服务12345678//host:主机名 port:端口名 password:密码$ redis-cli -h host -p port -a password//默认连接本机，等同于下一条命令$ redis-cli$ redis-cli -h 127.0.0.1 -p 6379 -a &quot;mypass&quot;redis 127.0.0.1:6379&gt;redis 127.0.0.1:6379&gt; PINGPONG PING命令用于检测redis服务是否启动。 数据类型 Redis字符串(String)（命令手册）1234567//语法redis 127.0.0.1:6379&gt; COMMAND KEY_NAME//实例redis 127.0.0.1:6379&gt; SET runoobkey redisOKredis 127.0.0.1:6379&gt; GET runoobkey&quot;redis&quot; Redis哈希(Hash)（命令手册） 说明：Redis hash 是一个string类型的field和value的映射表，hash特别适合用于存储对象。Redis 中每个 hash 可以存储 232 - 1 键值对（40多亿）。1234567891011121314//runoobkey为键名，后面的数据都是一对一对存储的，比如name和&quot;redis tutorial&quot;是一对键值对127.0.0.1:6379&gt; HMSET runoobkey name &quot;redis tutorial&quot; description &quot;redis basic commands for caching&quot; likes 20 visitors 23000OK//显示所有hash中的所有数据127.0.0.1:6379&gt; HGETALL runoobkey1) &quot;name&quot;2) &quot;redis tutorial&quot;3) &quot;description&quot;4) &quot;redis basic commands for caching&quot;5) &quot;likes&quot;6) &quot;20&quot;7) &quot;visitors&quot;8) &quot;23000&quot; Redis列表(List)（命令手册）说明： Redis列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素导列表的头部（左边）或者尾部（右边）一个列表最多可以包含 232 - 1 个元素 (4294967295, 每个列表超过40亿个元素)。 12345678910111213//在runoobkey头插入值（LPUSH在头部插入，RPUSH在尾部插入）redis 127.0.0.1:6379&gt; LPUSH runoobkey redis(integer) 1redis 127.0.0.1:6379&gt; LPUSH runoobkey mongodb(integer) 2redis 127.0.0.1:6379&gt; LPUSH runoobkey mysql(integer) 3//返回第1个元素到第11个元素区间内的值redis 127.0.0.1:6379&gt; LRANGE runoobkey 0 101) &quot;mysql&quot;2) &quot;mongodb&quot;3) &quot;redis&quot; Redis集合(Set)（命令手册）说明：Redis的Set是string类型的无序集合。集合成员是唯一的，这就意味着集合中不能出现重复的数据。Redis中集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)。集合中最大的成员数为 232 - 1 (4294967295, 每个集合可存储40多亿个成员)。 123456789101112131415//向集合添加一个成员redis 127.0.0.1:6379&gt; SADD runoobkey redis(integer) 1redis 127.0.0.1:6379&gt; SADD runoobkey mongodb(integer) 1redis 127.0.0.1:6379&gt; SADD runoobkey mysql(integer) 1redis 127.0.0.1:6379&gt; SADD runoobkey mysql(integer) 0//返回集合中的所有成员redis 127.0.0.1:6379&gt; SMEMBERS runoobkey1) &quot;mysql&quot;2) &quot;mongodb&quot;3) &quot;redis&quot; Redis有序集合(sorted set)（命令手册）说明：Redis 有序集合和集合一样也是string类型元素的集合,且不允许重复的成员。不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。有序集合的成员是唯一的,但分数(score)却可以重复。集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)。 集合中最大的成员数为 232 - 1 (4294967295, 每个集合可存储40多亿个成员)。 123456789101112131415161718redis 127.0.0.1:6379&gt; ZADD runoobkey 1 redis(integer) 1redis 127.0.0.1:6379&gt; ZADD runoobkey 2 mongodb(integer) 1redis 127.0.0.1:6379&gt; ZADD runoobkey 3 mysql(integer) 1redis 127.0.0.1:6379&gt; ZADD runoobkey 3 mysql(integer) 0redis 127.0.0.1:6379&gt; ZADD runoobkey 4 mysql(integer) 0redis 127.0.0.1:6379&gt; ZRANGE runoobkey 0 10 WITHSCORES1) &quot;redis&quot;2) &quot;1&quot;3) &quot;mongodb&quot;4) &quot;2&quot;5) &quot;mysql&quot;6) &quot;4&quot; Redis HyperLogLog1) Redis 在 2.8.9 版本添加了 HyperLogLog 结构。2) Redis HyperLogLog 是用来做基数统计的算法，HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定 的、并且是很小的。在 Redis 里面，每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基 数。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比。3) 因为HyperLogLog只会根据输入元素来计算基数，而不会储存输入元素本身，所以 HyperLogLog 不能像集合那样，返回输入的各个元素。 说明：基数：集合中不同元素的数量。比如 {‘apple’, ‘banana’, ‘cherry’, ‘banana’, ‘apple’} 的基数就是3。估算值：算法给出的基数并不是精确的，可能会比实际稍微多一些或者稍微少一些，但会控制在合理的范围之内。 12345678910//向HyperLogLog中添加元素redis 127.0.0.1:6379&gt; PFADD runoobkey &quot;redis&quot;1) (integer) 1redis 127.0.0.1:6379&gt; PFADD runoobkey &quot;mongodb&quot;1) (integer) 1redis 127.0.0.1:6379&gt; PFADD runoobkey &quot;mysql&quot;1) (integer) 1//统计基数的数量redis 127.0.0.1:6379&gt; PFCOUNT runoobkey(integer) 3 Redis发布订阅发布订阅—菜鸟教程 Redis事务Redis事务—菜鸟教程 Java使用RedisJava使用Redis—菜鸟教程]]></content>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Memcached基本操作]]></title>
    <url>%2F2018%2F04%2F25%2FMemcached%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[1. Memcached简介Memcached是一个自由开源的，高性能，分布式内存对象缓存系统。 Memcached是一种基于内存的key-value存储，用来存储小块的任意数据（字符串、对象）。这些数据可以是数据库调用、API调用或者是页面渲染的结果。 本质上，它是一个简洁的key-value存储系统。 一般的使用目的是，通过缓存数据库查询结果，减少数据库访问次数，以提高动态Web应用的速度、提高可扩展性。 2. Memcached安装配置Memcached安装配置—菜鸟教程1234567891011//注意：路径对应修改为自己的安装路径//安装和卸载memcached服务c:\memcached\memcached.exe -d installc:\memcached\memcached.exe -d uninstall//启动和关闭memcached服务c:\memcached\memcached.exe -d startc:\memcached\memcached.exe -d stop//-m 512 意思是设置 memcached 最大的缓存配置为512M。c:\memcached\memcached.exe -d runservice -m 512//该命令可以用来查看命令帮助和参数配置c:\memcached\memcached.exe -h 3. Memcached 连接1234//执行任何命令时需要先启动memcached服务(路径对应修改为自己的安装路径)c:\memcached\memcached.exe -d start//telnet HOST PORT --------- HOST：主机名 PORT：端口telnet 127.0.0.1 11211 4. Memcached 存储命令1. set命令123//语法set key flags exptime bytes [noreply] value 参数说明：key：键值 key-value 结构中的 key，用于查找缓存值。flags：可以包括键值对的整型参数，客户机使用它存储关于键值对的额外信息。exptime：在缓存中保存键值对的时间长度（以秒为单位，0 表示永远）bytes：在缓存中存储的字节数noreply（可选）： 该参数告知服务器不需要返回数据value：存储的值（始终位于第二行）（可直接理解为key-value结构中的value） 例子：123456789set runoob 0 900 9memcachedSTOREDget runoobVALUE runoob 0 9memcachedEND 说明：12345key → runoobflag → 0exptime → 900 (以秒为单位)bytes → 9 (数据存储的字节数)value → memcached 输出：12//数据设置成功STORED 输出信息说明：12STORED：保存成功后输出。ERROR：在保持失败后输出。 2. add命令123//语法add key flags exptime bytes [noreply]value 参数说明：key：键值 key-value 结构中的 key，用于查找缓存值。flags：可以包括键值对的整型参数，客户机使用它存储关于键值对的额外信息。exptime：在缓存中保存键值对的时间长度（以秒为单位，0 表示永远）bytes：在缓存中存储的字节数noreply（可选）： 该参数告知服务器不需要返回数据value：存储的值（始终位于第二行）（可直接理解为key-value结构中的value） 例子：1234567add new_key 0 900 10data_valueSTOREDget new_keyVALUE new_key 0 10data_valueEND 说明：12345key → new_keyflag → 0exptime → 900 (以秒为单位)bytes → 10 (数据存储的字节数)value → data_value 输出：12//数据设置成功STORED 输出信息说明：12STORED：保存成功后输出。NOT_STORED ：在保持失败后输出。 3. replace命令123//语法replace key flags exptime bytes [noreply]value 参数说明：key：键值 key-value 结构中的 key，用于查找缓存值。flags：可以包括键值对的整型参数，客户机使用它存储关于键值对的额外信息。exptime：在缓存中保存键值对的时间长度（以秒为单位，0 表示永远）bytes：在缓存中存储的字节数noreply（可选）： 该参数告知服务器不需要返回数据value：存储的值（始终位于第二行）（可直接理解为key-value结构中的value） 例子：12345678910111213add mykey 0 900 10data_valueSTOREDget mykeyVALUE mykey 0 10data_valueENDreplace mykey 0 900 16some_other_valueget mykeyVALUE mykey 0 16some_other_valueEND 说明：12345key → mykeyflag → 0exptime → 900 (以秒为单位)bytes → 10 (数据存储的字节数)value → data_value 输出：12//数据设置成功STORED 输出信息说明：12STORED：保存成功后输出。NOT_STORED ：在保持失败后输出。 4. append命令(prepend在键值的前面追加数据)123//语法append key flags exptime bytes [noreply]value 参数说明：key：键值 key-value 结构中的 key，用于查找缓存值。flags：可以包括键值对的整型参数，客户机使用它存储关于键值对的额外信息。exptime：在缓存中保存键值对的时间长度（以秒为单位，0 表示永远）bytes：在缓存中存储的字节数noreply（可选）： 该参数告知服务器不需要返回数据value：存储的值（始终位于第二行）（可直接理解为key-value结构中的value） 例子：1234567891011121314set runoob 0 900 9memcachedSTOREDget runoobVALUE runoob 0 9memcachedENDappend runoob 0 900 5redisSTOREDget runoobVALUE runoob 0 14memcachedredisEND 说明： 首先我们在 Memcached 中存储一个键 runoob，其值为 memcached。然后，我们使用 get 命令检索该值。然后，我们使用 append 命令在键为 runoob 的值后面追加 “redis”。最后，我们再使用 get 命令检索该值。 输出：12//数据设置成功STORED 输出信息说明：123STORED：保存成功后输出。NOT_STORED：该键在 Memcached 上不存在。CLIENT_ERROR：执行错误。 5. CAS命令说明：Memcached CAS（Check-And-Set 或 Compare-And-Swap） 命令用于执行一个”检查并设置”的操作它仅在当前客户端最后一次取值后，该key 对应的值没有被其他客户端修改的情况下， 才能够将值写入。检查是通过cas_token参数进行的，这个参数是Memcach指定给已经存在的元素的一个唯一的64位值。 123//语法cas key flags exptime bytes unique_cas_token [noreply]value 参数说明：key：键值 key-value 结构中的 key，用于查找缓存值。flags：可以包括键值对的整型参数，客户机使用它存储关于键值对的额外信息。exptime：在缓存中保存键值对的时间长度（以秒为单位，0 表示永远）bytes：在缓存中存储的字节数unique_cas_token通过 gets 命令获取的一个唯一的64位值。noreply（可选）： 该参数告知服务器不需要返回数据value：存储的值（始终位于第二行）（可直接理解为key-value结构中的value） 例子：要在 Memcached 上使用 CAS 命令，你需要从 Memcached 服务商通过 gets 命令获取令牌（token）。gets 命令的功能类似于基本的 get 命令。两个命令之间的差异在于，gets 返回的信息稍微多一些：64 位的整型值非常像名称/值对的 “版本” 标识符。123456789101112131415161718192021222324cas tp 0 900 9ERROR &lt;− 缺少 tokencas tp 0 900 9 2memcachedNOT_FOUND &lt;− 键 tp 不存在set tp 0 900 9memcachedSTOREDgets tpVALUE tp 0 9 1memcachedENDcas tp 0 900 5 1redisSTOREDget tpVALUE tp 0 5redisEND 说明： 如果没有设置唯一令牌，则 CAS 命令执行错误。如果键 key 不存在，执行失败。添加键值对。通过 gets 命令获取唯一令牌。使用 cas 命令更新数据。使用 get 命令查看数据是否更新。 输出：12//数据设置成功STORED 输出信息说明：1234STORED：保存成功后输出。ERROR：保存出错或语法错误。EXISTS：在最后一次取值后另外一个用户也在更新该数据。NOT_FOUND：Memcached 服务上不存在该键值。 5. Memcached 查找命令1. get命令说明：Memcached get 命令获取存储在 key(键) 中的 value(数据值) ，如果 key 不存在，则返回空。1234//语法get key//多个 key 使用空格隔开get key1 key2 key3 参数说明：key：键值 key-value 结构中的 key，用于查找缓存值。 例子：1234567set runoob 0 900 9memcachedSTOREDget runoobVALUE runoob 0 9memcachedEND 说明：使用 runoob 作为 key，过期时间设置为 900 秒。 2. gets命令Memcached gets 命令获取带有 CAS 令牌存 的 value(数据值) ，如果 key 不存在，则返回空。1234//语法get key//多个 key 使用空格隔开get key1 key2 key3 参数说明：key：键值 key-value 结构中的 key，用于查找缓存值。 例子：1234567set runoob 0 900 9memcachedSTOREDgets runoobVALUE runoob 0 9 1memcachedEND 说明：在使用gets命令的输出结果中，在最后一列的数字1代表了key为runoob的CAS令牌。 3. delete命令Memcached delete 命令用于删除已存在的 key(键)。12//语法delete key [noreply] 参数说明：key：键值 key-value 结构中的 key，用于查找缓存值。noreply（可选）： 该参数告知服务器不需要返回数据。 例子：12345678910111213set runoob 0 900 9memcachedSTOREDget runoobVALUE runoob 0 9memcachedENDdelete runoobDELETEDget runoobENDdelete runoobNOT_FOUND 说明：使用runoob作为key，过期时间设置为900秒。之后我们使用delete命令删除该key。 输出信息说明：123DELETED：删除成功。ERROR：语法错误或删除失败。NOT_FOUND：key不存在。 3. incr / decr 命令Memcached incr 与 decr 命令用于对已存在的 key(键) 的数字值进行自增或自减操作。incr与decr命令操作的数据必须是十进制的32位无符号整数。如果key不存在返回NOT_FOUND，如果键的值不为数字，则返回 CLIENT_ERROR，其他错误返回 ERROR。12//语法incr key increment_value 参数说明：key：键值 key-value 结构中的 key，用于查找缓存值。increment_value： 增加的数值。 例子：12345678910111213set visitors 0 900 210STOREDget visitorsVALUE visitors 0 210ENDincr visitors 515get visitorsVALUE visitors 0 215END 说明：使用 visitors 作为 key，初始值为 10，之后进行加 5 操作。 输出信息说明：123NOT_FOUND：key 不存在。CLIENT_ERROR：自增值不是对象。ERROR其他错误，如语法错误等。 decr命令与此类似 6. Memcached 统计命令1. Memcached stats 命令说明：Memcached stats 命令用于返回统计信息例如 PID(进程号)、版本号、连接数等。12//语法stats 2. Memcached stats items命令说明：Memcached stats items 命令用于显示各个slab中 item的数目和存储时长(最后一次访问距离现在的秒数)。12//语法stats items 3. Memcached stats slabs命令说明：Memcached stats slabs 命令用于显示各个slab的信息，包括chunk的大小、数目、使用情况等。12//语法stats slabs Memcached stats sizes命令说明：Memcached stats sizes 命令用于显示所有item的大小和个数。该信息返回两列，第一列是item的大小，第二列是item的个数。12//语法stats sizes 例子：123stats sizesSTAT 96 1END 4. Memcached flush_all 命令说明：Memcached flush_all 命令用于用于清理缓存中的所有 key=&gt;value(键=&gt;值) 对。该命令提供了一个可选参数 time，用于在制定的时间后执行清理缓存操作。12//语法flush_all [time] [noreply] 例子：1234567891011set runoob 0 900 9memcachedSTOREDget runoobVALUE runoob 0 9memcachedENDflush_allOKget runoobEND 7. Java连接Memcached服务Java连接Memcached服务—菜鸟教程]]></content>
      <tags>
        <tag>memcached</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HeadFirst设计模式笔记]]></title>
    <url>%2F2018%2F04%2F25%2FHeadFirst%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[设计模式（原则） 将设计模式装进大脑里，然后在你的设计和已有的应用中，寻找何处可以使用它们。以往是代码复用，现在是经验复用。 设计原则1：封装变化。找出应用中可能需要变化之处，把它们独立出来，不需要和那些不需要变化的代码混合在一起。（将会变化的部分取出并“封装”起来，好让其他部分不会受到影响。 设计原则2：针对接口编程，而不是针对实现编程。（“针对接口编程”的真正意思是“针对超类型（supertype）编程”，超类型可以是抽象类“或”接口。 设计原则3：多用组合，少用继承。 设计原则4：为了交互对象之间的松耦合设计而努力。（松耦合设计能让我们建立有弹性的OO系统，能够应对变化，因为对象之间的互相依赖降到了最低水平。） 设计原则5：类应该对扩展开放，对修改关闭。（我们的目标是允许类容易扩展，在不修改现有代码的情况下，就可以搭配新的行为。这样的设计具有弹性可以应付改变，可以接受新的功能来应对改变的需求） 设计原则6：要依赖抽象，不要依赖具体类。（不让高层组件依赖低层组件，而且，不管高层或低层组件，“两者”都应该依赖于抽象）。 设计原则7：最少知识原则：只和你的密友交谈。（在设计中，不要让太多的类耦合在一起，免得修改系统中一部分，会影响到其他部分。）关键：不要调用从另一个调用中返回的对象的方法，也就是不要向另一个对象的子部分发请求。 设计原则8：好莱坞原则。（别调用（打电话给）我们，我们会调用（打电话给）你）。 注意： 有一些面向对象的原则，适用于所有的模式。当无法找到合适的模式来解决问题时，采用这些原则可以达到目的。 在设计模式中，“实现一个接口”并“不一定”表示“写一个类，并利用implement关键词来实现某个java接口”。“实现一个接口”泛指“实现某个超类型（可以是类或接口）的某个方法”。 策略(Strategy)模式 定义： 定义了算法簇，分别将其封装起来，让它们之间可以相互替换，该模式让算法的变化独立于使用算法的客户。（当需要给朋友留下深刻的印象，或者想影响关键主管的决策时，可以使用“这个”定义。） 抽象方法的作用：在该类中不用实现它，或者说在该类中不确定该如何实现它，它是用来被重载的方法。（比如有一个鸭子类，它的外观都不相同，display()方法可以定义为抽象的） 当涉及“维护”时，为了“复用”（reuse)目的而使用继承，结果并不好。（比如当在父类鸭子中加入fly()方法时，那些不会飞的鸭子（橡皮鸭）也会同时继承）。 当使用Flyable接口来实现时(只有会飞的鸭子才能继承Flyable接口），可以解决上面问题，但是又会导致代码无法复用的问题。 实例代码—-&gt;headfirst/strategy 菜鸟教程策略模式 观察者(Observer)模式注意：当试图使用观察者模式时，可以比拟出版者和订阅者的关系。 定义：定义了对象之间的一对多的依赖关系，这样一来，当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新。 观察者模式有两种实现方式： 自己实现Subject接口和Observer类。 java.util包内有最基本的Obserer(Subject)接口与Observable(Observer)类，（同时提供了推(push)和拉(pull)两种方式来传送数据）。push方式被认为更正确。 注意： 不要依赖观察者被通知的次序。（java自带的观察者模式，Observable是一个类，它会自己实现notifyObservers()方法，该方法会自定义其观察者的顺序） 应用：在JavaBeans和Swing中也使用了观察者模式。实例代码—-&gt;headfirst/observer菜鸟教程观察者模式 装饰者(Decorator)模式 定义：动态地将责任附加到对象上。若要扩展功能，装饰者提供了比继承更有弹性的替代方案。 注意： 通常装饰者模式采用抽象类，但是在java中可以使用接口。应用： 在java I/O中使用了装饰者设计模式。 实例代码—-&gt;headfirst/decorator菜鸟教程装饰者模式 工厂(Factory)模式应用： Collection中的iterator方法 JDBC数据库开发 简单工厂注意：简单工厂不是一个设计模式，它更像是一种编程习惯。 静态工厂： 利用静态方法定义一个简单工厂。 优点：不需要使用创建对象的方法来实例化对象。缺点：不能通过继承来改变创建方法的行为。（因为静态方法只和类相关，不能通过继承来重写该方法）。实例代码—-&gt;headfirst/factory/pizzas菜鸟教程工厂模式 工厂方法 定义：定义一个创建对象的接口，但是由子类决定要实例化的类是哪一个。工厂方法让类把实例化推迟到子类。（所谓的“决定”，并不是指模式允许子类本身在运行时做出决定，而是指在编写创建者类时，不需要知道实际创建的产品是哪一个。）实例代码—-&gt;headfirst/factory/pizzafm菜鸟教程工厂模式 抽象工厂 定义：提供一个接口，用于创建相关或依赖对象的家族，而不需要明确的指定具体类。 实例代码—-&gt;headfirst/factory/pizzaaf菜鸟教程抽象工厂模式 要点： 所有的工厂都是用来封装对象的创建。 简单工厂，虽然不是真正的设计模式，但依然是一个简单的方法，将客户程序从具体类中解耦。 工厂方法使用继承：把对象的创建委托给子类，子类实现工厂方法来创建对象。 抽象工厂使用对象组合：对象的创建被实现在工厂接口所暴露出来的方法中。 所有工厂模式都通过减少应用程序和具体类之间的依赖促进松耦合。 工厂方法允许类将实例化延迟到子类中进行。 抽象工厂创建相关的对象家族，而不需要依赖它们的具体类。 依赖倒置原则，指导我们避免依赖具体类型，而要尽量依赖抽象。 工厂是很有威力的技巧，帮助我们针对抽象编程，而不要针对具体类编程。单件模式 定义：确保一个类只有一个实例，并提供一个全局访问点。（注意处理多线程的情况） 饿汉式: 类一加载就创建对象懒汉式: 用的时候才去创建对象 应用：Runtime类中提供了饿汉式单例模式，jdk都是用饿汉式，我们开发时就要使用饿汉式（单面试的时候面试官叫你写一个单例模式那你要写懒汉式，因为他要考你的是线多程安全问题）实例代码—-&gt;headfirst/singleton菜鸟教程单例模式 适配器模式 定义：将一个类的接口，转换成客户期望的另一各接口。适配器让原本接口不兼容的类可以合作无间。 使用场景：当需要使用一个现有的类而其接口并不符合你的需要时，就使用适配器。 注意：适配器模式有两种形式，对象适配器和类适配器。而类适配器需要用到多重继承。 应用：将Enumeration(旧世界的枚举类)适配到Iterator（新世界的迭代器）。实例代码—-&gt;headfirst/adapter菜鸟教程适配器模式 外观模式 定义：提供了一个统一的接口，用来访问子系统中的一群接口。外观定义了一个高层接口，让子系统更容易使用。 使用场景：当需要简化并统一一个很大的接口或者一群复杂的接口时，使用外观。 实例代码—-&gt;headfirst/facade菜鸟教程外观模式 对比： 适配器将一个对象包装起来以改变其接口； 装饰者将一个对象包装起来以增加新的行为和责任； 外观将一群对象包装起来以简化其接口。 模板方法模式 定义：在一个方法中定义一个算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤。 注意： 为防止恶意操作，一般模板方法都加上 final 关键词。 策略模式和模板方法模式都封装算法，一个用组合，一个用继承。 工厂方法是模板方法的一种特殊版本。 钩子：钩子是一种被声明在抽象类中的方法，但只有空的或者默认的实现。 使用场景： Arrays.sort()排序算法（利用Comparable接口） Swing窗口程序 Applet 实例代码—-&gt;headfirst/templatemethod菜鸟教程模板方法模式]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java多线程基础]]></title>
    <url>%2F2018%2F04%2F25%2FJava%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[线程和进程的区别联系进程：操作系统运行中的程序（进程和程序的区别是程序只是一个静态的指令集合，而进程则是系统中一个活动的指令集合，加入了时间）。 线程：进程能够执行多项任务，而每一项任务就相当于一个线程。 进程之间不能共享资源，但是线程之间可以共享资源。 并发性和并行性区别并行: 有多条指令在多个处理器上同时执行。 并发: 同一时刻只有一条指令执行，但是多个进程指令会被快速轮换执行，使得看起来好像有多个进程在同时执行。 创建线程的方式1） 继承Thread类来创建线程类，然后要重写run()方法。 2）实现Runnable接口来创建线程类，然后实现run()方法，将创建的实现Runnable接口的对象作为Thread的target。 3）实现Callable接口，功能是Runnable的增强版本（java5之后提供）。接口中定义的方法有返回值，可以抛出异常。 ###实现Runnable或Callable接口 优点： 1）线程类只是实现了Runnable接口或Callable接口，它依然还可以继承其他类。 2）多个线程可以同时共享一个target对象，十分适合多个相同线程来处理同一份资源。 缺点： 编码可能较为复杂，如果要访问当前线程的话，则必须要使用Thread.currentThread()方法。 ###继承Thread类优点： 程序编写起来简单，如果需要访问当前线程的话，不用使用Thread.currentThread()方法，直接使用this即可。 缺点： 线程类以及继承了Thread类，不能再继承其他父类了。 线程的生命周期线程5种状态： 1）new(创建)：线程通过new方法创建。 2）Runnable(就绪)：当线程调用start()方法，线程进入就绪状态，等待系统调度。 3）Running(运行): 当系统调度时，线程进入运行状态。 4）Blocked(阻塞): 一个正在运行的线程因某些原因不能继续运行时，它就进入阻塞状态。 5）Dead(死亡)：线程正常结束或异常退出。 线程阻塞的几种情形： 1）处于运行状态的线程若遇到sleep()方法，则线程进入睡眠状态，不会让出资源锁，sleep()方法结束，线程转为就绪状态，等待系统重新调度。2）处于运行状态的线程可能在等待io，也可能进入挂起状态。io完成，转为就绪状态。3）处于运行状态的线程调用yield()方法，线程转为就绪状态。（yield只让给权限比自己高的）。4）处于运行状态的线程遇到wait()方法（object的方法），线程处于等待状态，需要notify()/notifyALL()来唤醒线程，唤醒后的线程处于锁定状态，获取了“同步锁”，之后，线程才转为就绪状态。5）处于运行的线程synchronized，加上后变成同步操作。处于锁定状态，获取了“同步锁”，之后，线程才转为就绪状态。 ##5. 线程控制 1）join()方法（Thread类提供的静态方法） java 线程方法join的简单总结说明：让一个线程等待另一个线程执行完成。当前线程必须等待调用join()方法的线程执行完成后，才能继续向下执行。 2）sleep()方法（Thread类提供的静态方法）说明：暂停当前线程，并进入阻塞状态，这时，如果有其它线程，则其它线程会执行。 3）yield()方法（Thread类提供的静态方法）说明：暂停当前线程，将当前线程转入就绪状态，不是阻塞状态，这时只有大于等于当前线程优先级状态的线程才能获得从就绪状态转入运行状态的机会。 线程同步同步代码块 12345//格式synchronized(obj) &#123; ...... //此处代码为同步代码块代码&#125; 说明：上面格式中的obj就是同步监视器。当线程开始执行同步代码块之前，必须先得到同步监视器的锁定。这样可以保证同一时刻只有一个线程能执行当前代码，从而保证线程安全。 同步方法 1234//格式public synchronized void draw() &#123; ......&#125; 说明：对synchronized修饰的实例方法（非static方法）来说，不需要显示的指定同步监视器，同步方法的同步监视器是this，也就是调用该方法的对象。 释放同步监视器的时机： 1.）当前线程的同步方法、同步代码块执行结束，当前线程就会释放同步监视器。2）当前线程的同步方法、同步代码块出现了未处理的Error和Exception，导致代码块异常结束了。3）当前线程执行同步方法、同步代码块时，程序执行了同步监视器对象的wait()方法，则当前线程暂停，并释放同步监视器。 java中的synchronized（同步代码块和同步方法的区别） 同步锁Lock 通过显示定义同步锁对象来实现同步，此时同步锁是由Lock对象来充当。（java5之后实现） 常用： ReentrantLock（可重入锁）123456789101112131415161718//格式class X &#123; //定义锁对象 private final ReentrantLock lock = new ReentrantLock(); //... //定义需要保证线程安全的方法 public void m() &#123; //加锁 lock.lock(); try &#123; //需要保证线程安全的代码 //...method body &#125; finally &#123; lock.unlock(); &#125; &#125;&#125; 优点：使用同步锁Lock比同步方法和同步代码块更加灵活！ 死锁 两个线程相互等待对方释放同步监视器时就会发生死锁。 死锁很容易发生，特别是在系统中出现了多个同步监视器的情况下。 线程间通讯###传统线程通讯（对应同步代码块和同步方法情况） 调用Object类的wait()、notify()、notifyAll()方法来实现线程间通讯，这三个方法是jvm中的native方法。 wait(): 调用某个对象的wait()方法能让当前线程阻塞，并且当前线程必须拥有此对象的monitor（即锁） notify(): 调用某个对象的notify()方法能够唤醒一个正在等待这个对象的monitor的线程，如果有多个线程都在等待这个对象的monitor，则只能唤醒其中一个线程；。 notifyAll(): 调用notifyAll()方法能够唤醒所有正在等待这个对象的monitor的线程； 注意： 一个线程被唤醒不代表立即获取了对象的monitor，只有等调用完notify()或者notifyAll()并退出synchronized块，释放对象锁后，其余线程才可获得锁执行。 Condition（对应Lock的情况）（JDK1.5之后出现）Condition类中提供了await()、signal()、signalAll()方法来对应wait()、notify()、notifyAll()方法，使用方法基本相同。 123456789101112//格式class X &#123; //定义锁对象 private final Lock lock = new ReentrantLock(); private final Condition cond = lock.newCondition(); .... cond.await(); cond.signal(); cond.signalAll();&#125; 相比使用Object的wait()、notify()，使用Condition的await()、signal()这种方式实现线程间协作更加安全和高效。 ###BlockingQueue（java5提供） 它是Queue的子接口，作用不是作为容器，而是作为一个线程同步的工具。 特征： （经典的生产者消费者模型） 当生产者线程尝试向BlockingQueue中放入元素时，如果队列已经满了，那么线程就会被阻塞； 当消费者线程尝试向BlockingQueue中取出元素时，如果队列已空，那么线程也会被阻塞； 对应put()方法和take()方法。 线程池线程池原理 1）线程池能够提高系统性能 说明： 系统启动线程成本高，因为涉及到和操作系统的交互。这种情况下，使用线程池能够提高系统性能。特别是需要创建大量生存期比较短的线程时候，才更需要使用线程池。 2）线程池的最大线程数参数可以控制系统中并发线程数目不会超过设置的线程数 说明： 当系统中包含大量并发线程时，会导致系统性能剧烈下降，甚至导致JVM崩溃。 过程： 线程池在系统启动时就会创建大量空闲的线程，程序将一个Runnable对象或Callable对象传给线程池，则线程池就会启动一个线程来执行它们的run()或call()方法，当run()或call()方法执行结束之后，线程不会死亡，它会再次返回到线程池中从而成为空闲状态，等待下一个run()或call()方法。 Executors工厂类来产生线程池。 1234567891011121314151617public class ThreadPoolTest &#123; pulic static void main(String[] args) throws Exception &#123; //创建一个具有固定线程数(6)的线程池 ExecutorService pool = Executors.newFixedThreadPool(6); //使用Lambda表达式创建Runnable对象 Runnable target = () -&gt; &#123; for (int i = 0; i &lt; 100; i++) &#123; System.out.println(Thread.currentThread().getName() + "的i值为：" + i); &#125; &#125;; //向线程池中提交两个线程 pool.submit(target); pool.submit(target); //关闭线程池 pool.shutdown(); &#125; &#125; ThreadLocal类 线程局部变量（ThreadLocal）为每一个使用该变量的线程都提供一个变量值的副本，使每一个线程都可以独立地改变自己的副本，而不会和其他线程的副本冲突。 ThreadLocal类方法 : T get() : 取得当前线程副本数据值 void remove() ：删除当前线程副本数据值 void set(T value) ：设置当前线程副本数据的值 ThreadLocal类是从另一个角度来解决多线程的并发访问，ThreadLocal将需要并发访问的资源复制多份，每个线程拥有一份资源，每个线程都拥有自己的资源副本，从而也就没有必要对该变量进行同步了。 实用场景： 1）如果多个线程之间需要共享资源，来达到线程之间的通信功能，就使用同步机制。 2）如果只需要隔离多个线程之间的共享冲突，可以使用ThreadLocal。 Volatile关键字深入分析volatile的实现原理]]></content>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法]]></title>
    <url>%2F2018%2F04%2F25%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[控制台运行编译java程序带中文乱码问题解决办法： javac -encoding utf-8 Test.java 稳定性：排序算法需要保留数组中重复元素的相对位置。（具体详见算法第四版P217） 冒泡排序思想： 两两比较相邻记录的关键字，如果反序则交换，直到没有反序的记录为止。 时间复杂度： O(N2) 空间复杂度： O(1) 稳定性： 稳定 123456789101112131415public class Sort &#123; public static void sort(int[] nums) &#123; int N = nums.length; int temp = 0; for (int i = 0; i &lt; N-1; i++) &#123; for (int j = 0; j &lt; N-i-1; j++) &#123; if (nums[j] &gt; nums[j + 1]) &#123; temp = nums[j]; nums[j] = nums[j+1]; nums[j+1] = temp; &#125; &#125; &#125; &#125;&#125; 选择排序思想： 每一趟在n-i+1(i=1,2,…,n-1)个记录中选取关键字最小的记录作为有序序列的第i个记录。 时间复杂度： O(N2) 空间复杂度： O(1) 稳定性： 不稳定（说明：举个例子，序列5 8 5 2 9， 我们知道第一遍选择第1个元素5会和2交换，那么原序列中2个5的相对前后顺序就被破坏了，所以选择排序不是一个稳定的排序算法） 123456789101112131415161718public class Sort &#123; public static void sort(int[] nums) &#123; int N = nums.length; for (int i = 0; i &lt; N; i++ ) &#123; int min = i; for (int j = i+1; j &lt; N; j++) &#123; if (nums[j] &lt; nums[min]) &#123; min = j; &#125; &#125; if (min != i) &#123; temp = nums[i]; nums[i] = nums[min]; nums[min] = temp; &#125; &#125; &#125;&#125; 插入排序思想： 将一个记录插入到已经排序好的有序表中，从而得到一个新的、记录数增1的有序表 时间复杂度： O(N2) 空间复杂度： O(1) 稳定性： 稳定 123456789101112131415161718192021222324252627282930313233public class Sort &#123; public static void sort(int[] nums) &#123; int N = nums.length; int temp = 0; for (int i = 1; i &lt; N; i++ ) &#123; for (int j = i; j &gt; 0 &amp;&amp; nums[j] &lt; nums[j-1]; j--) &#123; temp = nums[j]; nums[j] = nums[j+1]; nums[j+1] = temp; &#125; &#125; &#125;&#125;``` **改进版本**```javapublic class Sort &#123; public static void sort(int[] nums) &#123; int N = nums.length; int i = 0; int j = 0; for (i = 1; i &lt; N; i++) &#123; if (nums[i] &lt; nums[i-1]) &#123; int temp = nums[i]; for (j = i-1; (j &gt;= 0) &amp;&amp; (nums[j] &gt; temp); j--) &#123; nums[j+1] = nums[j]; &#125; nums[j+1] = temp; &#125; &#125; &#125;&#125; 希尔排序（插入排序升级）思想： 将数据分为若干组记录，然后分别对每一组做插入排序。 时间复杂度： O(NlgN) 空间复杂度： O(1) 稳定性： 不稳定 1234567891011121314151617181920212223242526public class Sort &#123; public static void sort(int[] nums) &#123; int N = nums.length; int temp = 0; int h = 1; int i = 0; int j = 0; //固定步长：1,4,13,40... while (h &lt; N/3) &#123; h = 3*h + 1; &#125; while (h &gt;= 1) &#123; //下面操作和插入排序算法基本相同 for (i = h; i &lt; N; i++) &#123; if (nums[i] &lt; nums[i - h]) &#123; int temp = nums[i]; for (j = i-h; (j &gt;= 0) &amp;&amp; (nums[j] &gt; temp); j = j-h) &#123; nums[j+h] = nums[j]; &#125; nums[j+h] = temp; &#125; &#125; h = h / 3; &#125; &#125;&#125; 快速排序（冒泡排序增强）思想： 选取一个轴值(比较的基准)，将待排序记录分为独立的两个部分，左侧记录都是小于或等于轴值，右侧记录都是大于或等于轴值，然后分别对左侧部分和右侧部分重复前面的过程，也就是左侧部分又选择一个轴值，又分为两个独立的部分，这就使用了递归了。到最后，整个序列就变得有序了。 时间复杂度： O(NlgN) 空间复杂度： O(lgN)~O(N) 稳定性： 不稳定 123456789101112131415161718192021222324252627282930313233343536373839public class Sort &#123; public static void sort(int[] nums) &#123; //消除对输入的依赖 //StdRandom.shuffle(a); sort(nums, 0, nums.length - 1); &#125; public static void sort (int[] nums, int lo, int hi) &#123; if (hi &lt;= lo) return; //切分 int j = partition(nums, lo, hi); sort(nums, lo, j-1); sort(nums, j+1, hi); &#125; public static int partition(int[] nums, int lo, int hi) &#123; //定义左右扫描的指针 int i = lo, j = hi + 1; //定义切分的元素d int point = nums[lo]; int temp = 0; while (true) &#123; while (nums[++i] &lt; point) if (i == hi) break; while (point &lt; nums[--j]) if (j == lo) break; if (i &gt;= j) break; //交换两个元素 temp = nums[i]; nums[i] = nums[j]; nums[j] = temp; &#125; //将切分元素放到数组中合适位置 temp = nums[lo]; nums[lo] = nums[j]; nums[j] = temp; return j; &#125;&#125; 堆排序（选择排序增强）思想： 利用优先队列的删除最大元素的特点，依次将将删除的最大元素保存起来，就有序了。当然，这里的优先队列是用堆实现的。 第一步：需要保证堆有序，也就是每一个父节点要比它的任意子节点要大； 第二步：使用堆的下沉操作来实现排序； 时间复杂度： O(NlgN) 空间复杂度： O(1) 稳定性： 不稳定 1234567891011121314151617181920212223242526272829303132333435363738public class Sort &#123; public static void heapSort(int[] a) &#123; int N = a.length; //第一步：通过下沉操作来实现堆有序，这里只需要操作数组中前面的一半元素即可 for (int k = N / 2; k &gt;= 1; k--) &#123; sink(a, k, N); &#125; //第二步：将堆有序的数组使用下沉操作来得到有序数组 while (N &gt; 1) &#123; exch(a, 1, N--); sink(a, 1, N); &#125; &#125; //堆下沉操作 public static void sink(int[] a, int k, int N) &#123; while (2*k &lt;= N) &#123; int j = 2*k; //取两个子节点中较大的一个 if (j &lt; N &amp;&amp; less(a, j, j+1)) j++; //比较如果父节点比子节点中较大的一个小，则交换 if (!less(a, k, j)) break; exch(a, k, j); //继续往下面遍历 k = j; &#125; &#125; //之所以取i-1，是因为堆中下标是从1开始的，需要还原到数组中从0开始的。 public static boolean less(int[] a, int i, int j) &#123; return a[i-1] &lt; a[j-1]; &#125; public static void exch(int[] a, int i, int j) &#123; int temp = a[i-1]; a[i-1] = a[j-1]; a[j-1] = temp; &#125; &#125; 归并排序思想： 要将一个数组排序，可以先（递归地）将它们分成两半分别排序，然后将它们的结果归并起来。 时间复杂度： O(NlgN) 空间复杂度： O(N) 稳定性： 稳定 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public class Sort &#123; //1.将两个有序数组合并为一个有序数组 public static void merge(int[] a, int lo, int mid, int hi) &#123; //将a[lo..mid] 和 a[mid+1..hi]归并 //i代表左半边索引，j代表右半边索引 int i = lo, j = mid + 1; //定义一个辅助数组 int[] aux; //将a[lo..hi]复制到aux[lo..hi] for (int k = lo; k &lt;= hi; k++) &#123; aux[k] = a[k]; &#125; for (int k = lo; k &lt;= hi; k++) &#123; //左半边元素用尽，取右半边的元素 if (i &gt; mid) &#123; a[k] = aux[j++]; //右半边元素用尽，取左半边元素 &#125; else if (j &gt; hi) &#123; a[k] = aux[i++]; //右半边的当前元素小于左半边的当前元素，则取右半边的元素 &#125; else if (aux[j] &lt; aux[i]) &#123; a[k] = aux[j++]; //左半边的当前元素小于等于右半边的当前元素，则取左半边的元素 &#125; else &#123; a[k] = aux[i++]; &#125; &#125; &#125; //自顶向下 pubic static void sort (int[] a, int lo, int hi) &#123; if (hi &lt;= lo) &#123; return; &#125; int mid = lo + (hi - lo) / 2; //将左半边排序 sort(a, lo, mid); //将右半部分排序 sort(a, mid+1, hi); //归并结果 merger(a, lo, mid, hi); &#125; //自底向上 public static void sort (int[] a) &#123; int N = a.length; int[] aux = new int[N]; //定义子数组的大小 for (int sz = 1; sz &lt; N; sz = sz + sz) &#123; //子数组的索引 for (int lo = 0; lo &lt; N-sz; lo += sz+sz) &#123; //lo+sz+sz-1可能越界，因此需要一个min函数来取边界 merge(a, lo, lo+sz-1, Math.min(lo+sz+sz-1, N-1)); &#125; &#125; &#125;&#125; 总结时间复杂度：O(N)计数排序、基数排序 O(N2)冒泡排序、选择排序、插入排序 O(NlogN)希尔排序、堆排序、快速排序、归并排序 空间复杂度：O(1)插入排序、选择排序、冒泡排序、堆排序、希尔排序 O(logN) ~ O(N)快速排序 O(N)归并排序 O(M) M为桶的数量计数排序、基数排序 稳定性： 稳定的排序算法：冒泡排序、插入排序、归并排序、计数排序、基数排序、桶排序 不稳定的排序算法：选择排序、快速排序、希尔排序、堆排序]]></content>
  </entry>
  <entry>
    <title><![CDATA[Java虚拟机]]></title>
    <url>%2F2018%2F04%2F25%2FJava%E8%99%9A%E6%8B%9F%E6%9C%BA%2F</url>
    <content type="text"><![CDATA[先来一个JVM物理结构图，后面基本是围绕这个图来说明各个部分。 JVM五大区 ###程序计数器 说明：当前线程所执行的字节码的行号指示器。 1）线程私有； 2）线程执行Java方法时，记录其正在执行的虚拟机字节码指令地址，线程执行Native方法时，计数器记录为空（Undefined）； 3）唯一在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域； ###虚拟机栈 说明：存放方法执行时所需的数据，其中每个方法为一个栈帧，存储了局部变量表（编译期间可以知道的各种基本数据类型和对象引用（不是对象本身））、操作数栈、动态链接等信息，方法的调用就对应了栈帧在虚拟机栈中的入栈和出栈的过程。 1）线程私有； 2）线程请求的栈深度如果大于虚拟机所允许的栈深度，将会抛出StackOverflowError异常； 3）如果虚拟机栈在动态扩展内存后依然不能申请到足够的内存，会抛出OutOfMemoryError异常； ###本地方法栈 说明：作用基本同本地方法栈，只是虚拟机栈是为虚拟机执行Java方法（也就是字节码）服务的，而本地方法栈却是为虚拟机使用到的Native（使用的编程语言不固定）方法服务的。 1）线程私有； 2）线程请求的栈深度如果大于虚拟机所允许的栈深度，将会抛出StackOverflowError异常； 3）如果虚拟机栈在动态扩展内存后依然不能申请到足够的内存，会抛出OutOfMemoryError异常； ###Java堆 说明：存放对象的实例。 1） 所有线程共享； 2）Java堆是Java虚拟机所管理的内存中最大的一块； 3）垃圾收集器管理的主要区域，也称为GC堆； 4）如果在堆中内存不够无法完成实例的分配，并且堆无法在扩展时，就会抛出OutOfMemoryError异常； ###方法区 （包括其中的运行时常量池） 说明：用于存储运行时常量池、已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。 1）所有线程共享； 2）当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。 运行时常量池： 说明： Class文件中的常量池（不是运行时常量池），用来存放编译期生成的各种字面量和符号引用，而这部分内容将会在类加载之后进入方法区的运行时常量池中存放。 注意： 运行时常量池不一定就一定要从字节码常量池中拿取常量，可能在程序运行期间将新的常量放入池中，比如String.intern()方法，这个方法的作用就是：先从方法区的运行时常量池中查找看是否有该值，如果有，则返回该值的引用，如果没有，那么就会将该值加入运行时常量池中。 参考：Java垃圾收集算法 对象标记算法 垃圾回收器在对堆内存进行回收前，第一件事情就是要确定哪些对象还”存活”中，哪些对象已经”死去”。 ###引用计数法 原理：给对象中添加一个引用计数器，每当有一个地方引用到它，计算器的值就加1，当引用失效的时候，计数器就减1，任何时刻计数器为0的对象就是没有被使用的对象，表示可以回收。 说明：这种方法在主流的虚拟机里面没有被采用，原因是它很难解决对象之间循环引用的问题。 ###可达性分析算法 原理：通过一系列称为”GC Roots”的对象作为起始起点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连时，则证明此对象没有被使用，可以被回收。 ###四中引用 （参考：Java的四种引用方式） 强引用 说明：是指创建一个对象并把这个对象赋给一个引用变量。 软引用（SoftReference） 说明：如果一个对象具有软引用，内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。 弱引用（WeakReference） 说明：弱引用也是用来描述非必需对象的，当JVM进行垃圾回收时，无论内存是否充足，都会回收被弱引用关联的对象。 虚引用 说明：它并不影响对象的生命周期，无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。 垃圾回收算法###标记清除算法 思路： 第一步：使用可达性分析算法将无用的对象标记出来； 第二步：将第一步标记的对象进行回收清除； 缺点： 1）效率问题：标记和清除的效率都不高； 2）空间问题：清除后会产生大量不连续的内存碎片。 ###复制算法（新生代） 思路： 第一步：将可用内存按容量划分为大小相等的两块，每次只使用其中的一块； 第二步：一块的内存用完了，就将还存活着的对象复制到另外一块上面； 第三步：把已使用的内存空间一次清理掉； 优点： 1）实现简单2）运行高效3）不容易产生碎片 缺点： 对内存空间的使用做出了高昂的代价，因为能够使用的内存缩减到原来的一半。 ###标记-整理算法（老年代） 思想： 在完成标记之后，它不是直接清理可回收对象，而是将存活对象都向一端移动，然后清理掉端边界以外的内存。 ###分代收集算法 思路： 根据对象存活的生命周期将内存划分为若干个不同的区域。 新生代： 包含有Enden (80%)、form survivor space (10%)、to survivor space(10%)三个区，绝大多数最新被创建的对象会被分配到这里，大部分对象在创建之后会变得很快不可达，在该区域发生的垃圾收集被称为Minor GC。 老年代： 从新生代存活下来的对象会被拷贝到这里，它的空间比新生代要大，所以在老年代上发生的GC要比新生代少得多。在该区域发生的垃圾收集被称为Major GC / Full GC。 持久代： 也被称为方法区，用来存放类常量和字符串常量，这个区域不是用来存储那些从老年代存活下来的对象。它也会发生GC操作。 内存分配与回收的策略 1）对象优先在Enden上分配 2）大对象可以直接进入老年代 （设置标签-XX:PretenureSizeThreshold = n） 3）长期存活的对象将进入老年代 注意：虚拟机给每个对象定义了一个对象年龄（Age）计数器。如果对象在Enden出生并且经过第一次Minor GC仍然存活，并且能够被Survivor空间容纳，进入移动到Survivor空间，并且设置对象年龄为1，对象在Survivor区每熬过一个Minor GC，年龄就增加1岁，当它的年龄到达一定的程度（默认为15岁），就会被移动到老年代，这个年龄阀值可以通过-XX:MaxTenuringThreshold设置。 动态对象年龄判断 说明：虚拟机并不是永远要求对象的年龄达到MaxTenuringThreshold才移动到老年代，如果Survivor区中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或者等于该年龄的对象也被移动到老年代。 空间分配担保 说明：在发生Minor GC之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那么Minor GC可以确保是安全的。如果不成立，则虚拟机会查看HandlePromotionFailure设置值是否允许担保失败。如果允许，那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次Minor GC，尽管这次Minor GC是有风险的；如果小于，或者HandlePromotionFailure设置不允许冒险，那这时也要改为进行一次Full GC。 垃圾收集器参考：Java HotSpot虚拟机的内存管理（垃圾收集）参考：7种垃圾收集器：主要特点 应用场景 设置参数 基本运行原理 新生代收集器： Serial、ParNew、Parallel Scavenge； 老年代收集器： Serial Old、Parallel Old、CMS； 整堆收集器： G1； 说明： 两个收集器间有连线，表明它们可以搭配使用。 ###Serial 收集器 Serial是最基本的收集器，历史悠久。是一个单线程收集器，而且它在进行垃圾回收的时候，必须暂停其他所有的工作线程，直到收集结束。这就意味着，每次进行垃圾收集都必须停掉用户正常工作的线程。 线程：单线程； 算法：复制算法； ###ParNew 收集器（新生代） ParNew是Serial的多线程版本。仍要停顿 线程：多线程； 算法：复制算法； ###Parallel Scavenge 收集器（新生代） Parallel Scavenge是一个新生代收集器，使用多线程和复制算法。相比其他收集器，只有这个收集器是针对系统吞吐量进行改进，适用于后台运算并且交互不多的程序。其他收集器则更关注改善收集时的停顿时间，适用于用户交互的程序。 吞吐量： 用于运行用户代码的时间与CPU总消耗时间的比值； 即吞吐量=运行用户代码时间 /（运行用户代码时间+垃圾收集时间）； 线程：多线程； 算法：复制算法； 注意： 通常，平均响应时间越短，系统吞吐量越大；平均响应时间越长，系统吞吐量越小。但是，系统吞吐量越大，未必平均响应时间越短。因为在某些情况（例如，不增加任何硬件配置）吞吐量的增大，有时会把平均响应时间作为牺牲，来换取一段时间处理更多的请求。 ###Serial Old 收集器（老年代） Serial Old是Serial的老年代版本，专门用于收集老年代，采用“标记整理算法”。 线程：单线程； 算法：标记整理算法； ###Parallel Old 收集器（老年代） Parallel Old是Parallel Scavenge的老年代版本，使用多线程和“标记整理算法”。 线程：多线程； 算法：标记整理算法； ###CMS 收集器（老年代） 说明： CMS收集器是一种以获取最短回收停顿时间为目标的收集器，给用用户带来较好的体验，可称之为并发低停顿收集器。基于标记-清除算法实现。可用于新、老代收集，一般用于老年代收集，然后搭配一个新生代收集器(可以是Serial和ParNew) 缺点： 1）对CPU资源敏感（因为是并发）。在并发阶段，虽然不会导致用户线程停顿，但是会因为占用了一部分线程（即CPU资源）而导致用户应用程序变慢，总吞吐量降低。 2）无法处理浮动垃圾。因为是边收集，边产生垃圾。 3）标记-清除算法会产生空间碎片。需要额外碎片整理过程，停顿时间变长。 线程：多线程； 算法：标记清除算法； ###G1 收集器 说明： G1收集器是当前收集器技术发展最前沿的成果。基于标记-整理算法，可以精确控制停顿。基本不牺牲吞吐量的前提下完成低停顿的内存回收。这是由于它将新生代、老年代划分为多个区域，并维护一个每个区域收集的优先列表，保证了在有限的时间内可以获得最高的收集效率。 缺点：没有经过实际应用的考验，缺少测试。 ###应用场景总结： 用户交互：ParNew、CMS 高吞吐量：Parallel Scavenge fullGC和MinorGC区别Minor GC（新生代GC）：发生在新生代的垃圾收集动作，因为Java对象大多数都具备朝生夕灭的特点，所以Minor GC 非常频繁，通常回收速度比较快。 Major GC / Full GC（老年代GC）：指发生在老年代的GC，速度一般会比Minor GC慢10倍以上。 触发条件： Minor GC：当Eden区满时，触发Minor GC。 Major / Full GC： 1）调用System.gc时，系统建议执行Full GC，但是不必然执行 2）老年代空间不足 3）方法区空间不足 说明： 1）通过Minor GC后进入老年代的平均大小大于老年代的可用内存 2）由Eden区、From Space区向To Space区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小。 类加载机制说明： Java虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的加载机制。 类从被加载到虚拟机内存中到卸载出内存为止，它的整个生命周期如下： 加载： 查找和导入Class文件； 连接： 把类的二进制数据合并到JRE中； 1）验证：检查载入Class文件数据的正确性； 2）准备：给类的静态变量分配存储空间； 3）解析：将常量池符号引用转成直接引用； 初始化： 对类的静态变量，静态代码块执行初始化操作； 注意： 加载、验证、准备、初始化和卸载这五个阶段的顺序是确定的，类的加载过程必须按照这个顺序来按部就班地开始，而解析阶段则不一定，它在某些情况下可以在初始化阶段后再开始。 说明： Java程序可以动态扩展是由运行期动态加载和动态链接实现的。比如：如果编写一个使用接口的应用程序，可以等到运行时再指定其实际的实现(多态)，解析过程有时候还可以在初始化之后执行；比如：动态绑定(多态)。 结束生命周期： 在以下情况的时候，Java虚拟机会结束生命周期 执行了System.exit()方法； 程序正常执行结束； 程序在执行过程中遇到了异常或错误而异常终止； 由于操作系统出现错误而导致Java虚拟机进程终止； 下面展开分析： 加载说明：1）将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内。 2）然后在堆区创建一个java.lang.Class对象，用来封装类在方法区内的数据结构。 3）类的加载的最终产品是位于堆区中的Class对象，Class对象封装了类在方法区内的数据结构，并且向Java程序员提供了访问方法区内的数据结构的接口。 注意： 类加载器并不需要等到某个类被“首次主动使用”时再加载它，JVM规范允许类加载器在预料某个类将要被使用时就预先加载它。 加载class文件方式： 1）从本地系统中直接加载 2）通过网络下载.class文件 3）从zip，jar等归档文件中加载.class文件 4）从专有数据库中提取.class文件 5）将Java源文件动态编译为.class文件 加载阶段，虚拟机完成工作： 1）通过一个类的全限定名称来获取定义此类的二进制字节流。 2）将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。 3）在java堆中生成一个代表这个类的java.lang.Class对象，作为方法区这些数据的访问入口。 验证说明： 验证的目的是为了确保Class文件中的字节流包含的信息符合当前虚拟机的要求，而且不会危害虚拟机自身的安全。不同的虚拟机对类验证的实现可能会有所不同，但大致都会完成以下四个阶段的验证：文件格式的验证、元数据的验证、字节码验证和符号引用验证。 1）文件格式的验证：验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理，该验证的主要目的是保证输入的字节流能正确地解析并存储于方法区之内。经过该阶段的验证后，字节流才会进入内存的方法区中进行存储，后面的三个验证都是基于方法区的存储结构进行的。 2）元数据验证：对类的元数据信息进行语义校验（其实就是对类中的各数据类型进行语法校验），保证不存在不符合Java语法规范的元数据信息。 3）字节码验证：该阶段验证的主要工作是进行数据流和控制流分析，对类的方法体进行校验分析，以保证被校验的类的方法在运行时不会做出危害虚拟机安全的行为。 4） 符号引用验证：这是最后一个阶段的验证，它发生在虚拟机将符号引用转化为直接引用的时候（解析阶段中发生该转化，后面会有讲解），主要是对类自身。 ###准备 说明： 准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中进行分配。 1）这时候进行内存分配的仅包括类变量（static），而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在Java堆中。 2）这里所设置的初始值通常情况下是数据类型默认的零值（如0、0L、null、false等），而不是被在Java代码中被显式地赋予的值。 ###解析 说明： 解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。 1）符号引用（Symbolic Reference）：符号引用以一组符号来描述所引用的目标，符号引用可以是任何形式的字面量，符号引用与虚拟机实现的内存布局无关，引用的目标并不一定已经在内存中。 2）直接引用（Direct Reference）：直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用是与虚拟机实现的内存布局相关的，同一个符号引用在不同的虚拟机实例上翻译出来的直接引用一般都不相同，如果有了直接引用，那引用的目标必定已经在内存中存在。 解析分析： 1）类或接口的解析：判断所要转化成的直接引用是对数组类型，还是普通的对象类型的引用，从而进行不同的解析。 2）字段解析：对字段进行解析时，会先在本类中查找是否包含有简单名称和字段描述符都与目标相匹配的字段，如果有，则查找结束；如果没有，则会按照继承关系从上往下递归搜索该类所实现的各个接口和它们的父接口，还没有，则按照继承关系从上往下递归搜索其父类，直至查找结束。 3）类方法解析：对类方法的解析与对字段解析的搜索步骤差不多，只是多了判断该方法所处的是类还是接口的步骤，而且对类方法的匹配搜索，是先搜索父类，再搜索接口。 4）接口方法解析：与类方法解析步骤类似，只是接口不会有父类，因此，只递归向上搜索父接口就行了。 ###初始化 说明： 类初始化阶段是类加载过程的最后一步，前面的类加载过程中，除了加载（Loading）阶段用户应用程序可以通过自定义类加载器参与之外，其余动作完全由虚拟机主导和控制。到了初始化阶段，才真正开始执行类中定义的Java程序代码。 初始化： 为类的静态变量赋予正确的初始值，JVM负责对类进行初始化，主要对类变量进行初始化。在Java中对类变量进行初始值设定有两种方式： 1）声明类变量时指定初始值； 2）使用静态代码块为类变量指定初始值； 类初始化的触发条件: 只有当对类的主动使用的时候才会导致类的初始化。 1）遇到new、getstatic、putstatic或invokestatic这4条字节码指令时，如果类没有进行过初始化，则需要先触发其初始化。生成这4条指令的最常见的Java代码场景是：使用new关键字实例化对象的时候，读取或设置一个类的静态字段（被final修饰、已在编译期把结果放入常量池的静态字段除外）的时候，以及调用一个类的静态方法的时候。 2）使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。 3）当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。 4）当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类。 说明： 只有上述四种情况会触发初始化，也称为对一个类进行主动引用，除此以外，所有其他方式都不会触发初始化，称为被动引用。 通俗的解释对应下面的六种: 1）创建类的实例，也就是new的方式； 2）或者对该静态变量赋值； 3）调用类的静态方法； 4）反射（如Class.forName(“com.shengsiyuan.Test”)）； 5）初始化某个类的子类，则其父类也会被初始化； 6）Java虚拟机启动时被标明为启动类的类（Java Test），直接使用java.exe命令来运行某个主类； 类加载器与双亲委派模型###类加载器 说明： 在类加载的第一阶段“加载”过程中，需要通过一个类的全限定名来获取定义此类的二进制字节流，完成这个动作的代码块就是类加载器。这一动作是放在Java虚拟机外部去实现的，以便让应用程序自己决定如何获取所需的类。 注意： 1）虚拟机规范并没有指明二进制字节流要从一个Class文件获取，或者说根本没有指明从哪里获取、怎样获取。 2）JVM中两个类是否“相等”，首先就必须是同一个类加载器加载的，否则，即使这两个类来源于同一个Class文件，被同一个虚拟机加载，只要类加载器不同，那么这两个类必定是不相等的。 ###类加载器分类 说明：从Java虚拟机的角度来说，只存在两种不同的类加载器：一种是（Bootstrap ClassLoader），这个类加载器使，是虚拟机自身的一部分；另一种就是所有其他的类加载器，这些类加载器都有Java语言实现，独立于虚拟机外部，并且全部继承自java.lang.ClassLoader。 JVM虚拟机角度： 1）启动类加载器（用C++语言实现（HotSpot虚拟机中），是虚拟机自身的一部分） 2）其他的类加载器（由Java语言实现，独立于虚拟机外部，继承自java.lang.ClassLoader类。） 开发者的角度： 1）启动（Bootstrap）类加载器（将Java_Home/lib下面的类库加载到内存中（比如rt.jar），开发者无法直接引用） 2）扩展（Extension）类加载器（将Java_Home/lib/ext或者由系统变量 java.ext.dir指定位置中的类库加载到内存中。开发者可以直接使用） 3）应用程序（Application）类加载器（将系统类路径（CLASSPATH）中指定的类库加载到内存中。开发者可以直接使用，由于这个类加载器是ClassLoader中的getSystemClassLoader()方法的返回值，因此一般称为系统（System）加载器。） ###双亲委派模型 说明： 该模型要求除了顶层的启动类加载器外，其余的类加载器都应该有自己的父类加载器，而这种父子关系一般通过组合（Composition）关系来实现，而不是通过继承（Inheritance）。 1234567891011121314151617181920212223protectedsynchronized Class&lt;?&gt; loadClass(String name,boolean resolve) throws ClassNotFoundException &#123; //首先判断该类型是否已经被加载 Class c = findLoadedClass(name); if (c ==null) &#123; //如果没有被加载，就委托给父类加载或者委派给启动类加载器加载 try &#123; //如果存在父类加载器，就委派给父类加载器加载 if (parent !=null) &#123; c = parent.loadClass(name,false); //如果不存在父类加载器，就检查是否是由启动类加载器加载的类，通过调用本地方法native Class findBootstrapClass(String name) &#125;else &#123; c = findBootstrapClass0(name); &#125; &#125;catch (ClassNotFoundException e) &#123; //如果父类加载器和启动类加载器都不能完成加载任务，才调用自身的加载功能 c = findClass(name); &#125; &#125; if (resolve) &#123; resolveClass(c); &#125; return c;&#125; 执行过程： 某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父类加载器，依次递归，如果父类加载器可以完成类加载任务，就成功返回；只有父类加载器无法完成此加载任务时，才自己去加载。 注意： 双亲委派模型是Java设计者推荐给开发者的类加载器的实现方式，并不是强制规定的。大多数的类加载器都遵循这个模型，但是JDK中也有较大规模破坏双亲模型的情况，例如线程上下文类加载器（Thread Context ClassLoader）的出现。 与垃圾回收相关的JVM参数-Xms / -Xmx ：堆的初始大小 / 堆的最大大小-Xmn ：堆中年轻代的大小-XX:-DisableExplicitGC ：让System.gc()不产生任何作用-XX:+PrintGCDetails ：打印GC的细节-XX:+PrintGCDateStamps ：打印GC操作的时间戳-XX:NewSize / XX:MaxNewSize ： 设置新生代大小/新生代最大大小-XX:NewRatio ：可以设置老生代和新生代的比例-XX:PrintTenuringDistribution： 设置每次新生代GC后输出幸存者乐园中对象年龄的分布-XX:InitialTenuringThreshold / -XX:MaxTenuringThreshold：设置老年代阀值的初始值和最大值-XX:TargetSurvivorRatio：设置幸存区的目标使用率 为什么新生代内存需要有两个Survivor区]]></content>
      <tags>
        <tag>虚拟机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络基础知识]]></title>
    <url>%2F2018%2F04%2F25%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[基本概念1）宽带猫 ADSL（宽带）的猫准确的名称叫做“调制解调器”。它是在发送端通过调制将数字信号转换为模拟信号，而在接收端通过解调再将模拟信号转换为数字信号的一种装置。现在的光纤网络，大多都不再需要调制解调器。 2）集线器 集线器的英文称为“Hub”。“Hub”是“中心”的意思，集线器的主要功能是对接收到的信号进行再生整形放大，以扩大网络的传输距离，同时把所有节点集中在以它为中心的节点上。 3）路由器 路由器大家都知道，插进去网线，设定好拨号，可以给多台电脑共享网络了，一般路由器有两个部分组成，WAN和LAN，WAN是用来拨号的，是让路由自身能上网的一个部分，LAN是用来局域网内交换数据的，跟交换机的作用一样，我们的电脑插在LAN口才能上网。 4）交换机 是不能拨号的路由器，也就是说他只有LAN，没有WAN。 5）集线器和交换机区别 集线器采用的是共享带宽的工作方式，简单打个比如，集线器就好比一条单行道，“10M”的带宽分多个端口使用，当一个端口占用了大部分带宽后，另外的端口就会显得很慢。相反，交换机是一个独享的通道，它能确保每个端口使用的带宽，如百兆的交换机，它能确保每个端口都有百兆的带宽。正因为交换机比集线器有着明显的优势，目前的集线器可说绝迹市场了。 网络传输过程： 1）ISP（internet service provider)通过电话线将数据连接到猫； 2）猫经过调制解调将数据转换为计算机能识别的数据； 3）将转换出来的数据连接到路由器，路由器的WAN口用来实现拨号功能，LAN口用来扩展接口，以方便连接到多个计算机； 4）但是路由器的可扩展接口往往不够用，需要交换机来扩展更多的接口，交换机只有LAN口； OSI参考模型OSI（Open Systems Interconnection Reference Model）OSI/RM简称OSI开放系统互连参考模型，通俗的将就是我们说的7层协议的体系结构应用层、表示层、会话层、传输层、网络层、链路层、物理层。 注意： 这七层是在发送数据到网线之前，在计算机中内部就已经经过了这7层，不是在传输过程中才慢慢经过这7层的。 应用层： 所有产生网络流量的程序。 表示层： 在传输数据之前进行的一些操作(加密，压缩，发送数据使用的编码等)。 例如：发送数据使用的是UTF-8来编码，而在浏览器用别的编码来解码，就会出现乱码，这就是表示层出现了问题。 会话层： 在传输数据时，需要通道，就需要创建会话，以防请求方和目标方不知道谁是谁。 例如：访问百度，则会与主机上存放百度网页的地址创建了会话，请求接收到了全部数据，则会话结束。 传输层： 就是传输数据的过程，因为有了前面表示层和会话层做的一些事情，已经具备传输数据的条件了。 可靠传输：通过网址访问主机之间，进行的传输是一来一往，而且进行多次交流，多个数据包； 不可靠传输：通过网址到DNS解析器解析域名真实地址的过程，就是不可靠传输，只需要一个数据包，去一个，回一个就完成了。 网络层： 规划最佳路径，规划ip地址， 传输数据到目标地址的过程中，经过哪些路由器，也就是走什么路径，就是网络层做的事情。 数据链路层： 对数据帧的开始与结束 差错校验。 发送数据是分组发送的，不是一次性发送，每次发送一组数据，如何知道这一组数据就是我们发的呢？就需要在数据的开始和结束定义一个特殊的东西，让路由器或交换机知道该数据什么时候开始，什么时候结束。 差错校验，在接受完一组数据后，校验数据是否完整，如果有问题，则丢掉，让计算机重新发一次。 物理层： 定义网络接口标准 网线的水晶头，里面都是8根线，0101如果定义，用1V代表1，0V代表0，类似这样规定，不可能一个商家50V代表1，这样1V那个规定将会出现问题。 TCP/IP的体系结构分为4层： 网络接口层(物理层、链路层)、网际层(网络层IP)、传输层(UDP/TCP)、应用层(会话层、表示层、应用层) 原理体系结构： 物理层、链路层、网络层、传输层、应用层(会话层+表示层+应用层) 发送数据将数据封装起来，看看每个层次都做了什么事 看看数据封装之后的样子 网络层参考博客：网络层 ###IP地址：&lt;网络地址&gt; + &lt;端口地址&gt; 网络地址=IP地址和子网掩码进行与运算 例如： 已知ip地址141.14.72.24，所在网络的子网掩码是255.255.192.0，试求其网络地址？ 子网掩码：255.255.192.0 ————–11111111，11111111，11000000，00000000 IP地址：141.14.72.24 —————— 10001101，00001110，01001000，00011000 说明： 根据子网掩码知道ip地址的前18位为网络号，网络地址就为：10001101.00001110.01000000.00000000 转换为10进制就是141.14.64.0 网关： 路由器的IP地址 ###IP地址和MAC地址的区别？ MAC地址：物理地址 IP地址：网络中的地址 说明： 在网络中通过主机的IP地址，先找到他的网络地址，到达了网络地址后，然后通过该网络中的老大(路由器)来分析一下这个IP地址是你网路中的哪个主机，这时，老大(路由器)就通过该目标ip地址改到对应主机的MAC地址，既然知道了MAC地址，就能找到该计算机了。就好比什么呢。路由器是每次分配给你的IP地址不一样，但是你的MAC地址肯定不会变，所以就根据IP地址找到你的MAC地址。但是怎么找到的呢？就要通过网络层中的ARP(地址解析协议)解析了。 ###3. ARP协议 地址解析协议：通过IP地址来解析主机的MAC地址。 过程： 拿局域网来说，一个局域网中有很多主机，主机A想和局域网中的主机B通话，但是只知道对方的IP地址，所以他就通过发广播，给局域网中所有的主机，问这个IP地址是谁，主机B收到了这个信息，通过网络适配器(网卡)就发现自己是这个IP地址，然后就把自己的MAC地址发给源主机，这样就知道了MAC地址，就能够通信了。 在跨网络中就不是直接发广播了，先通过IP地址找到对应的网络地址，如何找到的对应的网络地址呢，通过路由器，每个路由器都有三层。网络层、链路层、物理层，也就是说最高能够识别网络层中的东西来，那么路由器也就有ARP协议了，每个路由器都能识别出目标IP地址在哪个路由器上，这其中涉及到了很多算法，我们这里不做更多的解释，简单来说，路由器能根据目标IP地址找到下一跳路由器的MAC地址，然后一步一步跳下去，直到找到目标IP地址的网络地址的路由器，然后通过该路由器来找到目标IP地址的MAC地址，这样就能够找到目标主机了。这就是ARP协议。 ###4. IP协议 IP协议通过看一下IP数据包(报)的格式就知道IP协议是干嘛的了，就是来规定数据报的格式，以及定义的功能。 ###5. ICMP协议 这个比较简单，就两部分ICMP差错报告报文、ICMP询问报文。这个挺使用的，比如我们经常用来测试网络连接畅通的ping命令等。 ICMP差错报告报文：检测在传送数据的过程中，发生的错误，如果发生了错误，会通过该协议返回给源主机一个带有错误原因的数据包。 ICMP询问报文： 1）回送请求和回答： 主机向特定目标发出询问，收到此报文必须返回一个ICMP回送回答报文。用于测试目的站是否可达。 2）时间戳请求和回答： 请某个路由器或主机回答当前的日期和时间，用于进行时钟的同步和测量时间。 ###6. IGMP协议 主要用于多播。 广播： 老师在台上讲课，你们能随时看到老师的电脑屏幕，因为采用的广播，每个人都能接受到老师屏幕上所有的数据包。 多播： 在一个局域网中，有三个多播组，A、B、C，A在放java视频，B在放C++视频，C在放娱乐视频，如果你想看Java视频，那么你就调到A这个多播组中学习java视频，学习累了，你就可以换到C这个多播组中看看娱乐节目，这就是多播的意思，相对广播来说，自己需要什么就调什么，而不是跟广播一样，被动接受，他播到哪，就只能看到哪，多播能自由控制速度。 单播： 50个人想看视频，就得发送50个数据包。多播的话就发一个，然后通过路由器转发50分给不同的人， 传输层参考博客：传输层 运输层提供应用层提供端到端通信服务，网络层通过IP地址和MAC地址找到了主机，要实现两主机进程间的通讯，需要找到对应主机的端口号，一个端口号对应一个进程。 UDP协议UDP： User Datagram Protocol 用户数据报协议。 特点： 1. 无连接： 在通讯之前不需要建立连接，直接传输数据。 2. 不可靠： 是将数据报的分组从一台主机发送到另一台主机，但并不保证数据报能够到达另一端，任何必须的可靠性都由应用程序提供。在UDP情况下，虽然可以确保发送消息的大小，却不能保证消息一定会达到目的端。没有超时和重传功能，当UDP数据封装到IP数据报传输时，如果丢失，会发送一个ICMP差错报文给源主机。即使出现网络阻塞情况，UDP也无法进行流量控制。此外，传输途中即使出现丢包，UDP也不负责重发，甚至当出现包的到达顺序杂乱也没有纠正的功能。 应用场景： 1）应用层协议中DNS，也就是根据域名解析ip地址的一个协议，他使用的就是UDP； 2）DHCP，这个是给各电脑分配IP地址的协议，其中用的也是UDP协议； 3）IGMP，我们说的多播，也就是使用的UDP，在多媒体教师，老师拿笔记本讲课，我们在下面通过各自的电脑看到老师的画面，这就是通过UDP传输数据，所以会出现有的同学卡，有的同学很流畅，就是因为其不可靠传输，但是卡一下，对接下来的观看并没有什么映像。 TCP协议TCP： Transmission Control Protocol传输控制协议。 TCP协议是面向连接的、可靠传输、有流量控制，拥塞控制，面向字节流传输等很多优点的协议。其最终功能和UDP一样，在端和端之间进行通信，但是和UDP的区别还是很大的。 应用场景： 1）FTP：定义了文件传输协议，使用21端口。常说某某计算机开了FTP服务便是启动了文件传输服务。下载文件，上传主页，都要用到FTP服务。 2）Telnet：它是一种用于远程登陆的端口，用户可以以自己的身份远程连接到计算机上，通过这种端口可以提供一种基于DOS模式下的通信服务。如以前的BBS是-纯字符界面的，支持BBS的服务器将23端口打开，对外提供服务。 3）SMTP：定义了简单邮件传送协议，现在很多邮件服务器都用的是这个协议，用于发送邮件。如常见的免费邮件服务中用的就是这个邮件服务端口，所以在电子邮件设置-中常看到有这么SMTP端口设置这个栏，服务器开放的是25号端口。 4）POP3：Post Office Protocol 3的简称,即邮局协议的第3个版本，它是和SMTP对应，POP3用于接收邮件。通常情况下，POP3协议所用的是110端口。也是说，只要你有相应的使用POP3协议的程序（例如Fo-xmail或Outlook），就可以不以Web方式登陆进邮箱界面，直接用邮件程序就可以收到邮件（如是163邮箱就没有必要先进入网易网站，再进入自己的邮-箱来收信）。 5） HTTP：这是大家用得最多的协议，它就是常说的”超文本传输协议”。上网浏览网页时，就得在提供网页资源的计算机上打开80号端口以提供服务。常说”WWW服务”、”Web服务器”用的就是这个端口。 TCP三次握手建立连接 参考博客：（TCP三次握手） 有趣的例子： A:“喂，你听得到吗？”A-&gt;SYN_SEND B:“我听得到呀，你听得到我吗？”应答与请求同时发出 B-&gt;SYN_RCVD | A-&gt;ESTABLISHED A:“我能听到你，今天balabala……”B-&gt;ESTABLISHED 相关符号： 1. ACK： 确认，当ACK为1时，确认序号才有效。当ACK为0时，确认序号没用；2. SYN： 同步序号，用来发起一个连接；3. FIN： 终止标志，在释放连接时使用；（和SYN一样，一个FIN将占用一个序号）4. seq： 序号；5. ack： 确认序号；6. ISN： 初始序号(Initial Sequence Number),是随机产生的； 注意： 建立连接的最重要目是让连接的双方交换初始序号ISN(Initial Sequence Number)。 图片中x和y分别是客户端和服务器的ISN。 三次握手过程： 1）客户端发送SYN包(seq=x)到服务器，并进入SYN_SEND状态，等待服务器确认； 2）服务器收到SYN包，必须确认客户的SYN（ack=x+1），同时自己也发送一个SYN包（seq=y），即SYN+ACK包，此时服务器进入SYN_RECV状态； 3）客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=y+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。 TCP的三次握手过程？为什么会采用三次握手，若采用二次握手可以吗？TCP三次握手的思考，为什么要有三次握手 答：建立连接的过程是利用客户服务器模式，假设主机A为客户端，主机B为服务器端。 1）TCP的三次握手过程：主机A向B发送连接请求；主机B对收到的主机A的报文段进行确认；主机A再次对主机B的确认进行确认。 2）采用三次握手是为了防止失效的连接请求报文段突然又传送到主机B，因而产生错误。失效的连接请求报文段是指：主机A发出的连接请求没有收到主机B的确认，于是经过一段时间后，主机A又重新向主机B发送连接请求，且建立成功，顺序完成数据传输。考虑这样一种特殊情况，主机A第一次发送的连接请求并没有丢失，而是因为网络节点导致延迟达到主机B，主机B以为是主机A又发起的新连接，于是主机B同意连接，并向主机A发回确认，但是此时主机A根本不会理会，主机B就一直在等待主机A发送数据，导致主机B的资源浪费。 3）采用两次握手不行，原因就是上面说的实效的连接请求的特殊情况。 TCP四次挥手断开连接 有趣的例子： A:“喂，我不说了。”A-&gt;FIN_WAIT1 B:“我知道了。等下，上一句还没说完。Balabala…..”B-&gt;CLOSE_WAIT | A-&gt;FIN_WAIT2 B:”好了，说完了，我也不说了。”B-&gt;LAST_ACK A:”我知道了。”A-&gt;TIME_WAIT | B-&gt;CLOSED A等待2MSL,保证B收到了消息,否则重说一次”我知道了”,A-&gt;CLOSED TCP四次挥手断开连接过程 假设主机A为客户端，主机B为服务器，其释放TCP连接的过程如下： 1）关闭客户端到服务器的连接：首先客户端A发送一个FIN，用来关闭客户到服务器的数据传送，然后等待服务器的确认。其中终止标志位FIN=1，序列号seq=u 2）服务器收到这个FIN，它发回一个ACK，确认号ack为收到的序号加1。 3）关闭服务器到客户端的连接：也是发送一个FIN给客户端。 4）客户段收到FIN后，并发回一个ACK报文确认，并将确认序号seq设置为收到序号加1。 首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。 为什么TCP释放连接需要四次？ TCP建立连接要进行三次握手，而断开连接要进行四次。这是由于TCP的半关闭造成的。因为TCP连接是全双工的(即数据可在两个方向上同时传递)所以进行关闭时每个方向上都要单独进行关闭。这个单方向的关闭就叫半关闭。当一方完成它的数据发送任务，就发送一个FIN来向另一方通告将要终止这个方向的连接。 A为什么等待2MSL，从TIME_WAIT到CLOSE？ 在Client发送出最后的ACK回复，但该ACK可能丢失。Server如果没有收到ACK，将不断重复发送FIN片段。所以Client不能立即关闭，它必须确认Server接收到了该ACK。Client会在发送出ACK之后进入到TIME_WAIT状态。Client会设置一个计时器，等待2MSL的时间。如果在该时间内再次收到FIN，那么Client会重发ACK并再次等待2MSL。所谓的2MSL是两倍的MSL(Maximum Segment Lifetime)。MSL指一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大时间。如果直到2MSL，Client都没有再次收到FIN，那么Client推断ACK已经被成功接收，则结束TCP连接。 应用层参考博客：DNS协议 参考博客：HTTP协议 参考博客：HTTP断线续传原理 参考博客：Http和Https区别参考博客：Https原理解析 访问一个网站的基本流程参考：访问一个网站的基本流程]]></content>
  </entry>
  <entry>
    <title><![CDATA[Servlet基本知识]]></title>
    <url>%2F2018%2F04%2F25%2FServlet%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[注意：开发Servlet需要导入servlet-api.jar包。 get和post的区别get是form默认的提交方式。如果通过一个超链访问某个地址，是get方式如果在地址栏直接输入某个地址，是get方式提交数据会在浏览器显示出来不可以用于提交二进制数据，比如上传文件。 哪些是get方式呢？ 1）form默认的提交方式2）如果通过一个超链访问某个地址3）如果在地址栏直接输入某个地址4）ajax指定使用get方式的时候 post必须在form上通过 method=”post” 显示指定。提交数据不会在浏览器显示出来可以用于提交二进制数据，比如上传文件。 哪些是post方式呢？ 1）在form上显示设置 method=”post”的时候2）ajax指定post方式的时候 生命周期Servlet 生命周期可被定义为从创建直到毁灭的整个过程。以下是 Servlet 遵循的过程： 1）实例化：当用户通过浏览器输入一个路径，这个路径对应的servlet被调用的时候，该Servlet就会被实例化。注意： 不管访问多少次servlet，只会实例化一次，这是由Tomcat服务器实例化的。 2）初始化：init方式是一个实例方法，所以会在构造方法执行后执行。注意： init初始化 只会执行一次。 3）提供服务：接下来就是执行service()方法，然后通过浏览器传递过来的信息进行判断，是调用doGet()还是doPost()方法。 4）销毁：调用destroy()方法。 5） 被回收：当该Servlet被销毁后，就满足垃圾回收的条件了。当下一次垃圾回收GC来临的时候，就有可能被回收。 在如下几种情况下，会调用destroy()： 1）该Servlet所在的web应用重新启动。 2）关闭tomcat的时候 destroy()方法会被调用，但是这个一般都发生的很快，不易被发现。 Servlet三种实现方式参考博客：（Servlet三种实现方式） 1）实现Servlet接口，然后实现接口中的五个方法； 2）继承GenericServlet，只需要实现一个方法：service； 3）继承HttpServlet,复写doGet和doPost方法；（最常用） Servlet中页面的跳转1）在服务端进行页面跳转 request.getRequestDispatcher(“success.html”).forward(request, response); 2）在客户端进行页面跳转 response.sendRedirect(“fail.html”);]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>servlet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jsp基础知识]]></title>
    <url>%2F2018%2F04%2F25%2FJsp%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[通过Servlet进行整个网站的开发是可以的。不过在Servlet中输出html代码，特别是稍微复杂一点的html代码，就会给人一种很酸爽的感觉。 Jsp文件开头1&lt;%@page contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot; import=&quot;java.util.*&quot;%&gt; 是JSP的&lt;%@page指令 1contentType=&quot;text/html; charset=UTF-8&quot; 相当于response.setContentType(“text/html; charset=UTF-8”); 通知浏览器以UTF-8进行中文解码1pageEncoding=&quot;UTF-8&quot; 如果jsp文件中出现了中文，这些中文使用UTF-8进行编码1import=&quot;java.util.* 导入其他类，如果导入多个类，彼此用,逗号隔开，像这样 import=”java.util.,java.sql.“ 为什么Jsp是Servlet?页面元素jsp由这些页面元素组成： 1）静态内容就是html,css,javascript等内容 2）指令以&lt;%@开始 %&gt; 结尾，比如&lt;%@page import=”java.util.*”%&gt; 3）表达式 &lt;%=%&gt;用于输出一段html 4）Scriptlet在&lt;%%&gt; 之间，可以写任何java 代码 5）声明在&lt;%!%&gt; 之间可以声明字段或者方法。但是不建议这么做。 6）动作&lt;jsp:include page=”Filename” &gt; 在jsp页面中包含另一个页面。在包含的章节有详细的讲解 7）注释 &lt;%– – %&gt;不同于 html的注释 通过jsp的注释，浏览器也看不到相应的代码，相当于在servlet中注释掉了 指令include和动作include区别指令include1&lt;%@include file=&quot;footer.jsp&quot; %&gt; footer.jsp的内容会被插入到 hello.jsp 转译 成的hello_jsp.java中，最后只会生成一个hello_jsp.java文件 动作include1&lt;jsp:include page=&quot;footer.jsp&quot; /&gt; footer.jsp的内容不会被插入到 hello.jsp 转译成的hello_jsp.java中，还会有一个footer_jsp.java独立存在。 hello_jsp.java 会在服务端访问footer_.jsp.java,然后把返回的结果，嵌入到响应中。 传递参数 因为指令&lt;%@include 会导致两个jsp合并成为同一个java文件，所以就不存在传参的问题，在发出hello.jsp 里定义的变量，直接可以在footer.jsp中访问。 而动作&lt;jsp:include /&gt;其实是对footer.jsp进行了一次独立的访问，那么就有传参的需要。 cookie1）Cookie是一种浏览器和服务器交互数据的方式。 2）Cookie是由服务器端创建，但是不会保存在服务器。 3）创建好之后，发送给浏览器。浏览器保存在用户本地。 4）下一次访问网站的时候，就会把该Cookie发送给服务器。 sessionSession对应的中文翻译是会话。 会话指的是从用户打开浏览器访问一个网站开始，无论在这个网站中访问了多少页面，点击了多少链接，都属于同一个会话。 直到该用户关闭浏览器为止，都属于同一个会话。 session 原理（和cookie配合工作） 1）当在同一个浏览器中同时打开多个标签，发送同一个请求或不同的请求，仍是同一个session； 2）当不在同一个窗口中打开相同的浏览器时，发送请求，仍是同一个session； 3）当使用不同的浏览器时，发送请求，即使发送相同的请求，是不同的session； 4）当把当前某个浏览器的窗口全关闭，再打开，发起相同的请求时，就是本文所阐述的，是不同的session； 如果没有cookie，session如何工作 cookie和session区别和联系？ 具体来说cookie机制采用的是在客户端保持状态的方案，而session机制采用的是在服务器端保持状态的方案。两者存储的都是用户登录信息，操作行为等等的数据。 访问同一个服务器1） cookie是把用户的数据写在用户本地浏览器上,其他网站也可以扫描使用你的cookie，容易泄露自己网站用户的隐私，而且一般浏览器对单个网站站点有cookie数量与大小的限制。 2）Session是把用户的数据写在用户的独占session上，存储在服务器上，一般只将session的id存储在cookie中。但将数据存储在服务器对服务器的成本会高。 3）session是由服务器创建的，开发人员可以在服务器上通过request对象的getsession方法得到session。 4）一般情况，登录信息等重要信息存储在session中，其他信息存储在cookie中。 JSP有4个作用域1） pageContext 当前页面 2）requestContext 一次请求 注意： 服务端跳转算一次请求，而客户端跳转不算一次请求。 3）sessionContext 当前会话（当前用户） 4）applicationContext 全局，所有用户共享 JSP九大隐式对象1）request对象 request 对象是 javax.servlet.httpServletRequest类型的对象。 该对象代表了客户端的请求信息，主要用于接受通过HTTP协议传送到服务器的数据。（包括头信息、系统信息、请求方式以及请求参数等）。request对象的作用域为一次请求。 2）response对象 response 代表的是对客户端的响应，主要是将JSP容器处理过的对象传回到客户端。response对象也具有作用域，它只在JSP页面内有效。 3）session对象 session 对象是由服务器自动创建的与用户请求相关的对象。服务器为每个用户都生成一个session对象，用于保存该用户的信息，跟踪用户的操作状态。session对象内部使用Map类来保存数据，因此保存数据的格式为 “Key/value”。 session对象的value可以使复杂的对象类型，而不仅仅局限于字符串类型。 4）application对象 application 对象可将信息保存在服务器中，直到服务器关闭，否则application对象中保存的信息会在整个应用中都有效。与session对象相比，application对象生命周期更长，类似于系统的“全局变量”。 5）out 对象 out 对象用于在Web浏览器内输出信息，并且管理应用服务器上的输出缓冲区。在使用 out 对象输出数据时，可以对数据缓冲区进行操作，及时清除缓冲区中的残余数据，为其他的输出让出缓冲空间。待数据输出完毕后，要及时关闭输出流。 6）pageContext 对象 pageContext 对象的作用是取得任何范围的参数，通过它可以获取 JSP页面的out、request、reponse、session、application 等对象。pageContext对象的创建和初始化都是由容器来完成的，在JSP页面中可以直接使用 pageContext对象。 7）config 对象 config 对象的主要作用是取得服务器的配置信息。通过 pageConext对象的 getServletConfig() 方法可以获取一个config对象。当一个Servlet 初始化时，容器把某些信息通过 config对象传递给这个 Servlet。 开发者可以在web.xml 文件中为应用程序环境中的Servlet程序和JSP页面提供初始化参数。 8）page 对象 page 对象代表JSP本身，只有在JSP页面内才是合法的。 page隐含对象本质上包含当前 Servlet接口引用的变量，类似于Java编程中的 this 指针。 9）exception 对象 exception 对象的作用是显示异常信息，exception对象只有当前页面的&lt;%@page 指令设置为isErrorPage=”true”的时候才可以使用。同时，在其他页面也需要设置 &lt;%@page 指令 errorPage=”” 来指定一个专门处理异常的页面。 JSTL标准标签库为了能够在JSP 中使用JSTL，首先需要两个jar包，分别是jstl.jar 和standard.jar EL表达式MVC架构M 代表 模型（Model），模型就是数据，就是dao,bean V 代表 视图（View），就是网页, JSP，用来展示模型中的数据 C 代表 控制器（controller），控制器的作用就是把不同的数据(Model)，显示在不同的视图(View)上。（控制将数据转发到什么视图）]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>jsp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring框架基础知识]]></title>
    <url>%2F2018%2F04%2F25%2FSpring%E6%A1%86%E6%9E%B6%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[IOC/DIIOC—Inversion of Control ，即“控制反转”，不是什么技术，而是一种设计思想。在Java开发中，Ioc意味着将你设计好的对象交给容器控制，而不是传统的在你的对象内部直接控制。 DI—Dependency Injection ，即“依赖注入”：组件之间依赖关系由容器在运行期决定，形象的说，即由容器动态的将某个依赖关系注入到组件之中。 理解： 在平时的java应用开发中，我们要实现某一个功能或者说是完成某个业务逻辑时至少需要两个或以上的对象来协作完成，在没有使用Spring的时候，每个对象在需要使用他的合作对象时，自己均要使用像new object() 这样的语法来将合作对象创建出来，这个合作对象是由自己主动创建出来的，创建合作对象的主动权在自己手上，自己需要哪个合作对象，就主动去创建，创建合作对象的主动权和创建时机是由自己把控的，而这样就会使得对象间的耦合度高了，A对象需要使用合作对象B来共同完成一件事，A要使用B，那么A就对B产生了依赖，也就是A和B之间存在一种耦合关系，并且是紧密耦合在一起，而使用了Spring之后就不一样了，创建合作对象B的工作是由Spring来做的，Spring创建好B对象，然后存储到一个容器里面，当A对象需要使用B对象时，Spring就从存放对象的那个容器里面取出A要使用的那个B对象，然后交给A对象使用，至于Spring是如何创建那个对象，以及什么时候创建好对象的，A对象不需要关心这些细节问题(你是什么时候生的，怎么生出来的我可不关心，能帮我干活就行)，A得到Spring给我们的对象之后，两个人一起协作完成要完成的工作即可。 DI其实就是IOC的另外一种说法。DI是由Martin Fowler 在2004年初的一篇论文中首次提出的。他总结：控制的什么被反转了？就是：获得依赖对象的方式反转了。 Bean的生命周期1）Spring IOC 容器对 Bean 的生命周期进行管理的过程： 1）通过构造器或工厂方法创建 Bean 实例2）为 Bean 的属性设置值和对其他 Bean 的引用3）调用 Bean 的初始化方法4）Bean 可以使用了5）当容器关闭时, 调用 Bean 的销毁方法 说明：在Bean的声明里设置 init-method 和 destroy-method 属性, 为Bean指定初始化和销毁方法。 2）（添加bean的后置处理器后）Spring IOC 容器对 Bean 的生命周期进行管理的过程： 1）通过构造器或工厂方法创建 Bean 实例2）为 Bean 的属性设置值和对其他 Bean 的引用3）将 Bean 实例传递给 Bean 后置处理器的postProcessBeforeInitialization 方法4）调用 Bean 的初始化方法5）将 Bean 实例传递给 Bean 后置处理器的postProcessAfterInitialization方法6）Bean 可以使用了7）当容器关闭时, 调用 Bean 的销毁方法 使用注解来注入对象@Autowired 注解 （推荐使用） 说明： 1）注解自动装配具有兼容类型的单个 Bean属性。 2）构造器, 普通字段(即使是非 public), 一切具有参数的方法都可以应用@Authwired 注解 @Resource 注解（要求提供一个 Bean名称的属性，若该属性为空，则自动采用标注处的变量或方法名作为 Bean 的名称） @Inject 注解（和@Autowired 注解一样也是按类型匹配注入的Bean，但没有 required 属性） 在classpath中扫描特定组件组件扫描(component scanning): Spring 能够从classpath下自动扫描，侦测和实例化具有特定注解的组件。 通过在配置文件中声明： 1&lt;context:component-scan base-package=&quot;com.atguigu.spring.beans&quot;&gt; 特定组件包括： @Repository Spring在容器初始化时将自动扫描base-package指定的包及其子包下的所有class文件，所有标注了 @Repository 的类都将被注册为Spring Bean。 为什么 @Repository 只能标注在DAO类上呢？ 这是因为该注解的作用不只是将类识别为Bean，同时它还能将所标注的类中抛出的数据访问异常封装为 Spring 的数据访问异常类型。 Spring本身提供了一个丰富的并且是与具体的数据访问技术无关的数据访问异常结构，用于封装不同的持久层框架抛出的异常，使得异常独立于底层的框架。 @Component 是一个泛化的概念，仅仅表示一个组件 (Bean) ，可以作用在任何层次。 @Service 通常作用在业务层，但是目前该功能与 @Component 相同。 @Constroller 通常作用在控制层，但是目前该功能与 @Component 相同。 Spring AOP代理设计模式的原理: 使用一个代理将对象包装起来，然后用该代理对象取代原始对象。任何对原始对象的调用都要通过代理。代理对象决定是否以及何时将方法调用转到原始对象上。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package com.atguigu.spring.aop.helloworld;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;import java.util.Arrays;public class ArithmeticCalculatorLoggingProxy &#123; //要代理的对象 private ArithmeticCalculator target; public ArithmeticCalculatorLoggingProxy(ArithmeticCalculator target) &#123; this.target = target; &#125; public ArithmeticCalculator getLoggingProxy() &#123; ArithmeticCalculator proxy = null; //代理对象由哪一个类加载器进行加载，getClass()运行时加载 ClassLoader loader = target.getClass().getClassLoader(); //代理对象的类型，即其中有哪些方法，".calss"编译时加载 Class [] interfaces = new Class[]&#123;ArithmeticCalculator.class&#125;; //当调用代理对象其中的方法时，该执行的代码 InvocationHandler h = new InvocationHandler() &#123; /** * proxy: 正在返回的那个代理对象。一般情况下，在invoke方法中都不使用该对象。 * method: 正在被调用的方法 * args: 调用方法时，传入的参数 */ @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; String methodName = method.getName(); //日志 System.out.println("The method" + methodName + "begins with " + Arrays.asList(args)); //执行方法 Object result = null; try &#123; //前置通知 //target:执行这个方法的对象; //args:执行这个方法的参数; result = method.invoke(target, args); //返回通知，可以访问到方法的返回值 &#125; catch (Exception e)&#123; e.printStackTrace(); //异常通知，可以访问到方法出现的异常 &#125; //后置通知，因为方法可能会出现异常，所以访问不到方法的返回值 //日志 System.out.println("The method" + methodName + " ends with " + result); return result; &#125; &#125;; proxy = (ArithmeticCalculator) Proxy.newProxyInstance(loader, interfaces, h); return proxy; &#125;&#125; 参考博客：AOP通俗理解 AOP 的好处: 1）每个事物逻辑位于一个位置, 代码不分散, 便于维护和升级； 2）业务模块更简洁, 只包含核心业务代码； 两种动态代理（JDK动态代理和CGLIB动态代理）区别： 1）前一种兄弟模式，spring会使用JDK的java.lang.reflect.Proxy类，它允许Spring动态生成一个新类来实现必要的接口，织入通知，并且把对这些接口的任何调用都转发到目标类。 2）后一种父子模式，spring使用CGLIB库生成目标类的一个子类，在创建这个子类的时候，spring织入通知，并且把对这个子类的调用委托到目标类。 相比之下，还是兄弟模式好些，他能更好的实现松耦合，尤其在今天都高喊着面向接口编程的情况下，父子模式只是在没有实现接口的时候，也能织入通知，应当做一种例外。 Spring事务管理事务管理是企业级应用程序开发中必不可少的技术,用来确保数据的完整性和一致性。 事务就是一系列的动作, 它们被当做一个单独的工作单元. 这些动作要么全部完成, 要么全部不起作用。 事务的四个关键属性(ACID)： 1. 原子性(atomicity)： 事务是一个原子操作, 由一系列动作组成. 事务的原子性确保动作要么全部完成要么完全不起作用。 2. 一致性(consistency)： 一旦所有事务动作完成, 事务就被提交。数据和资源就处于一种满足业务规则的一致性状态中。 3. 隔离性(isolation)： 可能有许多事务会同时处理相同的数据, 因此每个事物都应该与其他事务隔离开来, 防止数据损坏。 4. 持久性(durability)： 一旦事务完成, 无论发生什么系统错误, 它的结果都不应该受到影响. 通常情况下, 事务的结果被写到持久化存储器中。 Spring 支持编程式事务管理，也支持声明式事务管理： 1. 编程式事务管理: 将事务管理代码嵌入到业务方法中来控制事务的提交和回滚。在编程式管理事务时, 必须在每个事务操作中包含额外的事务管理代码。 2. 声明式事务管理: 大多数情况下比编程式事务管理更好用。它将事务管理代码从业务方法中分离出来, 以声明的方式来实现事务管理。事务管理作为一种横切关注点, 可以通过 AOP 方法模块化。Spring 通过 Spring AOP 框架支持声明式事务管理。 ###并发事务所导致的问题： 参考博客： 数据库事务隔离级别–脏读、不可重复读、幻读（清晰解释） 数据事务四种隔离机制和七种传播行为代码示例 1）脏读： 脏读就是指当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据，之后如果未提交的事务回滚了，则事务读取的数据就是无效的。 2）不可重复读： 是指在一个事务内，多次读同一数据。在这个事务还没有结束时，另外一个事务也访问该同一数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改，那么第一个事务两次读到的的数据可能是不一样的。这样就发生了在一个事务内两次读到的数据是不一样的，因此称为是不可重复读。（即不能读到相同的数据内容）。 例如，一个编辑人员两次读取同一文档，但在两次读取之间，作者重写了该文档。当编辑人员第二次读取文档时，文档已更改。原始读取不可重复。如果只有在作者全部完成编写后编辑人员才可以读取文档，则可以避免该问题。 3）幻读： 是指当事务不是独立执行时发生的一种现象，例如第一个事务对一个表中的数据进行了修改，这种修改涉及到表中的全部数据行。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入一行新数据。那么，以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行，就好象发生了幻觉一样。 例如，一个编辑人员更改作者提交的文档，但当生产部门将其更改内容合并到该文档的主复本时，发现作者已将未编辑的新材料添加到该文档中。如果在编辑人员和生产部门完成对原始文档的处理之前，任何人都不能将新材料添加到文档中，则可以避免该问题。 ###事务隔离级别 从理论上来说, 事务应该彼此完全隔离, 以避免并发事务所导致的问题。然而, 那样会对性能产生极大的影响, 因为事务必须按顺序运行。在实际开发中, 为了提升性能, 事务会以较低的隔离级别运行。 Oracle Sql Server默认隔离级别：Read committed Mysql默认隔离级别：Repeatable read ###事务传播属性： 当事务方法被另一个事务方法调用时, 必须指定事务应该如何传播。例如: 方法可能继续在现有事务中运行, 也可能开启一个新事务, 并在自己的事务中运行。 Spring 有7种，常用如下两种： REQUIRED: 如果有事务在运行，当前方法就在这个事务内运行，否则，就启动一个新的事务，并在自己的事务内运行。 REQUIRED_NEW：当前方法必须启动新事务，并在它自己的事务内运行。如果有事务正在运行，应该将它挂起。 ###面试题目：Spring是如何控制事务的？ Spring的事务，可以说是 Spring AOP 的一种实现。 AOP面向切面编程，即在不修改源代码的情况下，对原有功能进行扩展，通过代理类来对具体类进行操作。 spring是一个容器，通过spring这个容器来对对象进行管理，根据配置文件来实现spring对对象的管理。 spring的事务声明有两种方式，编程式和声明式。spring主要是通过“声明式事务”的方式对事务进行管理，即在配置文件中进行声明，通过AOP将事务切面切入程序，最大的好处是大大减少了代码量。]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringMVC框架基础知识]]></title>
    <url>%2F2018%2F04%2F25%2FSpringMVC%E6%A1%86%E6%9E%B6%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[SpringMVC运行流程 1）用户发送请求至前端控制器DispatcherServlet。 2）DispatcherServlet收到请求调用HandlerMapping处理器映射器。 3）处理器映射器找到具体的处理器，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet。 4）DispatcherServlet调用HandlerAdapter处理器适配器。 5）HandlerAdapter经过适配调用具体的处理器(Controller，也叫后端控制器)。 6）Controller执行完成返回ModelAndView。 7）HandlerAdapter将controller执行结果ModelAndView返回给DispatcherServlet。 8）DispatcherServlet将ModelAndView传给ViewReslover视图解析器。 9）ViewReslover解析后返回具体View。 10）DispatcherServlet根据View进行渲染视图（即将模型数据填充至视图中）。 11）DispatcherServlet响应用户。 说明： Handler: 也就是处理器，直接对应着MVC中的C也就是控制层。SpringMVC中用@RequestMapping标注的方法都可以看成一个Handler。也就是只要可以实际处理的请求就是Handleer。 HandlerMapping: 用来查找Handler。 HandlerAdapter: 适配器。因为SpringMVC中的Handler可以是任意形式，只要能处理请求就可以，但是Servlet需要的处理方法的结构是固定的，都是用request和response为参数的方法（比如doService方法）。如何让固定的Servlet处理方法调用灵活的Handler来进行处理？这就是HandlerAdapter所做的事情。 View: 用来展示数据。 ViewResolver: 用来查找View。]]></content>
      <categories>
        <category>springmvc</category>
      </categories>
      <tags>
        <tag>springMvc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mybatis框架面试题]]></title>
    <url>%2F2018%2F04%2F25%2Fmybatis%E6%A1%86%E6%9E%B6%E9%9D%A2%E8%AF%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[参考博客：Mybatis常见面试题 对于简单语句来说，使用注解代码会更加清晰，然而Java注解对于复杂语句来说就会混乱，应该限制使用。因此，如果你不得不做复杂的事情，那么最好使用XML来映射语句。 持久是相对于瞬时来说的，其实就是可以把数据固化在硬盘或者磁带一类可以保存很长时间的设备上，不像放在内存中一样断电就消失了。企业应用中数据很重要(各种订单数据、客户数据、库存数据之类的)，比应用程序本身更重要，所以需要把数据持久化。持久化可以通过很多方式，写文件和数据库都可以。只是现在企业一般都会选择把数据持久化到数据库中，因为可以很方便的查询统计分析，但数据库的数据最终还是会写到磁盘上的。 #、$区别参考博客：#、$区别 答：\${}是Properties文件中的变量占位符，它可以用于标签属性值和sql内部，属于静态文本替换，比如${driver}会被静态替换为com.mysql.jdbc.Driver。#{}是sql的参数占位符，Mybatis会将sql中的#{}替换为?号，在sql执行前会使用PreparedStatement的参数设置方法，按序给sql的?号占位符设置参数值，比如ps.setInt(0, parameterValue)，#{item.name}的取值方式为使用反射从参数对象中获取item对象的name属性值，相当于param.getItem().getName()。 Xml映射文件中，除了常见的select|insert|updae|delete标签之外，还有哪些标签？答：还有很多其他的标签：12345&lt;resultMap&gt;&lt;parameterMap&gt;&lt;sql&gt;&lt;include&gt;&lt;selectKey&gt; 加上动态sql的9个标签：1trim|where|set|foreach|if|choose|when|otherwise|bind 其中为sql片段标签，通过标签引入sql片段，为不支持自增的主键生成策略标签。 一级、二级缓存1）一级缓存: 基于 PerpetualCache 的 HashMap 本地缓存，其存储作用域为 Session，当 Session flush 或 close 之后，该 Session 中的所有 Cache 就将清空。 2）二级缓存与一级缓存其机制相同，默认也是采用 PerpetualCache，HashMap 存储，不同在于其存储作用域为 Mapper(Namespace)，并且可自定义存储源，如 Ehcache。要开启二级缓存，你需要在你的 SQL 映射文件中添加一行：1&lt;cache/&gt; 3）对于缓存数据更新机制，当某一个作用域(一级缓存 Session/二级缓存Namespaces)的进行了C/U/D 操作后，默认该作用域下所有 select 中的缓存将被 clear。]]></content>
      <categories>
        <category>mybatis</category>
      </categories>
      <tags>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[idea+springboot+freemarker热部署]]></title>
    <url>%2F2018%2F04%2F25%2Fidea-springboot-freemarker%E7%83%AD%E9%83%A8%E7%BD%B2%2F</url>
    <content type="text"><![CDATA[今天在学习springboot集成freemarker模板引擎修改代码时，发现每次修改一次freemarker文件时，都必须重启下应用，浏览器刷新才能显示修改后的内容，这样效率太低，每次启动一次应用都需要耗费大量时间。通过参考网上的资料终于解决了该问题，将部署步骤整理如下，方便后续参考。 第一步：在maven中加入devtools的依赖（这里我使用的是maven来管理项目） 第二步：在application.properties中设置禁用模板引擎缓存 12spring.freemarker.cache=falsespring.freemarker.settings.template_update_delay=0 第三步：修改IDEA的设置 打开 Settings –&gt; Build-Execution-Deployment –&gt; Compiler，将 Build project automatically.勾上。 点击 Help –&gt; Find Action..，或使用快捷键 Ctrl+Shift+A来打开 Registry…，将其中的compiler.automake.allow.when.app.running勾上。 全部设置完毕，重启一下IDEA。现在你就不必每次都手动的去点停止和启动了。]]></content>
      <categories>
        <category>技巧</category>
      </categories>
      <tags>
        <tag>springboot</tag>
        <tag>freemarker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql语句执行顺序]]></title>
    <url>%2F2018%2F04%2F25%2Fmysql%E8%AF%AD%E5%8F%A5%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[MySQL的语句一共分为11步，如下图所标注的那样，最先执行的总是FROM操作，最后执行的是LIMIT操作。其中每一个操作都会产生一张虚拟的表，这个虚拟的表作为一个处理的输入，只是这些虚拟的表对用户来说是透明的，但是只有最后一个虚拟的表才会被作为结果返回。如果没有在语句中指定某一个子句，那么将会跳过相应的步骤。 下面我们来具体分析一下查询处理的每一个阶段： （1）FORM: 对FROM的左边的表和右边的表计算笛卡尔积。产生虚表VT1。（选择相对小的表做基础表） （2）ON: 对虚表VT1进行ON筛选，只有那些符合的行才会被记录在虚表VT2中。 （3）JOIN： 如果指定了OUTER JOIN（比如left join、 right join），那么保留表中未匹配的行就会作为外部行添加到虚拟表VT2中，产生虚拟表VT3, 如果 from子句中包含两个以上的表的话，那么就会对上一个join连接产生的结果VT3和下一个表重复执行步骤1~3这三个步骤，一直到处理完所有的表为止。 （4）WHERE： 对虚拟表VT3进行WHERE条件过滤。只有符合的记录才会被插入到虚拟表VT4中。 （5）GROUP BY: 根据group by子句中的列，对VT4中的记录进行分组操作，产生VT5。 （6）CUBE | ROLLUP: 对表VT5进行cube或者rollup操作，产生表VT6。 （7）HAVING： 对虚拟表VT6应用having过滤，只有符合的记录才会被 插入到虚拟表VT7中。 （8）SELECT： 执行select操作，选择指定的列，插入到虚拟表VT8中。 （9）DISTINCT： 对VT8中的记录进行去重。产生虚拟表VT9. （10）ORDER BY: 将虚拟表VT9中的记录按照&lt;order_by_list&gt;进行排序操作，产生虚拟表VT10. （11）LIMIT：取出指定行的记录，产生虚拟表VT11, 并将结果返回。 有几个问题需要特别留意下： 1）对于包含outer join子句的查询，就有一个让人感到困惑的问题，到底在on筛选器还是用where筛选器指定逻辑表达式呢？ on和where的最大区别在于，如果在on应用逻辑表达式中，那么在第三步outer join中还可以把移除的行再次添加回来，而where的移除后得到的是最终结果。 举个简单的例子，有一个学生表（班级,姓名）和一个成绩表(姓名,成绩)，我现在需要返回一个x班级的全体同学的成绩，但是这个班级有几个学生缺考，也就是说在成绩表中没有记录。为了得到我们预期的结果我们就需要在on子句指定学生和成绩表的关系（学生.姓名=成绩.姓名）那么我们是否发现在执行第二步的时候，对于没有参加考试的学生记录就不会出现在vt2中，因为他们被on的逻辑表达式过滤掉了，但是我们用left outer join就可以把左表（学生）中没有参加考试的学生找回来，因为我们想返回的是x班级的所有学生，如果在on中应用学生.班级=’x’的话，left outer join会把所有班级的所有学生记录找回，所以只能在where筛选器中应用学生.班级=’x’ 因为它的过滤是最终的。 2）GROUP BY语句和DISTINCT语句不能同时用在同一个字段上！！！ 事实上如果应用了group by子句那么distinct是多余的，原因同样在于，分组的时候是将列中唯一的值分成一组，同时只为每一组返回一行记录，那么所以的记录都将是不相同的。]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git命令]]></title>
    <url>%2F2018%2F04%2F25%2Fgit%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[1. 将当前目录设置成一个Git仓库1234//进入需要创建Git仓库的目录，然后输入命令，则当前目录就被设置成了一个Git仓库，默认会自动生成一个.git文件夹git init //在创建项目时就将项目目录设置成一个Git仓库git init projectName 2. 将项目提交到本地仓库123456//将修改文件提交到暂存区的持久化容器中,可以同时提交多个文件git add fileName1 fileName2//将代码提交的Git仓库中，每次提交最好都加上后面的描述信息git commit -m &quot;description&quot;//查看git代码提交状态git status 3. 查看修改内容工作区和暂存区详细介绍 HEAD ———-&gt; commit版本 Index ———-&gt; staged版本(暂存区) 123456789//比较的是工作目录(Working tree)和暂存区域快照(index)之间的差异也就是修改之后还没有暂存起来的变化内容git diff//查看已经暂存起来的文件(staged)和上次提交时的快照之间(HEAD)的差异git diff --cachedgit diff --staged//显示工作区版本(Working tree)和HEAD的差别git diff HEAD//查看简化的diff结果，可以加上--stat参数git diff --stat 4. 查看git日志123456789101112//按照时间倒叙排列提交日志git log//显示提交信息的简单版本git log --oneline//可以显示每次提交包含的文件git log --stat//显示每次提交之间哪些内容改变git log --patch//查看分支合并图git log --graph//查询自己所有的操作以及对应版本的commit idgit reflog 5. 版本回退1234//回退到上一个版本，上一个版本就是HEAD^，上上一个版本就是HEAD^^，往上n个版本写n个^比较容易数不过来，所以写成HEAD~ngit reset --hard HEAD^//回退到之前的某个版本，commit_id可以通过git log命令得到,若要回到未来版本，需要用git reflog来得到commit_idgit reset --hard commit_id 6. 撤销修改123456789//场景1：当改乱了工作区某个文件的内容，想直接丢弃工作区的修改时git checkout --fileName//场景2：不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改//先回到场景1git reset HEAD fileNamegit checkout --fileName场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，可以使用版本回退命令，不过前提是没有推送到远程库。 7. 删除文件12345//将文件从版本库中删除，同时提交修改git rm fileNamegit commit -m &quot;remove test.txt&quot;//如果文件已经提交到版本库并且被误删了，还可以使用如下命令还原git checkout --fileName 8. 添加远程仓库1234//关联一个远程库git remote add origin git@server-name:path/repo-name.git//第一次推送master分支的所有内容，第一次推送需要-u选项git push -u origin master 9. 从远程仓库克隆12//后面填写需要克隆仓库的地址git clone git@github.com:michaelliao/gitskills.git 10. 创建与合并分支创建与合并分支详解123456789101112//查看分支git branch//创建分支(&lt;name&gt;为分支名)git branch &lt;name&gt;//切换分支git checkout &lt;name&gt;//创建+切换分支git checkout -b &lt;name&gt;//合并某分支到当前分支git merge &lt;name&gt;//删除分支git branch -d &lt;name&gt; 当多个分支同时修改了同一个文件时候，需要解决分支冲突，分支冲突通常需要手动解决。解决分支冲突详解 11. 分支管理策略在实际开发中，应该按照几个基本原则进行分支管理： 首先，master分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活； 那在哪干活呢？干活都在dev分支上，也就是说，dev分支是不稳定的，到某个时候，比如1.0版本发布时，再把dev分支合并到master上，在master分支发布1.0版本； 你和你的小伙伴们每个人都在dev分支上干活，每个人都有自己的分支，时不时地往dev分支上合并就可以了。 所以，团队合作的分支看起来就像这样： 12. BUG分支参考：BUG分支 13. 多人合作实际工作中的情况：多人合作详解]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux常用命令]]></title>
    <url>%2F2018%2F04%2F24%2FLinux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[竖杠 |管道就像水管一样，将前面命令的执行结果输送给后面的命令。 123//&apos;ls -l&apos;负责收集当前目录下的文件信息，然后将这些文件名作为结果输送到管道，//wc这个命令接着就从管道中把它们读取出来，并计算出行数，单词个数和总字符数。ls -l | wc 查看日志命令(tail)tail的功能就是输出文件的尾部内容。 Linux文件的日志文件通常存储在’/var/log’目录下。 123456//输出syslog文件的尾部几行tail /var/log/syslog//tail会继续监视日志文件，输出写入到文件的下一行。这意味着你可以在终端窗口里面实时关注什么写入到syslogtail -f /var/log/syslog//只想查看写入到syslog的尾部5行tail -f -n 5 /var/log/syslog CPU相关命令ps：查看当前瞬间系统的进程信息 pstree：以树状方式查看当前系统的进程 top：持续跟踪系统的进程情况1234//动态跟踪所有进程（&lt;向左翻页，&gt;向右翻页）top//动态跟踪PID为1234的进程top -p 1234 kill：给一个指定的进程发送一个信号123456//列出当前系统所支持的所有信号kill -l//给PID为1234的进程发送9号信号kill -9 1234 //给PID为1234的进程发送SIGINT信号kill -s SIGINT 1234 nice：以某一个指定的NICE值启动进程12//以NICE值为5的起始状态来启动程序./examplenice -n 5 ./example renice：动态修改一个进程的NICE值12//将PID为1234的进程的NICE值调整为15renice -n 15 1234 网络相关命令ifconfig：查看系统当前活跃的网络接口123456//查看系统当前所有的活跃的网络接口信息ifconfig //查看eth0相关的信息ifconfig eth0 //将网络接口eth0的IP地址设置为192.168.1.5ifconfig eth0 192.168.1.5 ping：给某主机发送ICMP数据包以检测网络 12//给百度服务器发送ICMP数据包以检测网络是否连通ping www.baidu.com netstat：查看系统网络连接的相关信息 123456//查看系统中所有状态的网络连接信息netstat -a//查看系统中处于监听状态的网络连接信息netstat -l//查看系统中所有状态的TCP（或者UDP 或者UNIX域）的网络连接信息netstat -at （或者 netstat -au 或者 netstat -ax） ifdown：禁用网络接口 12//禁用网络接口eth0ifdown eth0 ifup：启用网络接口 12//启用网络接口eth0ifup eth0 host：查看域名所对应的IP地址12//查看域名www.baidu.com所对应的IP地址，以此来检测本机的DNS服务设置正确与否host www.baidu.com route：查看、设置路由和网关相关信息 1234//查看网关地址route -n//添加默认网关为192.168.1.1route add default gw 192.168.1.1 ln：创建一个连接文件 1234//为文件file创建一个硬连接（别名）,叫file1ln file file1 //为文件file创建一个软连接，叫file2 ln -s file file2]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java IO 基础]]></title>
    <url>%2F2018%2F04%2F23%2Fjava-IO-%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[参考：Java IO技术博客 BIO（同步并阻塞） 字节输入流 字节输出流 字符输入流 字符输出流 抽象基类 InputStream OutputStream Reader Writer 访问文件 FileInputStream FileOutputStream FileReader FileWriter 访问数组 ByteArrayInputStream ByteArrayOutputStream CharArrayReader CharArrayWriter 缓冲流 BufferedInputStream BufferedOutputStream BufferedReader BufferedWriter 打印流 PrintStream PrintWriter 说明： 上面是一些比较常用的输入输出流，缓冲流可以一次处理一行文本，以换行符为标志，打印流的输出功能非常强大，方便处理打印操作。 注意： PrintWriter 的close()方法通常自带flush()。 使用场景： 输入输出内容为文本： 使用字符流 输入输出内容为二进制： 使用字节流 java使用处理流来包装节点流是一种典型的装饰器设计模式。 RandomAccessFile类说明： RandomAccessFile是java输入/输出流体系中功能最丰富的文件内容访问类，可以读取和向文件写入数据。 优点：支持“随机访问”，可以直接跳转到文件的任意位置读写数据。 （注意：在向文件指定位置插入内容时，会覆盖掉插入点之后原有的内容） 缺点：只能读写文件，不能读写其它IO节点。 使用场景： 1）只需要访问文件部分内容，而不是把文件从头读到尾。 2）向已存在的文件后面追加内容，而不是从文件开始的地方直接输出。 对象序列化说明：将实现序列化的Java对象转换成字节序列，这些字节序列可以保存在磁盘上，或者能够通过网络传输，方便以后重新再恢复成原来的对象。 注意：定义的类必须实现Serializable接口 NIO（同步非阻塞）（JDK1.4） 新IO采用了内存映射文件的方式来处理输入/输出，新IO将文件或文件的一段区域映射到内存中，这样就可以像访问内存一样来访问文件了（模拟了操作系统虚拟内存的概念），相比传统的输入/输出要快！ Channels and Buffers（通道和缓冲区）： 标准的IO基于字节流和字符流进行操作的，而NIO是基于通道（Channel）和缓冲区（Buffer）进行操作，数据总是从通道读取到缓冲区中，或者从缓冲区写入到通道中。 Selectors（选择器）： Java NIO引入了选择器的概念，选择器用于监听多个通道的事件（比如：连接打开，数据到达）。因此，单个的线程可以监听多个数据通道。 Asynchronous IO（异步IO）： Java NIO可以让你异步的使用IO，例如：当线程从通道读取数据到缓冲区时，线程还是可以进行其他事情。当数据被写入到缓冲区时，线程可以继续处理它。从缓冲区写入通道也类似。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java集合面试]]></title>
    <url>%2F2018%2F04%2F23%2Fjava%E9%9B%86%E5%90%88%E9%9D%A2%E8%AF%95%2F</url>
    <content type="text"><![CDATA[在Java集合框架源码中有如下几点说明： 1) 实现RandomAccess接口目的：说明支持快速访问，保证使用下标访问比用迭代器访问要快。否则，迭代器访问要快。 2) 实现Cloneable接口目的：保证对象能实现克隆。 3) AbstractList中的modCount变量（修改次数），通常会在迭代器中使用它，也就是说，在迭代器遍历的过程中，一旦发现这个对象的mcount和迭代器中存储的mcount不一样，那就抛异常。也就是Fail-Fast机制。对集合内容的修改都会改变modcount的值，那么在迭代器初始化过程中会将这个值赋给迭代器的expectedModCount。在迭代过程中，判断modCount跟expectedModCount是否相等，如果不相等就表示已经有其他线程修改了集合。 4) Fail-Fast VS Fail-Safe Fail-Safe（安全失败）：基于对底层集合做拷贝。因此，它不受源集合上修改的影响。java.util.concurrent包下面的所有的类都是安全失败的。 Fail-Fast（快速失败）：java.util包下面的所有的集合类都是快速失败的，快速失败的迭代器会抛出ConcurrentModificationException异常，而安全失败的迭代器永远不会抛出这样的异常。 List有序可重复集合 ArrayList底层实现： 基于动态数组 增：末尾添加元素，时间复杂度O(1); 任意位置添加元素，时间复杂度为O(N)。删：末尾删除元素，时间复杂度O(1); 任意位置删除元素，时间复杂度为O(N)。查：时间复杂度O(1)。 非线程安全（性能高） Vector功能基本同ArrayList。 线程安全（性能低） LinkedList底层实现： 双向链表 增：末尾添加元素，时间复杂度O(1); 任意位置添加元素，时间复杂度为O(N)。删：末尾删除元素，时间复杂度O(1); 任意位置删除元素，时间复杂度为O(N)。查：时间复杂度O(N)。 MapHashMap参考：HashMap源码解析ConcurrentHashMap源码解析 底层实现： 散列表+数组+链表+红黑树（JDK1.8增加了红黑树部分） 原理： 它根据键的hashCode值存储数据，大多数情况下可以直接定位到它的值，因而具有很快的访问速度，但遍历顺序却是不确定的。HashMap最多只允许一条记录的键为null，允许多条记录的值为null。 源码说明： HashMap在Map.Entry静态内部类实现中存储key-value对。HashMap使用哈希算法，在put和get方法中，它使用hashCode()和equals()方法。当我们通过传递key-value对调用put方法的时候，HashMap使用Key hashCode()和哈希算法来找出存储key-value对的索引。Entry存储在LinkedList中，所以如果存在entry，它使用equals()方法来检查传递的key是否已经存在，如果存在，它会覆盖value，如果不存在，它会创建一个新的entry然后保存。当我们通过传递key调用get方法时，它再次使用hashCode()来找到数组中的索引，然后使用equals()方法找出正确的Entry，然后返回它的值。下面的图片解释了详细内容。 其它关于HashMap比较重要的问题是容量、负荷系数和阀值调整。HashMap默认的初始容量是32，负荷系数是0.75。阀值是为负荷系数乘以容量，无论何时我们尝试添加一个entry，如果map的大小比阀值大的时候，HashMap会对map的内容进行重新哈希，且使用更大的容量。容量总是2的幂，所以如果你知道你需要存储大量的key-value对，比如缓存从数据库里面拉取的数据，使用正确的容量和负荷系数对HashMap进行初始化是个不错的做法。 线程安全： HashMap非线程安全，即任一时刻可以有多个线程同时写HashMap，可能会导致数据的不一致。如果需要满足线程安全，可以用Collections的synchronizedMap方法使HashMap具有线程安全的能力，或者使用ConcurrentHashMap。 对比Hashtable： Hashtable是遗留类，很多映射的常用功能与HashMap类似，不同的是它承自Dictionary类，并且是线程安全的，任一时间只有一个线程能写Hashtable，并发性不如ConcurrentHashMap，因为ConcurrentHashMap引入了分段锁。Hashtable不建议在新代码中使用，不需要线程安全的场合可以用HashMap替换，需要线程安全的场合可以用ConcurrentHashMap替换。（不允许键或值为空） weakHashMap用法基本同HashMap。 区别：HashMap中的key保留了对实际对象的强引用，只要该HashMap对象不被销毁，该HashMap的所有key所引用的对象就不会被垃圾回收。 WeakHashMap中的key只保留了对于实际对象的弱引用，如果WeakHashMap对象的key所引用的对象没有被其他强引用变量所引用，则这些key所引用的对象可能被垃圾回收。 LinkedHashMap参考：LinkedHashMap源码详解 底层实现： 散列表+数组+双向循环链表 说明： LinkedHashMap是HashMap的子类，实现的原理跟HashMap差不多，唯一的区别就是LinkedHashMap多了一个双向循环链表。因为有双向循环列表，所以LinkedHashMap能够记录插入元素的顺序，而HashMap不能，可以根据元素的插入顺序和访问顺序来遍历集合。 TreeMap参考：TreeMap源码详解 底层实现： 散列表+红黑树 说明： TreeMap存储key-value节点对时，需要根据key对节点进行排序。它能保证所有的key-value对处于一种有序的状态。 TreeMap有两种排序方式，自然排序和定制排序。 自然排序：TreeMap所有key必须实现Comparable接口。 定制排序：创建TreeMap时，传入一个Comparator对象，该对象负责对TreeMap中的所有key进行排序。使用定制排序的时候不需要Map的key来实现Comparable接口。 适用场景： 添加，查询元素：HashMap性能较好。(TreeMap需要红黑树算法来维护集合元素次序，性能低). 保存排序的集合：TreeMap. 遍历集合：LinkedHashMap. Set相当于一个罐子，不允许包含重复元素 HashSet参考： LinkedHashSet的实现原理 底层实现： 基于HashMap实现。在它里面放置的元素对应到map里面的key部分，而在map中与key对应的value用一个固定Object()对象保存。 LinkedHashSet说明： 会根据元素的插入顺序来访问集合中的元素。 底层实现： 它继承于HashSet，又基于LinkedHashMap来实现的。 TreeSet说明： 确保集合处于排序状态。 底层实现： TreeSet实际上是TreeMap实现的。 当构造TreeSet时；若使用不带参数的构造函数，则TreeSet的使用自然比较器；若用户需要使用自定义的比较器，则需要使用带比较器的参数。 适用场景： 添加，查询元素：HashSet性能较好。(TreeSet需要红黑树算法来维护集合元素次序，性能低). 保存排序的集合：TreeSet. 遍历集合：LinkedHashSet.]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java基础面试总结]]></title>
    <url>%2F2018%2F04%2F22%2Fjava%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[面向对象的三大特性1) 封装，也就是把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。 2) 继承，是指可以让某个类型的对象获得另一个类型的对象的属性和方法。 3) 多态，是指一个类实例的相同方法在不同情形有不同表现形式。 重载重写1） 重载是在同一个类中的两个或两个以上的方法，拥有相同的方法名，但是参数却不相同，方法体也不相同，最常见的重载的例子就是类的构造函数。 两同一不同原则： 两同：同一个类，方法名相同；不同：参数列表不同； 注意：方法的其它部分，比如方法的返回值类型、方法修饰符等都与方法重载没有任何关系。 2） 重写是子类的方法覆盖父类的方法，要求方法名和参数都相同。 两同两小一大原则： 两同：方法名相同、形参列表相同；两小：子类方法返回值类型小于父类方法返回值类型或相等；子类方法声明抛出的异常类型应比父类方法声明抛出的异常类型更小或相等。一大：子类方法的访问权限要大于等于父类方法的访问权限。 注意： private修饰的相同方法不是被重写了，而是另一个重新定义的方法，因为private只对当前类可见。 常用Object类的方法equals()方法== 运算符 对于基本类型变量，如果两者数值相同，则返回true。对于引用类型变量，只有两者指向同一个对象，才返回true。 Object默认提供的功能只是比较两个对象的地址是否相同。通常需要重载equals()方法。 例如：在String类中就重载了equals()方法，用来判断String对象包含的字符序列是否相同。 12345678910111213141516171819//比较严谨的重载equals()方法的实例如下public boolean equals(Object obj) &#123; //如果两个对象为同一个对象 if (this == obj) &#123; return true; &#125; //getClass()获得的是对象的运行时类型 if (obj != null &amp;&amp; obj.getClass() == Person.class) &#123; Person personObj = (Person)obj; //并且当前对象的idStr 与 obj对象的idStr 相等的时候才可以判断两个对象是相等的 if (this.getIdStr().equals(personObj.getIdStr()) &#123; return true; &#125; &#125; return false;&#125; toString()方法通常在打印对象信息时会使用到toString()方法，比如：12345System.out.println(p);//等价于//输出：Person@15db9742//打印格式为：类名+@+hashCodeSystem.out.println(p.toString); 通常需要重写toString()方法，该方法总是会返回该对象的所有令人感兴趣的信息所组成的字符串，可以返回如下格式的字符串：1类名[field1=值1, field2=值2,...] hashCode()方法 hashCode()方法主要在集合中才会用到。 将对象放入集合中的步骤： 1) 首先判断要放入对象的hashcode值与集合中的任意一个元素的hashcode值是否相等，如果不相等直接将该对象放入集合中。 2) 如果hashcode值相等，然后再通过equals方法判断要放入对象与集合中的任意一个对象是否相等，如果equals判断不相等，直接将该元素放入到集合中，否则不放入。 参考：hashCode与equals的区别与联系 finalize()方法 在垃圾回收机制回收某个对象占用的内存之前，需要程序调用一定的方法来清理资源。而java提供了默认的机制来清理该对象的资源，该机制就是finalize()方法。 注意： 垃圾回收机制什么时候调用对象的finalize()方法是完全透明的，只有当程序认为需要更多的额外内存空间时，它才能够进行垃圾回收的工作。也就是说finalize()方法是在垃圾回收之前执行的。 比如： 当一个对象虽然失去了引用，但是只占用了少量的内存资源，而且系统没有很严重的内存需求，此时，垃圾回收机制没有试图去回收对象所占用的资源，这样对象的finalize()方法是不会被调用的。 finalize()方法4个特点：1) 永远不要主动调用某个对象的finalize()方法，该方法应交给垃圾回收机制调用。 2) finalize()方法何时被调用，是否被调用具有不确定性，不要把finalize()方法当成一定会被执行的方法。 3) 当JVM执行可恢复对象的finalize()方法时，可能使该对象或系统中其他对象重新变成可达状态。 4) 当JVM执行finalize()方法时出现异常时，垃圾回收机制不会报告异常，程序继续执行。 getClass()方法 返回当前对象所属类对应的CLASS对象(具体方法查看API); clone()方法 用来帮助其他对象来实现“自我克隆”，也就是得到一个当前对象的副本，而且两者完全隔离。Object类提供的clone()方法使用了protected修饰符，该方法只能够被子类重写或调用。 注意： Object类中提供的Clone机制只可以对对象里面的各实例变量进行“简单复制”，如果实例变量的类型为引用类型，Object的Clone机制也只能够简单地复制这个引用变量。 参考：Java疯狂讲义 P247页 类访问权限 修饰词 本类 同一个包的类 继承类 其他类 private √ × × × 无（默认） √ √ × × protected √ √ √ × public √ √ √ √ String、stringbuffer、stringbuilder 联系、区别、源码String：字符串常量 StringBuffer：字符串变量（线程安全） StringBuilder：字符串变量（线程非安全） 三者在执行速度方面的比较：StringBuilder &gt; StringBuffer &gt; String 使用场景： 1) 如果要操作少量的数据用 = String 2) 单线程操作字符串缓冲区下操作大量数据 = StringBuilder 3) 多线程操作字符串缓冲区下操作大量数据 = StringBuffer 为什么线程安全比非线程安全性能低？ 1) 线程的安全是以牺牲性能为代价的，所谓线程安全就是多了个加锁，解锁的操作，比如100亿个操作中都要加锁和解锁，线程是安全了，但性能就下降了。 2) 有些软件是以性能为主的，为了提高性能，就少了加锁，解锁的操作，虽然容易出现并发性问题，但性能却提高了。 final修饰符 final修饰的变量不可改变。 final修饰成员变量说明：final修饰的成员变量必须由程序员显示地指定初始值。 类变量：必须在静态初始化块中指定初始值或声明该类变量时指定初始值，而且只能在两个地方的其中之一指定。 实例变量：必须在非静态初始化块、声明该变量或构造器中指定初始值，而且只能在三个地方的其中之一指定。 final修饰局部变量final修饰局部变量在定义时没有指定默认值，可以在后面代码中对该final变量赋初始值，但是只能一次，不可重复赋值。 final修饰的形参不能在方法体内赋值，因为形参在调用该方法时，是由系统根据传入的参数来完成初始化的。 final修饰基本类型变量和引用类型变量final修饰基本类型变量时，不可以对基本类型变量重新赋值，因此基本类型变量不能被改变。 final修饰引用类型变量时，只保证该引用类型变量所引用的地址不会改变，即一直引用同一个对象，但这个对象完全可以发生改变。 final修饰的方法final修饰的方法不能被重写，并不是不能被重载。（例如Object类中的getClass()方法就是一个final方法） final修饰类final修饰的类不可以有子类 immutable不可变类：当你获得这个类的一个实例引用时，你不可以改变这个实例的内容。不可变类的实例一但创建，其内在成员变量的值就不能被修改。 抽象类和接口的联系区别共同点： 1） 接口和抽象类都不能被实例化，它们都在继承树的顶端，用来被其他类实现和继承。 2） 接口和抽象类都可以包含抽象方法，实现接口或继承抽象类的普通子类都必须实现这些抽象方法。 设计目的： 接口主要体现一种规范，它类似于整个系统的“总纲”，它制定了系统各模块应该遵循的标准，因此一个系统中的接口不应该经常改变。 抽象类主要体现了一种模板式设计。可以认为是系统实现过程当中的中间产品。它已经实现了系统的部分功能（哪些已经提供实现的方法） 区别： 1）接口中只能包含抽象方法、静态方法和默认方法，不能为普通方法提供方法的实现；而抽象类则完全可以包含普通方法。 2）接口中只能定义静态常量，不能定义普通成员变量；抽象类里则可以定义普通成员变量，也可以定义静态常量。 3）接口里不包含构造器；抽象类里可以包含构造器；但是抽象类中的构造器不是用来创建对象，而是让其子类调用这些构造器来完成属于抽象类的初始化操作。 4）接口中不可以包含初始化块；但是抽象类中可以包含初始化块。 5）一个类最多只能有一个直接父类，包括抽象类；但一个类可以直接实现多个接口，通过实现多个接口可以弥补java单继承的不足。 什么时候用接口什么时候用抽象类？ 抽象类都是从一些相似的对象中抽象出来的一个相对无法具体描述的一个类，它的子类之间是有相似性的； 接口更侧重于对相同的动作进行抽象封装。当你关注一个事物的本质的时候，用抽象类；当你关注一个操作的时候，用接口。 对象的初始化过程1）初始化父类中的静态成员变量和静态代码块； 2）初始化子类中的静态成员变量和静态代码块； 3）初始化父类的普通成员变量和代码块，再执行父类的构造方法； 4）初始化子类的普通成员变量和代码块，再执行子类的构造方法； static修饰符static修饰变量1）对于静态变量在内存中只有一个拷贝（节省内存），JVM只为静态分配一次内存。 2）对于实例变量，每创建一个实例，就会为实例变量分配一次内存，实例变量可以在内存中有多个拷贝，互不影响（灵活）。 static方法静态方法中不能访问非静态成员方法和非静态成员变量，但是在非静态成员方法中是可以访问静态成员方法和变量的 static代码块static代码块是在类中独立于类成员的static语句块，可以有多个，位置可以随便放，它不在任何的方法体内，JVM加载类时会执行这些静态的代码块，如果static代码块有多个，JVM将按照它们在类中出现的先后顺序依次执行它们，每个代码块只会被执行一次。 关键的作用：用来形成静态代码块以优化程序性能。因为它只会在类加载的时候执行一次，所以能优化程序性能。 instanceof运算符编译时类型必须是如下3种情况： 1）要么与后面的类相同；2）要么是后面类型的父类；3）要么是后面类型的子类； 如果前面操作数的编译时类型与后面的类型没有任何关系，程序将没发通过编译。 运行阶段： 被转型变量所引用对象的实际类型必须是目标类型的实例，或者是目标类型的子类，实现类的实例，否则在运行时将引发ClassCastException异常。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>面试</tag>
      </tags>
  </entry>
</search>
