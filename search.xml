<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[HashMap源码解析]]></title>
    <url>%2F2018%2F07%2F15%2FHashMap%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[对于HashMap需要掌握以下几点 Map的创建：HashMap() 往Map中添加键值对：即put(Object key, Object value)方法 获取Map中的单个对象：即get(Object key)方法 下面结合源码看看hashmap的原理： 构建HashMap源码中关键的一些属性： 12345678910111213141516// 默认的初始化容量（必须是2的次方） java8中都改成了位运算，提高运算效率static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // 最大指定容量为2的30次方static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30; // 默认的加载因子（用于resize）static final float DEFAULT_LOAD_FACTOR = 0.75f; // Node数组（数组容量必须是2的多少次方，若不足必要会扩容resize）--这就是HashMap的底层数据结构transient Node&lt;K,V&gt;[] table;// 该map中存放的key-value对个数，该个数决定了数组的扩容（而非table中的所占用的桶的个数来决定是否扩容）transient int size; // 扩容resize的条件:eg.capacity=16,load_factor=0.75,threshold=capacity*load_factor=12,即当该map中存放的key-value对个数size&gt;=12时，就resize）int threshold; // 负载因子（用于resize）final float loadFactor; // 标志位，用于标识并发问题，主要用于迭代的快速失败（在迭代过程中，如果发生了put（添加而不是更新的时候）、remove操作，该值发生变化，快速失败）transient volatile int modCount; 注意： map中存放的key-value对个数size，该个数决定了数组的扩容（size&gt;=threshold时，扩容），而非table中的所占用的桶的个数来决定是否扩容 标志位modCount采用volatile实现该变量的线程可见性（之后会在”Java并发”章节中去讲） 数组中的桶，指的就是table[i] threshold默认为0.75，这是综合时间和空间的利用率来考虑的，通常不要变，如果该值过大，可能会造成链表太长，导致get、put等操作缓慢；如果太小，空间利用率不足。 容量（必须是2的次方）是为了方便后面定位hash桶的位置的时候进行取模运算 无参构造器（也是当下最常用的构造器） 123456/** * 构造一个空的hashMap，设置默认初始化容量为16和默认负载因子为0.75 */public HashMap() &#123; this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted&#125; 对于hashmap而言，还有两个比较常用的构造器，一个双参，一个单参。 1234567891011121314151617181920212223242526272829303132public HashMap(int initialCapacity, float loadFactor) &#123; // 一些边界条件判断 if (initialCapacity &lt; 0) throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; + initialCapacity); if (initialCapacity &gt; MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY; if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new IllegalArgumentException(&quot;Illegal load factor: &quot; + loadFactor); this.loadFactor = loadFactor; this.threshold = tableSizeFor(initialCapacity);&#125;// 获取cap的下一个2的n次幂的数（这个算法有兴趣可以研究下，涉及到位运算的一些技巧）static final int tableSizeFor(int cap) &#123; int n = cap - 1; n |= n &gt;&gt;&gt; 1; n |= n &gt;&gt;&gt; 2; n |= n &gt;&gt;&gt; 4; n |= n &gt;&gt;&gt; 8; n |= n &gt;&gt;&gt; 16; return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;&#125;/** * 指定初始容量 */public HashMap(int initialCapacity) &#123; // 会调用上边的双参构造器 this(initialCapacity, DEFAULT_LOAD_FACTOR);&#125; 注意： 利用上述两个构造器构造出的数组容量不一定是指定的初始化容量，而是一个刚刚大于指定初始化容量的2的几次方的一个值。 在实际使用中，若我们能预判所要存储的元素的多少，最好使用上述的单参构造器来指定初始容量，这样的话，就可以避免就来扩容时带来的消耗（这一点与ArrayList一样）。 table的初始化是在resize中进行的，这个和java7中的初始化逻辑不一样。后面会具体说。 从结构实现来讲，HashMap是数组+链表+红黑树（JDK1.8增加了红黑树部分）实现的，如下如所示： HashMap的底层数据结构是一个Node[]，Node是HashMap的一个内部类，源代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final int hash; final K key; V value; // 该Node的下一个Node（hash冲突时，形成链表） Node&lt;K,V&gt; next; Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123; this.hash = hash; this.key = key; this.value = value; this.next = next; &#125; public final K getKey() &#123; return key; &#125; public final V getValue() &#123; return value; &#125; public final String toString() &#123; return key + &quot;=&quot; + value; &#125; public final int hashCode() &#123; return Objects.hashCode(key) ^ Objects.hashCode(value); &#125; public final V setValue(V newValue) &#123; V oldValue = value; value = newValue; return oldValue; &#125; public final boolean equals(Object o) &#123; if (o == this) return true; if (o instanceof Map.Entry) &#123; Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o; if (Objects.equals(key, e.getKey()) &amp;&amp; Objects.equals(value, e.getValue())) return true; &#125; return false; &#125;&#125;// 在hashmap中可以存放null键和null值public static boolean equals(Object a, Object b) &#123; return (a == b) || (a != null &amp;&amp; a.equals(b));&#125; 注意： Node是一个节点，在其中还保存了下一个Node的引用（用来解决put时的hash冲突问题），这样的话，我们可以把hashmap看作是”一个链表数组” Node类中的equals()方法会在get(Object key)中使用 put(Object key, Object value)put流程图： 判断键值对数组table[i]是否为空或为null，否则执行resize()进行扩容； 根据键值key计算hash值得到插入的数组索引i，如果table[i]==null，直接新建节点添加，转向6，如果table[i]不为空，转向3； 判断table[i]的首个元素是否和key一样，如果相同直接覆盖value，否则转向4，这里的相同指的是hashCode以及equals； 判断table[i] 是否为treeNode，即table[i] 是否是红黑树，如果是红黑树，则直接在树中插入键值对，否则转向5； 遍历table[i]，判断链表长度是否大于8，大于8的话把链表转换为红黑树，在红黑树中执行插入操作，否则进行链表的插入操作；遍历过程中若发现key已经存在直接覆盖value即可； 插入成功后，判断实际存在的键值对数量size是否超多了最大容量threshold，如果超过，进行扩容。 源代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public V put(K key, V value) &#123; // 对key的hashCode()做hash return putVal(hash(key), key, value, false, true); &#125; final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; // 步骤1：tab为空则创建 if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; // 步骤2：计算index，并对null做处理 if ((p = tab[i = (n - 1) &amp; hash]) == null) tab[i] = newNode(hash, key, value, null); else &#123; Node&lt;K,V&gt; e; K k; // 步骤3：节点key存在，直接覆盖value if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; // 步骤4：判断该链为红黑树 else if (p instanceof TreeNode) e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); // 步骤5：该链为链表 else &#123; for (int binCount = 0; ; ++binCount) &#123; // 如果没找到则将节点添加到链表最后面 if ((e = p.next) == null) &#123; p.next = newNode(hash, key,value,null); //链表长度大于8转换为红黑树进行处理 if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; &#125; // key已经存在直接覆盖value if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; p = e; &#125; &#125; if (e != null) &#123; // existing mapping for key V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; &#125; &#125; ++modCount; // 步骤6：超过最大容量就扩容 if (++size &gt; threshold) resize(); afterNodeInsertion(evict); return null;&#125; hash运算：123456static final int hash(Object key) &#123; int h; // h = key.hashCode() 为第一步 取hashCode值 // h ^ (h &gt;&gt;&gt; 16) 为第二步 高位参与运算 return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);&#125; 在JDK1.8的实现中，优化了高位运算的算法，通过hashCode()的高16位异或低16位实现的：(h = k.hashCode()) ^ (h &gt;&gt;&gt; 16)，主要是从速度、功效、质量来考虑的，这么做可以在数组table的length比较小的时候，也能保证考虑到高低Bit都参与到Hash的计算中，同时不会有太大的开销。 说明：在上述的步骤1中判断tab为空时候，调用了扩容函数resize() 下面举个例子说明下扩容过程。假设了我们的hash算法就是简单的用key表示。其中的哈希桶数组table的size=2， 所以key = 3、7、5，put顺序依次为3、7、5 。在mod 2以后都冲突在table[1]这里了。这里假设负载因子 loadFactor=1，即当键值对的实际大小size 大于 table的实际大小时进行扩容。接下来的三个步骤是哈希桶数组 resize成4，然后所有的Node重新rehash的过程。 注意：java8在添加新节点到链表时候是使用的尾插，所以插入顺序和链表遍历顺序是一样的。而java7使用的是头插方式，插入顺序和链表遍历的顺序相反。 java8对扩容做了些优化。经过观测可以发现，我们使用的是2次幂的扩展(指长度扩为原来2倍)，所以，元素的位置要么是在原位置，要么是在原位置再移动2次幂的位置。看下图可以明白这句话的意思，n为table的长度，图（a）表示扩容前的key1和key2两种key确定索引位置的示例，图（b）表示扩容后key1和key2两种key确定索引位置的示例，其中hash1是key1对应的哈希与高位运算结果。 元素在重新计算hash之后，因为n变为2倍，那么n-1的mask范围在高位多1bit(红色)，因此新的index就会发生这样的变化： 因此，我们在扩充HashMap的时候，不需要像JDK1.7的实现那样重新计算hash，只需要看看原来的hash值新增的那个bit是1还是0就好了，是0的话索引没变，是1的话索引变成“原索引+oldCap”，可以看看下图为16扩充为32的resize示意图： 这个设计确实非常的巧妙，既省去了重新计算hash值的时间，而且同时，由于新增的1bit是0还是1可以认为是随机的，因此resize的过程，均匀的把之前的冲突的节点分散到新的bucket了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081final Node&lt;K,V&gt;[] resize() &#123; Node&lt;K,V&gt;[] oldTab = table; int oldCap = (oldTab == null) ? 0 : oldTab.length; int oldThr = threshold; int newCap, newThr = 0; if (oldCap &gt; 0) &#123; // 如果超过最大值就不再扩充了，就只好随你碰撞去吧 if (oldCap &gt;= MAXIMUM_CAPACITY) &#123; threshold = Integer.MAX_VALUE; return oldTab; &#125; // 没超过最大值，就扩充为原来的2倍 else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY) newThr = oldThr &lt;&lt; 1; // double threshold &#125; else if (oldThr &gt; 0) // initial capacity was placed in threshold newCap = oldThr; else &#123; // zero initial threshold signifies using defaults newCap = DEFAULT_INITIAL_CAPACITY; newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); &#125; // 计算新的resize上限 if (newThr == 0) &#123; float ft = (float)newCap * loadFactor; newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); &#125; threshold = newThr; @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;) Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap]; table = newTab; if (oldTab != null) &#123; // 把每个bucket都移动到新的buckets中 for (int j = 0; j &lt; oldCap; ++j) &#123; Node&lt;K,V&gt; e; if ((e = oldTab[j]) != null) &#123; oldTab[j] = null; if (e.next == null) newTab[e.hash &amp; (newCap - 1)] = e; else if (e instanceof TreeNode) ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap); else &#123; // 链表优化重hash的代码块，保证链表节点顺序 Node&lt;K,V&gt; loHead = null, loTail = null; Node&lt;K,V&gt; hiHead = null, hiTail = null; Node&lt;K,V&gt; next; do &#123; next = e.next; // 原索引 if ((e.hash &amp; oldCap) == 0) &#123; if (loTail == null) loHead = e; else loTail.next = e; loTail = e; &#125; // 原索引+oldCap else &#123; if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; &#125; &#125; while ((e = next) != null); // 原索引放到bucket里 if (loTail != null) &#123; loTail.next = null; newTab[j] = loHead; &#125; if (hiTail != null) &#123; hiTail.next = null; newTab[j + oldCap] = hiHead; &#125; &#125; &#125; &#125; &#125; return newTab;&#125; get(Object key)源代码： 1234567891011121314151617181920212223242526272829public V get(Object key) &#123; Node&lt;K,V&gt; e; // 在hashmap的结构中查找key值，如果没找到返回null，找到了就返回对应的value值 return (e = getNode(hash(key), key)) == null ? null : e.value;&#125;final Node&lt;K,V&gt; getNode(int hash, Object key) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k; // 根据hash(key)定位桶的位置 if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (first = tab[(n - 1) &amp; hash]) != null) &#123; // 判断第一个节点是否相同，相同直接返回 if (first.hash == hash &amp;&amp; // always check first node ((k = first.key) == key || (key != null &amp;&amp; key.equals(k)))) return first; // 遍历链表 if ((e = first.next) != null) &#123; // 如果已经调整成红黑树，则遍历红黑树 if (first instanceof TreeNode) return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key); do &#123; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) return e; &#125; while ((e = e.next) != null); &#125; &#125; return null;&#125; 总结： HashMap底层就是一个Node数组，Node又包含next，事实上，可以看成是一个”链表数组”,java8还在此基础上增加了红黑树结构 扩容：map中存放的key-value对个数size，该个数决定了数组的扩容（size&gt;=threshold时，扩容），而非table中的所占用的桶的个数来决定是否扩容 扩容过程，不会重新计算hash值，只会重新按位与 在实际使用中，若我们能预判所要存储的元素的多少，最好使用上述的单参构造器来指定初始容量 HashMap可以插入null的key和value HashMap线程不安全（多线程情况下会导致环形链表产生），若想要线程安全，最好使用ConcurrentHashMap]]></content>
      <categories>
        <category>java集合框架源码</category>
      </categories>
      <tags>
        <tag>java集合框架源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LinkedList源码解析]]></title>
    <url>%2F2018%2F07%2F12%2FLinkedList%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[对于LinkedList需要掌握的八点内容 LinkedList的创建：即构造器 往LinkedList中添加对象：即add(E)方法 获取LinkedList中的单个对象：即get(int index)方法 修改LinkedList中的指定索引的节点的数据set(int index, E element) 删除LinkedList中的对象：即remove(E)，remove(int index)方法 遍历LinkedList中的对象：即iterator，在实际中更常用的是增强型的for循环去做遍历 判断对象是否存在于LinkedList中：contain(E) LinkedList中对象的排序：主要取决于所采取的排序算法 源码分析LinkedList的创建实现方式：1List&lt;String&gt; strList0 = new LinkedList&lt;String&gt;(); 源代码：在读源代码之前，首先要知道什么是环形双向链表 123456789101112131415161718192021222324252627282930// 链表大小0transient int size = 0;// 双向链表的头结点transient Node&lt;E&gt; first;// 双向链表的尾结点transient Node&lt;E&gt; last;/** * 构造一个空节点 */public LinkedList() &#123;&#125;/** * 链表节点，LinkedList的一个内部类： */private static class Node&lt;E&gt; &#123; // 链表存储的数据 E item; // 链表的下一个节点 Node&lt;E&gt; next; // 链表的上一个节点 Node&lt;E&gt; prev; Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123; this.item = element; this.next = next; this.prev = prev; &#125;&#125; 往LinkedList中添加对象（add(E e)）实现方式： 1strList0.add(&quot;hello&quot;); 源代码： 1234567891011121314151617181920212223// 在链表的尾部添加新节点，添加成功则返回truepublic boolean add(E e) &#123; linkLast(e); return true;&#125;void linkLast(E e) &#123; // 临时保存尾节点 final Node&lt;E&gt; l = last; // 把节点添加到双向链表中 final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null); // 令链表尾指针指向新添加的节点 last = newNode; // 如果是空链表 if (l == null) // 则令头指针指向新添加的节点，相当于创建一个新链表头节点 first = newNode; else l.next = newNode; size++; // 保证遍历时候检查链表是否有添加或删除节点 modCount++;&#125; 添加过程如下图： 这里，结合着代码注释与图片去看add(E)的源代码就好。 注意：在添加元素方面LinkedList不需要考虑数组扩容和数组复制，只需要新建一个对象。 获取LinkedList中的单个对象（get(int index)）实现方式： 12// 注意：下标从0开始strList.get(0); 源码：1234567891011121314151617181920212223242526272829303132333435/** * 返回索引值为index节点的数据，index从0开始计算 */public E get(int index) &#123; checkElementIndex(index); return node(index).item;&#125;/** * 判断index是否在合理范围内 */private void checkElementIndex(int index) &#123; if (!isElementIndex(index)) throw new IndexOutOfBoundsException(outOfBoundsMsg(index));&#125;private boolean isElementIndex(int index) &#123; return index &gt;= 0 &amp;&amp; index &lt; size;&#125;/** * 获取指定index索引位置的节点（需要遍历链表） */Node&lt;E&gt; node(int index) &#123; // 如果index小于链表大小的半，就从链表头开始遍历，否则从尾部开始遍历 if (index &lt; (size &gt;&gt; 1)) &#123; Node&lt;E&gt; x = first; for (int i = 0; i &lt; index; i++) x = x.next; return x; &#125; else &#123; Node&lt;E&gt; x = last; for (int i = size - 1; i &gt; index; i--) x = x.prev; return x; &#125;&#125; 注意：链表节点的按索引查找，需要遍历链表；而数组不需要。 修改LinkedList中指定索引的节点的数据：set(int index, E element)使用方式： 1strList.set(0, &quot;world&quot;); 源码： 123456789101112131415/** * 修改指定索引位置index上的节点的数据为element */public E set(int index, E element) &#123; // 判断index是否在合理范围内 checkElementIndex(index); // 获取指定index索引位置的节点（需要遍历链表） Node&lt;E&gt; x = node(index); // 保存节点旧值 E oldVal = x.item; // 将新值赋给该节点的element属性 x.item = element; // 返回旧值 return oldVal;&#125; 删除LinkedList中的对象remove(Object o)使用方式： 1strList.remove(&quot;world&quot;); 源码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/** * 删除第一个出现的指定元数据为o的节点 */public boolean remove(Object o) &#123; if (o == null) &#123; for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; if (x.item == null) &#123; unlink(x); return true; &#125; &#125; &#125; else &#123; for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; if (o.equals(x.item)) &#123; unlink(x); return true; &#125; &#125; &#125; return false;&#125;/* * 删除节点逻辑（节点不为空） */E unlink(Node&lt;E&gt; x) &#123; final E element = x.item; final Node&lt;E&gt; next = x.next; final Node&lt;E&gt; prev = x.prev; // 处理待删除节点的前面节点 if (prev == null) &#123; first = next; &#125; else &#123; prev.next = next; x.prev = null; &#125; // 处理待删除节点的后面节点 if (next == null) &#123; last = prev; &#125; else &#123; next.prev = prev; x.next = null; &#125; x.item = null; size--; modCount++; return element;&#125; remove(int index)使用方式： 1strList.remove(0); 源代码： 12345// 删除指定位置的节点public E remove(int index) &#123; checkElementIndex(index); return unlink(node(index));&#125; 注意： unlink(node(index))见上边 判断对象是否存在于LinkedList中（contains(E)）123456789101112131415161718192021222324252627/** * 链表中是否包含指定数据o的节点 */public boolean contains(Object o) &#123; return indexOf(o) != -1;&#125;/** * 从链表头开始，查找第一个出现o的索引 */public int indexOf(Object o) &#123; int index = 0; if (o == null) &#123; for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; if (x.item == null) return index; index++; &#125; &#125; else &#123; for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; if (o.equals(x.item)) return index; index++; &#125; &#125; return -1;&#125; 注意：indexOf(Object o)返回第一个出现的元素o的索引 遍历LinkedList中的对象（iterator()）使用方式： 123456789List&lt;String&gt; strList = new LinkedList&lt;String&gt;();strList.add(&quot;jigang&quot;);strList.add(&quot;nana&quot;);strList.add(&quot;nana2&quot;);Iterator&lt;String&gt; it = strList.iterator();while (it.hasNext()) &#123; System.out.println(it.next());&#125; 源代码：iterator()方法是在父类AbstractSequentialList中实现的 123public Iterator&lt;E&gt; iterator() &#123; return listIterator();&#125; listIterator()方法是在父类AbstractList中实现的 123public ListIterator&lt;E&gt; listIterator() &#123; return listIterator(0);&#125; listIterator(int index)方法是在父类AbstractList中实现的 123456public ListIterator&lt;E&gt; listIterator(final int index) &#123; if (index &lt; 0 || index &gt; size()) throw new IndexOutOfBoundsException(&quot;Index: &quot; + index); return new ListItr(index);&#125; 该方法返回AbstractList的一个内部类ListItr对象 1234private class ListItr extends Itr implements ListIterator&lt;E&gt; &#123; ListItr(int index) &#123; cursor = index; &#125; 上边这个类并不完整，它继承了内部类Itr，还扩展了一些其他方法（eg.向前查找方法hasPrevious()等），至于hasNext()/next()等方法还是来自于Itr的。 1234567891011121314151617181920212223242526272829303132private class Itr implements Iterator&lt;E&gt; &#123; //标记位：标记遍历到哪一个元素 int cursor = 0; //标记位：用于判断是否在遍历的过程中，是否发生了add、remove操作 int expectedModCount = modCount; //检测对象数组是否还有元素 public boolean hasNext() &#123; //如果cursor==size，说明已经遍历完了，上一次遍历的是最后一个元素 return cursor != size(); &#125; //获取元素 public E next() &#123; //检测在遍历的过程中，是否发生了add、remove操作 checkForComodification(); try &#123; E next = get(cursor++); return next; //捕获get(cursor++)方法的IndexOutOfBoundsException &#125; catch (IndexOutOfBoundsException e) &#123; checkForComodification(); throw new NoSuchElementException(); &#125; &#125; //检测在遍历的过程中，是否发生了add、remove等操作 final void checkForComodification() &#123; //发生了add、remove操作,这个我们可以查看add等的源代码，发现会出现modCount++ if (modCount != expectedModCount) throw new ConcurrentModificationException(); &#125;&#125; 注：上述的Itr我去掉了一个此时用不到的方法和属性。这里的get(int index)方法参照2.3所示。 总结 LinkedList基于环形双向链表方式实现，无容量的限制 添加元素时不用扩容（直接创建新节点，调整插入节点的前后节点的指针属性的指向即可） 线程不安全 get(int index)：需要遍历链表 remove(Object o)需要遍历链表 remove(int index)需要遍历链表 contains(E)需要遍历链表]]></content>
      <categories>
        <category>java集合框架源码 </category>
      </categories>
      <tags>
        <tag>java集合框架源码 </tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ArrayList源码解析]]></title>
    <url>%2F2018%2F07%2F11%2FArrayList%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[对于ArrayList需要掌握的七点内容 ArrayList的创建：即构造器 往ArrayList中添加对象：即add(E)方法 获取ArrayList中的单个对象：即get(int index)方法 删除ArrayList中的对象：即remove(E)方法 遍历ArrayList中的对象：即iterator，在实际中更常用的是增强型的for循环去做遍历 判断对象是否存在于ArrayList中：contain(E) ArrayList中对象的排序：主要取决于所采取的排序算法 源码分析ArrayList的创建（常见的两种方式）12List&lt;String&gt; strList = new ArrayList&lt;String&gt;();List&lt;String&gt; strList2 = new ArrayList&lt;String&gt;(5); ArrayList源代码： 基本属性：1234//对象数组：ArrayList的底层数据结构private transient Object[] elementData;//elementData中已存放的元素的个数，注意：不是elementData的容量private int size; 注意： transient关键字的作用：在采用Java默认的序列化机制的时候，被该关键字修饰的属性不会被序列化。 ArrayList类实现了java.io.Serializable接口，即采用了Java默认的序列化机制 上面的elementData属性采用了transient来修饰，表明其不使用Java默认的序列化机制来实例化，但是该属性是ArrayList的底层数据结构，在网络传输中一定需要将其序列化，之后使用的时候还需要反序列化，那不采用Java默认的序列化机制，那采用什么呢？直接翻到源码的最下边有两个方法，发现ArrayList自己实现了序列化和反序列化的方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/** * Save the state of the &lt;tt&gt;ArrayList&lt;/tt&gt; instance to a stream (that * is, serialize it). * * @serialData The length of the array backing the &lt;tt&gt;ArrayList&lt;/tt&gt; * instance is emitted (int), followed by all of its elements * (each an &lt;tt&gt;Object&lt;/tt&gt;) in the proper order. */private void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException&#123; // Write out element count, and any hidden stuff int expectedModCount = modCount; s.defaultWriteObject(); // Write out size as capacity for behavioural compatibility with clone() s.writeInt(size); // Write out all elements in the proper order. for (int i=0; i&lt;size; i++) &#123; s.writeObject(elementData[i]); &#125; if (modCount != expectedModCount) &#123; throw new ConcurrentModificationException(); &#125;&#125;/** * Reconstitute the &lt;tt&gt;ArrayList&lt;/tt&gt; instance from a stream (that is, * deserialize it). */private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException &#123; elementData = EMPTY_ELEMENTDATA; // Read in size, and any hidden stuff s.defaultReadObject(); // Read in capacity s.readInt(); // ignored if (size &gt; 0) &#123; // be like clone(), allocate array based upon size not capacity int capacity = calculateCapacity(elementData, size); SharedSecrets.getJavaOISAccess().checkArray(s, Object[].class, capacity); ensureCapacityInternal(size); Object[] a = elementData; // Read in all elements in the proper order. for (int i=0; i&lt;size; i++) &#123; a[i] = s.readObject(); &#125; &#125;&#125; 构造器： 12345678910111213141516171819202122232425262728/** * 创建一个容量为initialCapacity的空的（size==0）对象数组 */public ArrayList(int initialCapacity) &#123; if (initialCapacity &gt; 0) &#123; this.elementData = new Object[initialCapacity]; &#125; else if (initialCapacity == 0) &#123; this.elementData = EMPTY_ELEMENTDATA; &#125; else &#123; throw new IllegalArgumentException(&quot;Illegal Capacity: &quot; + initialCapacity); &#125;&#125;/** * 默认初始化一个容量为10的对象数组(java8之前) */public ArrayList() &#123; //即上边的public ArrayList(int initialCapacity)&#123;&#125;构造器 this(10);&#125;/** * 默认初始化一个空数组(java8)，在java8中，在第一次add方法中会调用ensureExplicitCapac * ity方法把容量初始化为10，效果同上面一样 */private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;public ArrayList() &#123; this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;&#125; 在我们执行new ArrayList\&lt;String>()时，会调用上边的无参构造器，创造一个容量为10的对象数组。在我们执行new ArrayList\&lt;String>(5)时，会调用上边的public ArrayList(int initialCapacity)，创造一个容量为5的对象数组。 在实际使用中，如果我们能对所需的ArrayList的大小进行判断，有两个好处： 节省内存空间（eg.我们只需要放置两个元素到数组，new ArrayList(2)） 避免数组扩容（下边会讲）引起的效率下降（eg.我们只需要放置大约37个元素到数组，new ArrayList(40)） 往ArrayList中添加对象（常见的两个方法add(E)和addAll(Collection&lt;? extends E&gt; c)）add(E)1strList.add(&quot;hello&quot;); ArrayList源代码:12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * 向elementData中添加元素 */public boolean add(E e) &#123; //确保对象数组elementData有足够的容量，可以将新加入的元素e加进去 ensureCapacityInternal(size + 1); //加入新元素e，size加1 elementData[size++] = e; return true;&#125;//确保对象数组elementData有足够的容量private void ensureCapacityInternal(int minCapacity) &#123; ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));&#125;// 计算数组容量，保证初始化容量为10private static int calculateCapacity(Object[] elementData, int minCapacity) &#123; if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; return Math.max(DEFAULT_CAPACITY, minCapacity); &#125; return minCapacity;&#125;// 保证有足够容量private void ensureExplicitCapacity(int minCapacity) &#123; // modCount变量用于在遍历集合（iterator()）时，检测是否发生了add、remove操作。 modCount++; // 如果容量不够则扩容 if (minCapacity - elementData.length &gt; 0) grow(minCapacity);&#125;// 扩容逻辑private void grow(int minCapacity) &#123; // 原始容量大小 int oldCapacity = elementData.length; // 容量扩大1.5倍 int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; // 如果超出最大值，则设置为最大值 if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); elementData = Arrays.copyOf(elementData, newCapacity);&#125; 在上述代码的扩容结束后，调用了Arrays.copyOf(elementData, newCapacity)方法，这个方法中：对于我们这里而言，先创建了一个新的容量为newCapacity的对象数组，然后使用System.arraycopy()方法将旧的对象数组复制到新的对象数组中去了。 注意：modCount变量用于在遍历集合（iterator()）时，检测是否发生了add、remove操作。 addAll(Collection&lt;? extends E&gt; c)使用方式： 1234567List&lt;String&gt; strList = new ArrayList&lt;String&gt;();strList.add(&quot;jigang&quot;);strList.add(&quot;nana&quot;);strList.add(&quot;nana2&quot;);List&lt;String&gt; strList2 = new ArrayList&lt;String&gt;(2);strList2.addAll(strList); 源代码： 1234567891011121314151617/** * 将c全部加入elementData */public boolean addAll(Collection&lt;? extends E&gt; c) &#123; // 将c集合转化为对象数组a Object[] a = c.toArray(); // 获取a对象数组的容量 int numNew = a.length; // 确保对象数组elementData有足够的容量，可以将新加入的a对象数组加进去 ensureCapacityInternal(size + numNew); //将对象数组a拷贝到elementData中去 System.arraycopy(a, 0, elementData, size, numNew); // 重新设置elementData中已加入的元素的个数 size += numNew; // 若加入的是空集合则返回false return numNew != 0;&#125; 注意: 从上述代码可以看出，若加入的c是空集合，则返回false ensureCapacity(size + numNew);这个方法在上边用过 System.arraycopy()方法定义如下：1public static native void arraycopy(Object src, int srcPos, Object dest, int destPos, int length); 将数组src从下标为srcPos开始拷贝，一直拷贝length个元素到dest数组中，在dest数组中从destPos开始加入先的srcPos数组元素。 除了以上两种常用的add方法外，还有如下两种： add(int index, E element)123456789101112131415161718192021222324/** * 在特定位置（只能是已有元素的数组的特定位置）index插入元素E */public void add(int index, E element) &#123; // 检查index是否在已有的数组中 rangeCheckForAdd(index); // 确保对象数组elementData有足够的容量，可以将新加入的元素e加进去 ensureCapacityInternal(size + 1); // 将index及其后边的所有的元素整块后移，空出index位置 System.arraycopy(elementData, index, elementData, index + 1, size - index); // 插入元素 elementData[index] = element; // 已有数组元素个数+1 size++;&#125;/** * 检查index是否在已有的数组中 */private void rangeCheckForAdd(int index) &#123; if (index &gt; size || index &lt; 0) throw new IndexOutOfBoundsException(outOfBoundsMsg(index));&#125; 注意：index&lt;=size才行，并不是index&lt;elementData.length set(int index, E element)12345678910111213/** * 更换特定位置index上的元素为element，返回该位置上的旧值 */public E set(int index, E element) &#123; // 检查index是否在已有的数组中 rangeCheck(index); // 旧值 E oldValue = elementData(index); // 该位置替换为新值 elementData[index] = element; // 返回旧值 return oldValue;&#125; 获取ArrayList中的单个对象（get(int index)）实现方式： 12345ArrayList&lt;String&gt; strList2 = new ArrayList&lt;String&gt;(2);strList2.add(&quot;hello&quot;);strList2.add(&quot;nana&quot;);strList2.add(&quot;nana2&quot;);System.out.println(strList2.get(0)); 源代码： 123456789101112131415/** * 按照索引查询对象E */public E get(int index) &#123; RangeCheck(index);//检查索引范围 return (E) elementData[index];//返回元素，并将Object转型为E&#125;/** * 检查索引index是否超出size-1 */private void RangeCheck(int index) &#123; if (index &gt;= size) throw new IndexOutOfBoundsException(&quot;Index:&quot;+index+&quot;,Size:&quot;+size);&#125; 注意：这里对index进行了索引检查，是为了将异常内容写的详细一些并且将检查的内容缩小（index &lt; 0 || index &gt;= size，注意这里的size是已存储元素的个数）；事实上不检查也可以，因为对于数组而言，如果index不满足要求（index &lt; 0 || index &gt; = length，注意这里的length是数组的容量）,都会直接抛出数组越界异常，而假设数组的length为10，当前的size是2，你去计算array[9]，这时候得出是null，这也是上边get为什么减小检查范围的原因。 删除ArrayList中的对象remove(Object o)使用方式： 1strList2.remove(&quot;hello&quot;); 源代码： 1234567891011121314151617181920212223242526272829303132333435/** * 从前向后移除第一个出现的元素o */public boolean remove(Object o) &#123; //移除对象数组elementData中的第一个null if (o == null) &#123; for (int index = 0; index &lt; size; index++) if (elementData[index] == null) &#123; fastRemove(index); return true; &#125; //移除对象数组elementData中的第一个o &#125; else &#123; for (int index = 0; index &lt; size; index++) if (o.equals(elementData[index])) &#123; fastRemove(index); return true; &#125; &#125; return false;&#125;/* * 删除单个位置的元素，是ArrayList的私有方法 */private void fastRemove(int index) &#123; modCount++; int numMoved = size - index - 1; //删除的不是最后一个元素 if (numMoved &gt; 0) //删除的元素到最后的元素整块前移 System.arraycopy(elementData, index + 1, elementData, index,numMoved); //将最后一个元素设为null，在下次gc的时候就会回收掉了 elementData[--size] = null; &#125; remove(int index)使用方式： 1strList2.remove(0); 源代码： 123456789101112131415/** * 删除指定索引index下的元素，返回被删除的元素 */public E remove(int index) &#123; rangeCheck(index); modCount++; E oldValue = elementData(index); int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; return oldValue;&#125; 注意：remove(Object o)需要遍历数组，remove(int index)不需要，只需要判断索引符合范围即可，所以，通常：后者效率更高。 判断对象是否存在于ArrayList中（contains(E)）源代码：1234567891011121314151617181920212223242526272829303132333435363738/** * 判断动态数组是否包含元素o */public boolean contains(Object o) &#123; return indexOf(o) &gt;= 0;&#125;/** * 返回第一个出现的元素o的索引位置 */public int indexOf(Object o) &#123; if (o == null) &#123;//返回第一个null的索引 for (int i = 0; i &lt; size; i++) if (elementData[i] == null) return i; &#125; else &#123;//返回第一个o的索引 for (int i = 0; i &lt; size; i++) if (o.equals(elementData[i])) return i; &#125; return -1;//若不包含，返回-1&#125;/** * 返回最后一个出现的元素o的索引位置 */public int lastIndexOf(Object o) &#123; if (o == null) &#123; for (int i = size - 1; i &gt;= 0; i--) if (elementData[i] == null) return i; &#125; else &#123; for (int i = size - 1; i &gt;= 0; i--) if (o.equals(elementData[i])) return i; &#125; return -1;&#125; 注意：indexOf(Object o)返回第一个出现的元素o的索引；lastIndexOf(Object o)返回最后一个o的索引 遍历ArrayList中的对象（iterator()）使用方式： 123456789List&lt;String&gt; strList = new ArrayList&lt;String&gt;();strList.add(&quot;jigang&quot;);strList.add(&quot;nana&quot;);strList.add(&quot;nana2&quot;);Iterator&lt;String&gt; it = strList.iterator();while (it.hasNext()) &#123; System.out.println(it.next());&#125; 源代码：iterator()方法是在AbstractList中实现的，该方法返回AbstractList的一个内部类Itr对象 123456789101112131415161718192021222324252627282930313233343536public Iterator&lt;E&gt; iterator() &#123; return new Itr();//返回一个内部类对象&#125;private class Itr implements Iterator&lt;E&gt; &#123; //标记位：标记遍历到哪一个元素 int cursor = 0; //标记位：用于判断是否在遍历的过程中，是否发生了add、remove操作 int expectedModCount = modCount; //检测对象数组是否还有元素 public boolean hasNext() &#123; //如果cursor==size，说明已经遍历完了，上一次遍历的是最后一个元素 return cursor != size(); &#125; //获取元素 public E next() &#123; //检测在遍历的过程中，是否发生了add、remove操作 checkForComodification(); try &#123; E next = get(cursor++); return next; //捕获get(cursor++)方法的IndexOutOfBoundsException &#125; catch (IndexOutOfBoundsException e) &#123; checkForComodification(); throw new NoSuchElementException(); &#125; &#125; //检测在遍历的过程中，是否发生了add、remove等操作 final void checkForComodification() &#123; //发生了add、remove操作,这个我们可以查看add等的源代码，发现会出现modCount++ if (modCount != expectedModCount) throw new ConcurrentModificationException(); &#125;&#125; 遍历的整个流程结合”使用方式”与”Itr的注释”来看。注：上述的Itr我去掉了一个此时用不到的方法和属性。 总结 ArrayList基于数组方式实现，无容量的限制（会扩容） 添加元素时可能要扩容（所以最好预判一下），删除元素时不会减少容量（若希望减少容量，trimToSize()），删除元素时，将删除掉的位置元素置为null，下次gc就会回收这些元素所占的内存空间。 线程不安全 add(int index, E element)：添加元素到数组中指定位置的时候，需要将该位置及其后边所有的元素都整块向后复制一位 get(int index)：获取指定位置上的元素时，可以通过索引直接获取（O(1)） remove(Object o)需要遍历数组 remove(int index)不需要遍历数组，只需判断index是否符合条件即可，效率比remove(Object o)高 contains(E)需要遍历数组做以上总结，主要是为了与后边的LinkedList作比较。]]></content>
      <categories>
        <category>java集合框架源码</category>
      </categories>
      <tags>
        <tag>java集合框架源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Executor框架]]></title>
    <url>%2F2018%2F07%2F04%2FExecutor%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[Eexecutor作为灵活且强大的异步执行框架，其支持多种不同类型的任务执行策略，提供了一种标准的方法将任务的提交过程和执行过程解耦开发，基于生产者-消费者模式，其提交任务的线程相当于生产者，执行任务的线程相当于消费者，并用Runnable来表示任务，Executor的实现还提供了对生命周期的支持，以及统计信息收集，应用程序管理机制和性能监视等机制。 Exexctor简介如下为Executor的UML图 Executor：一个接口，其定义了一个接收Runnable对象的方法executor，其方法签名为executor(Runnable command) ExecutorService：是一个比Executor使用更广泛的子类接口，其提供了生命周期管理的方法，以及可跟踪一个或多个异步任务执行状况返回Future的方法 AbstractExecutorService：ExecutorService执行方法的默认实现 ScheduledExecutorService：一个可定时调度任务的接口 ScheduledThreadPoolExecutor：ScheduledExecutorService的实现，一个可定时调度任务的线程池 ThreadPoolExecutor：线程池，可以通过调用Executors静态工厂方法来创建线程池并返回一个ExecutorService对象 ThreadPoolExecutor构造函数的各个参数说明ThreadPoolExecutor方法签名： 1234567public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) //后两个参数为可选参数 corePoolSize：核心线程数，如果运行的线程少于corePoolSize，则创建新线程来执行新任务，即使线程池中的其他线程是空闲的 maximumPoolSize:最大线程数，可允许创建的线程数，corePoolSize和maximumPoolSize设置的边界自动调整池大小：corePoolSize &lt;运行的线程数&lt; maximumPoolSize:仅当队列满时才创建新线程corePoolSize=运行的线程数= maximumPoolSize：创建固定大小的线程池 keepAliveTime:如果线程数多于corePoolSize,则这些多余的线程的空闲时间超过keepAliveTime时将被终止 unit:keepAliveTime参数的时间单位 workQueue:保存任务的阻塞队列，与线程池的大小有关： 当运行的线程数少于corePoolSize时，在有新任务时直接创建新线程来执行任务而无需再进队列 当运行的线程数等于或多于corePoolSize，在有新任务添加时则选加入队列，不直接创建线程 当队列满时，在有新任务时就创建新线程 threadFactory:使用ThreadFactory创建新线程，默认使用defaultThreadFactory创建线程 handle:定义处理被拒绝任务的策略，默认使用ThreadPoolExecutor.AbortPolicy,任务被拒绝时将抛出RejectExecutorException Executors：提供了一系列静态工厂方法用于创建各种线程池newFixedThreadPool创建可重用且固定线程数的线程池，如果线程池中的所有线程都处于活动状态，此时再提交任务就在队列中等待，直到有可用线程；如果线程池中的某个线程由于异常而结束时，线程池就会再补充一条新线程。 123456public static ExecutorService newFixedThreadPool(int nThreads) &#123; return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, //使用一个基于FIFO排序的阻塞队列，在所有corePoolSize线程都忙时新任务将在队列中等待 new LinkedBlockingQueue&lt;Runnable&gt;());&#125; newSingleThreadExecutor创建一个单线程的Executor，如果该线程因为异常而结束就新建一条线程来继续执行后续的任务 1234567public static ExecutorService newSingleThreadExecutor() &#123; return new FinalizableDelegatedExecutorService //corePoolSize和maximumPoolSize都等于，表示固定线程池大小为1 (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;()));&#125; newScheduledThreadPool创建一个可延迟执行或定期执行的线程池 1234567public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize, ThreadFactory threadFactory) &#123; return new ScheduledThreadPoolExecutor(corePoolSize, threadFactory);&#125;public ScheduledThreadPoolExecutor(int corePoolSize) &#123; super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS, new DelayedWorkQueue());&#125; 例1：（使用newScheduledThreadPool来模拟心跳机制） 1234567891011public class HeartBeat &#123; public static void main(String[] args) &#123; ScheduledExecutorService executor = Executors.newScheduledThreadPool(5); Runnable task = new Runnable() &#123; public void run() &#123; System.out.println(&quot;HeartBeat.........................&quot;); &#125; &#125;; executor.scheduleAtFixedRate(task,5,3, TimeUnit.SECONDS); //5秒后第一次执行，之后每隔3秒执行一次 &#125;&#125; 输出： 12HeartBeat....................... //5秒后第一次输出HeartBeat....................... //每隔3秒输出一个 newCachedThreadPool创建可缓存的线程池，如果线程池中的线程在60秒未被使用就将被移除，在执行新的任务时，当线程池中有之前创建的可用线程就重用可用线程，否则就新建一条线程。 123456public static ExecutorService newCachedThreadPool() &#123; return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, //使用同步队列，将任务直接提交给线程 new SynchronousQueue&lt;Runnable&gt;());&#125; 例2： 1234567891011121314public class ThreadPoolTest &#123; public static void main(String[] args) throws InterruptedException &#123; ExecutorService threadPool = Executors.newCachedThreadPool();//线程池里面的线程数会动态变化，并可在线程线被移除前重用 for (int i = 1; i &lt;= 3; i ++) &#123; final int task = i; //10个任务 //TimeUnit.SECONDS.sleep(1); threadPool.execute(new Runnable() &#123; //接受一个Runnable实例 public void run() &#123; System.out.println(&quot;线程名字： &quot; + Thread.currentThread().getName() + &quot; 任务名为： &quot;+task); &#125; &#125;); &#125; &#125;&#125; 输出：（为每个任务新建一条线程，共创建了3条线程） 123线程名字： pool-1-thread-1 任务名为： 1线程名字： pool-1-thread-2 任务名为： 2线程名字： pool-1-thread-3 任务名为： 3 去掉第6行的注释其输出如下：（始终重复利用一条线程，因为newCachedThreadPool能重用可用线程） 123线程名字： pool-1-thread-1 任务名为： 1线程名字： pool-1-thread-1 任务名为： 2线程名字： pool-1-thread-1 任务名为： 3 通过使用Executor可以很轻易的实现各种调优、管理、监视、记录日志和错误报告等待。 Executor的生命周期ExecutorService提供了管理Eecutor生命周期的方法，ExecutorService的生命周期包括了：运行，关闭和终止三种状态。 ExecutorService在初始化创建时处于运行状态shutdown方法等待提交的任务执行完成并不再接受新任务，在完成全部提交的任务后关闭shutdownNow方法将强制终止所有运行中的任务并不再允许提交新任务 可以将一个Runnable（如例2）或Callable（如例3）提交给ExecutorService的submit方法执行，最终返回一个Future用来获得任务的执行结果或取消任务 例3：（任务执行完成后并返回执行结果） 1234567891011public class CallableAndFuture &#123; public static void main(String[] args) throws ExecutionException, InterruptedException &#123; ExecutorService executor = Executors.newSingleThreadExecutor(); Future&lt;String&gt; future = executor.submit(new Callable&lt;String&gt;() &#123; //接受一上callable实例 public String call() throws Exception &#123; return &quot;MOBIN&quot;; &#125; &#125;); System.out.println(&quot;任务的执行结果：&quot;+future.get()); &#125;&#125; 输出：1任务的执行结果：MOBIN ExecutorCompletionService实现了CompletionService，将执行完成的任务放到阻塞队列中，通过take或poll方法来获得执行结果 例4：（启动10条线程，谁先执行完成就返回谁） 12345678910111213141516public class CompletionServiceTest &#123; public static void main(String[] args) throws InterruptedException, ExecutionException &#123; ExecutorService executor = Executors.newFixedThreadPool(10); //创建含10.条线程的线程池 CompletionService completionService = new ExecutorCompletionService(executor); for (int i =1; i &lt;=10; i ++) &#123; final int result = i; completionService.submit(new Callable() &#123; public Object call() throws Exception &#123; Thread.sleep(new Random().nextInt(5000)); //让当前线程随机休眠一段时间 return result; &#125; &#125;); &#125; System.out.println(completionService.take().get()); //获取执行结果 &#125;&#125; 输出结果可能每次都不同（在1到10之间） 13 通过Executor来设计应用程序可以简化开发过程，提高开发效率，并有助于实现并发，在开发中如果需要创建线程可优先考虑使用Executor]]></content>
      <categories>
        <category>java并发</category>
      </categories>
      <tags>
        <tag>java并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态规划（2）]]></title>
    <url>%2F2018%2F06%2F30%2F%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%882%EF%BC%89%2F</url>
    <content type="text"><![CDATA[整理一下经典动态规划题目 台阶问题题目：有n级台阶，一个人每次上一级或者两级，问有多少种走完n级台阶的方法。为了防止溢出，请将结果Mod 1000000007 分析：假设第i层台阶的方法数为f(i)，则f(i)=f(i-1)+f(i-2)，第i层只能等于i-1层上一阶加上i-2层上两阶，因此：f(1)=1f(2)=2f(i)=f(i-1)+f(i-2) 暴力递归方法123456789public static int jumpStep1(int n) &#123; if (n &lt; 0) &#123; return 0; &#125; if (n == 1 || n == 2) &#123; return n; &#125; return jumpStep1(n - 1) + jumpStep1(n - 2);&#125; 轮询遍历123456789101112131415161718192021public static int jumpStep2(int n) &#123; if (n &lt; 0) &#123; return 0; &#125; if (n == 1 || n == 2) &#123; return n; &#125; // 当前值 int pre = 1; // 前一个值 int res = 2; int temp = 0; for (int i = 3; i &lt;= n; ++i) &#123; temp = res; res = res + pre; pre = temp; &#125; return res;&#125; 动态规划12345678910111213141516public static int jumpStep3(int n) &#123; if (n &lt; 0) &#123; return 0; &#125; if (n == 1 || n == 2) &#123; return n; &#125; int[] res = new int[n + 1]; res[1] = 1; res[2] = 2; for (int i = 3; i &lt;= n; ++i) &#123; res[i] = res[i-1] + res[i-2]; &#125; return res[n];&#125; 矩阵的最小路径和题目：给定一个矩阵m，从左上角开始每次只能向右或者向下走，最后到达右下角的为止，路径上所有的数字累加起来就是路径和，返回所有路径中的最小的路径和。举例：1 3 5 98 1 3 45 0 6 18 8 4 0路径1,3,1,0,6,1,0是所有路径中路径和最小的，所以返回12. 代码：12345678910111213141516171819202122public static int getMin(int[][] arr) &#123; if (arr == null || arr.length == 0 || arr[0] == null || arr[0].length == 0) &#123; return 0; &#125; int rows = arr.length; int cols = arr[0].length; int[][] dp = new int[rows][cols]; dp[0][0] = arr[0][0]; for (int i = 1; i &lt; rows; ++i) &#123; dp[i][0] = arr[i][0] + dp[i-1][0]; &#125; for (int j = 1; j &lt; cols; ++j) &#123; dp[0][j] += arr[0][j] + dp[0][j-1]; &#125; for (int i = 1; i &lt; rows; ++i) &#123; for (int j = 1; j &lt; cols; ++j) &#123; dp[i][j] = arr[i][j] + Math.min(dp[i - 1][j], dp[i][j - 1]); &#125; &#125; return dp[rows - 1][cols - 1];&#125; 最长递增子序列问题题目：给定一个整数序列，找到最长上升子序列（LIS），返回LIS的长度。 最长上升子序列的定义：最长上升子序列问题是在一个无序的给定序列中找到一个尽可能长的由低到高排列的子序列，这种子序列不一定是连续的或者唯一的。 样例给出 [5,4,1,2,3]，LIS 是 [1,2,3]，返回 3给出 [4,2,4,5,3,7]，LIS 是 [2,4,5,7]，返回 4 分析： 代码：12345678910111213141516171819public int longestIncreasingSubsequence(int[] nums) &#123; int[] dp = new int[nums.length]; // 生成dp数组 for (int i = 0; i &lt; nums.length; ++i) &#123; dp[i] = 1; for (int j = 0; j &lt; i; ++j) &#123; if (nums[j] &lt; nums[i]) &#123; dp[i] = Math.max(dp[i], dp[j] + 1); &#125; &#125; &#125; // 遍历数组得到最长递增子序列长度 int max = 0; for (int i = 0; i &lt; nums.length; ++i) &#123; max = Math.max(max, dp[i]); &#125; return max;&#125; 最长公共子序列题目：给出两个字符串，找到最长公共子序列(LCS)，返回LCS的长度。 最长公共子序列的定义：最长公共子序列问题是在一组序列（通常2个）中找到最长公共子序列（注意：不同于子串，LCS不需要是连续的子串）。该问题是典型的计算机科学问题，是文件差异比较程序的基础，在生物信息学中也有所应用。 样例：给出”ABCD” 和 “EDCA”，这个LCS是 “A” (或 D或C)，返回1给出 “ABCD” 和 “EACB”，这个LCS是”AC”返回2 分析： 代码： 123456789101112131415161718192021222324252627282930public static int longestCommonSubsequence(String A, String B) &#123; int lengthA = A.length(); int lengthB = B.length(); if(lengthA == 0 || lengthB == 0) &#123; return 0; &#125; int[][] dp = new int[lengthA][lengthB]; dp[0][0] = A.charAt(0) == B.charAt(0) ? 1 : 0; for (int i = 0; i &lt; lengthA; ++i) &#123; dp[i][0] = Math.max(dp[i-1][0], A.charAt(i) == B.charAt(0) ? 1 : 0); &#125; for (int j = 0; j &lt; lengthB; ++j) &#123; dp[0][j] = Math.max(dp[0][j], A.charAt(0) == B.charAt(j) ? 1 : 0); &#125; for (int i = 1; i &lt; lengthA; ++i) &#123; for (int j = 1; j &lt; lengthB; ++j) &#123; dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]); if (A.charAt(i) == B.charAt(j)) &#123; dp[i][j] = Math.max(dp[i][j], dp[i-1][j-1] + 1); &#125; &#125; &#125; return dp[lengthA - 1][lengthB - 1];&#125; 背包问题题目： 一个背包有一定的承重W,有N件物品,每件都有自己的价值,记录在数组v中,也都有自己的重量,记录在数组w中,每件物品只能选择要装入背包还是不装入背包,要求在不超过背包承重的前提下,选出物品的总价值最大。 分析： 代码12345678910111213public static int backpack(int[] w, int[] v, int W, int N) &#123; int[][] dp = new int[N+1][W+1]; for (int x = 1 ; x &lt;= N; ++x) &#123; for (int y = 1; y &lt;= W; ++y) &#123; if (y &gt;= w[x-1]) &#123; dp[x][y] = Math.max(dp[x-1][y], dp[x-1][y-w[x-1]] + v[x-1]); &#125; else &#123; dp[x][y] = dp[x-1][y]; &#125; &#125; &#125; return dp[N][W];&#125; 最优编辑问题题目： 给定两个字符串str1和str2，再给定三个整数ic，dc和rc，分别代表插入，删除和替换一个字符的代价。返回将str1编辑成str2的最小代价。比如，str1=”abc”,str2=adc”,ic=5,dc=3,rc=2。从”abc”编辑成”adc”，把’b’替换成’d’是代价最小的，所以返回2。再比如，str1=”abc”,str2=adc”,ic=5,dc=3,C=100。从”abc”编辑成”adc”,先删除’b’,然后插入’d’是代价最小的，所以返回8。 分析： 假设A,B的长度分布为N和M，那么建立一个大小为(N+1)*(M+1)的矩阵dp，==其中dp[i][j]表示的含义是将A[0,…,i-1]编辑成B[0,…,j-1]的最小代价== dp[0][0]=0 dp[i][0]=dc*i dp[0][j]=ic*i dp[i][j]有四种情况分别如下： dp[i][j]=dp[i-1][j]+dc dp[i][j]=dp[i][j-1]+ic 当A[i-1]==B[j-1]时，dp[i][j]=dp[i-1][j-1] 当A[i-1]!=B[j-1]时，dp[i][j]=dp[i-1][j-1]+rc 12345678910111213141516171819202122232425public static int getMinEditCost(String str1, int m, String str2, int n, int ic, int dc, int rc) &#123; int[][] dp = new int[m + 1][n + 1]; dp[0][0] = 0; // 第一列 for (int i = 1; i &lt;= m; ++i) &#123; dp[i][0] = i * dc; &#125; // 第一行 for (int j = 1; j &lt;= n; ++j) &#123; dp[0][j] = j * ic; &#125; // dp[i][j] for (int i = 1; i &lt;= m; ++i) &#123; for (int j = 1; j &lt;= n; ++j) &#123; int temp = Math.min(dp[i - 1][j] + dc, dp[i][j - 1] + ic); if (str1.charAt(i - 1) == str2.charAt(j - 1)) &#123; dp[i][j] = Math.min(temp, dp[i - 1][j - 1]); &#125; else &#123; dp[i][j] = Math.min(temp, dp[i - 1][j - 1] + rc); &#125; &#125; &#125; return dp[m][n];&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态规划（1）]]></title>
    <url>%2F2018%2F06%2F30%2F%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%881%EF%BC%89%2F</url>
    <content type="text"><![CDATA[问题给定数组arr，arr中所有的值都为整数且不重复。每个值代表一种面值的货币，每种货币有无数张，再给定一个整数aim代表要找的钱数，求换钱的方法有多少种。 基本思路这道题的经典之处在于它可以体现暴力递归、记忆搜索、动态规划之间的关系，并可以在动态规划的基础上再进行一次优化。 首先介绍暴力递归的方法。如果arr = [5, 10, 25, 1]，aim = 1000，分析过程如下： 用０张５元的货币，让[10, 25, 1]组成剩下的1000，最终方法数记为res1。 用１张５元的货币，让[10, 25, 1]组成剩下的995，最终方法数记为res2。 用２张５元的货币，让[10, 25, 1]组成剩下的990，最终方法数记为res3。…… 用201张５元的货币，让[10, 25, 1]组成剩下的0，最终方法数记为res201。 那么res1 + res2 + res3 + …… +res201的值就是中的方法数。根据如上的分析过程定义递归函数process1(arr, index, aim)它的含义是如果用arr[index..N-1]这些面值的钱组成aim，返回总的方法数。最坏情况下时间复杂度为O(aim^N)，N表示数组的长度。 暴力搜索方法下面是用java实现的代码（时间复杂度O(aim^N)） 12345678910111213141516171819public static int coins1(int[] arr, int aim) &#123; if (arr == null || arr.length == 0 || aim &lt; 0) &#123; return 0; &#125; return process1(arr, 0, aim);&#125;// 它的含义是如果用arr[index..N-1]这些面值的钱组成aim，返回总的方法数public static int process1(int[] arr, int index, int aim) &#123; int res = 0; // 终止条件 if (index == arr.length) &#123; res = (aim == 0) ? 1 : 0; &#125; else &#123; for (int i = 0; arr[index] * i &lt;= aim; ++i) &#123; res += process1(arr, index + 1, aim - arr[index] * i); &#125; &#125; return res;&#125; 记忆搜索方法在暴力递归中，有很多的重复计算，比如使用0张5元+1张10元的情况和使用2张5元+0张10元的情况，都需要求[25, 1]组成剩下的990的方法数。记忆搜索就是使用一张记录表将递归过程中的结果进行记录，当下次再遇到同样的递归过程，就直接使用表中的数据，这样就对暴力递归进行了优化。 下面是用java实现的代码（时间复杂度为O(N*aim^2)，空间复杂度O(N*aim)） 123456789101112131415161718192021222324252627282930// 记忆搜索方法public static int coins2(int[] arr, int aim) &#123; if (arr == null || arr.length == 0 || aim &lt; 0) &#123; return 0; &#125; // 定义一张表来记录计算过的值，从而避免重复计算 // map[i][j] == 0 表示没有计算过 // map[i][j] == -1 表示计算过，但是值为0 // map[i][j] == a 表示计算过，值为a int[][] map = new int[arr.length + 1][aim + 1]; return process2(arr, 0, aim, map);&#125;public static int process2(int[] arr, int index, int aim, int[][] map) &#123; int res = 0; if (index == arr.length) &#123; res = (aim == 0) ? 1 : 0; &#125; else &#123; int mapValue = 0; for (int i = 0; arr[index] * i &lt;= aim; ++i) &#123; mapValue = map[index + 1][aim - arr[index] * i]; if (mapValue != 0) &#123; res += mapValue == -1 ? 0 : mapValue; &#125; else &#123; res += process2(arr, index + 1, aim - arr[index] * i, map); &#125; &#125; &#125; map[index][aim] = res == 0 ? -1 : res; return res;&#125; 动态规划 下面是用java实现的代码（时间复杂度为O(N*aim^2)，空间复杂度O(N*aim)） 12345678910111213141516171819202122232425// 动态规划方法public static int coins3(int[] arr, int aim) &#123; if (arr == null || arr.length == 0 || aim &lt; 0) &#123; return 0; &#125; // dp[i][j]的含义是在使用arr[0..i]货币的情况下，组成钱数j有多少种方法 int[][] dp = new int[arr.length][aim + 1]; for (int i = 0; i &lt; arr.length; ++i) &#123; dp[i][0] = 1; &#125; for (int j = 0; j * arr[0] &lt;= aim; j++) &#123; dp[0][j * arr[0]] = 1; &#125; for (int i = 1; i &lt; arr.length; ++i) &#123; for (int j = 1; j &lt;= aim; ++j) &#123; int num = 0; for (int k = 0; j - k * arr[i] &gt;= 0; ++k) &#123; num += dp[i - 1][j - k * arr[i]]; &#125; dp[i][j] = num; &#125; &#125; return dp[arr.length - 1][aim];&#125; 动态规划引入 123456789101112131415161718192021// 优化后的动态规划方法public static int coins4(int[] arr, int aim) &#123; if (arr == null || arr.length == 0 || aim &lt; 0) &#123; return 0; &#125; // dp[i][j]的含义是在使用arr[0..i]货币的情况下，组成钱数j有多少种方法 int[][] dp = new int[arr.length][aim + 1]; for (int i = 0; i &lt; arr.length; ++i) &#123; dp[i][0] = 1; &#125; for (int j = 0; j * arr[0] &lt;= aim; j++) &#123; dp[0][j * arr[0]] = 1; &#125; for (int i = 1; i &lt; arr.length; ++i) &#123; for (int j = 1; j &lt;= aim; ++j) &#123; // 简化枚举过程 dp[i][j] = dp[i - 1][j] + (j - arr[i] &gt;= 0 ? dp[i][j - arr[i]] : 0); &#125; &#125; return dp[arr.length - 1][aim];&#125; 记忆搜索与动态规划的联系 记忆化搜索方法就是某种形态的动态规划方法。 记忆化搜索方法不关心到达某一个递归过程的路径,只是单纯地对计算过的递归过程进行记录,避免重复的递归过程。 动态规划的方法则是规定好每一个递归过程的计算顺序,依次进行计算,后面的计算过程严格依赖前面的计算过程。 两者都是空间换时间的方法,也都有校举!的过程,区别就在于动态规划规定计算顺序,而记忆搜索不用规定。 解决动态规划问题的过程 实现暴力递归方法。 在暴力搜索方法的函数中看看哪些参数可!以代表递归过程 找到代表递归过程的参数之后,记忆化搜索的方法非常容易实现。 通过分析记忆化搜索的依赖路径,进而实视动态规划。 根据记忆化搜索方法改出动态规划方法,进而看看是否能化简,如果能化简,还能实现时间复杂度更低的动态规划方法。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编码规范整理]]></title>
    <url>%2F2018%2F06%2F27%2F%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[最近在根据阿里规范插件整理代码规范，总结下遇到的问题 Critical级别不使用过时的类或方法123456private static JSONObject sendHttpRequest(String url, List&lt;NameValuePair&gt; nvps) &#123; // DefaultHttpClient是添加了@Deprecated注解的类 DefaultHttpClient httpClient = new DefaultHttpClient(); HttpPost httpPost = new HttpPost(url); // ............&#125; 建线程或线程池时请指定有意义的线程名称，方便出错时回溯说明：创建线程池的时候使用带ThreadFactory的构造函数，并且提供自定义ThreadFactory实现或者使用第三方实现。 123456789101112// Guava提供ThreadFactory namedThreadFactory = new ThreadFactoryBuilder().setNameFormat("demo-pool-%d").build(); ExecutorService singleThreadPool = new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;(1024), namedThreadFactory, new ThreadPoolExecutor.AbortPolicy()); singleThreadPool.execute(()-&gt; System.out.println(Thread.currentThread().getName())); singleThreadPool.shutdown(); public class TimerTaskThread extends Thread &#123; public TimerTaskThread()&#123; super.setName("TimerTaskThread"); ...... &#125; Major级别不允许任何魔法值（即未经定义的常量）直接出现在代码中1234567891011Negative example: //Magic values, except for predefined, are forbidden in coding. if (key.equals(&quot;Id#taobao_1&quot;)) &#123; //... &#125;Positive example: String KEY_PRE = &quot;Id#taobao_1&quot;; if (KEY_PRE.equals(key)) &#123; //... &#125; 事务场景中，抛出异常被catch后，如果需要回滚，一定要手动回滚事务12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758Positive example 1： /** * @author caikang * @date 2017/04/07 */ @Service @Transactional(rollbackFor = Exception.class) public class UserServiceImpl implements UserService &#123; @Override public void save(User user) &#123; //some code //db operation &#125; &#125;Positive example 2： /** * @author caikang * @date 2017/04/07 */ @Service public class UserServiceImpl implements UserService &#123; @Override @Transactional(rollbackFor = Exception.class) public void save(User user) &#123; //some code //db operation &#125; &#125; Positive example 3： /** * @author caikang * @date 2017/04/07 */ @Service public class UserServiceImpl implements UserService &#123; @Autowired private DataSourceTransactionManager transactionManager; @Override @Transactional public void save(User user) &#123; DefaultTransactionDefinition def = new DefaultTransactionDefinition(); // explicitly setting the transaction name is something that can only be done programmatically def.setName("SomeTxName"); def.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED); TransactionStatus status = transactionManager.getTransaction(def); try &#123; // execute your business logic here //db operation &#125; catch (Exception ex) &#123; transactionManager.rollback(status); throw ex; &#125; &#125; &#125; 关于基本数据类型与包装数据类型的使用标准 所有的POJO类属性必须使用包装数据类型。 RPC方法的返回值和参数必须使用包装数据类型。 所有的局部变量推荐使用基本数据类型。 1234public class DemoDO &#123; String str; Integer a;&#125; 及时清理不再使用的代码段或配置信息说明：对于垃圾代码或过时配置，坚决清理干净，避免程序过度臃肿，代码冗余 1234567Positive example: public static void hello() &#123; /// Business is stopped temporarily by the owner. // Business business = new Business(); // business.active(); System.out.println(&quot;it&apos;s finished&quot;);&#125; 定义DO/DTO/VO等POJO类时，不要加任何属性默认值1234public class DemoDO &#123; String str; Integer a;&#125; 所有的类都必须添加创建者信息1234567/** * Demo class * * @author keriezhang * @date 2016/10/31 */public class CodeNoteDemo &#123;&#125; 类、类属性、类方法的注释必须使用javadoc规范说明：注释使用/**内容*/格式，不得使用//xxx方式和/*xxx*/方式。 123456789101112131415161718192021222324252627/** * * XXX class function description. * */public class XxClass implements Serializable &#123; private static final long serialVersionUID = 113323427779853001L; /** * id */ private Long id; /** * title */ private String title; /** * find by id * * @param ruleId rule id * @param page start from 1 * @return Result&lt;Xxxx&gt; */ public Result&lt;Xxxx&gt; funcA(Long ruleId, Integer page) &#123; return null; &#125;&#125; 不要在条件判断中执行复杂的语句说明：除常用方法（如getXxx/isXxx）等外，不要在条件判断中执行复杂的语句，将复杂逻辑判断的结果赋值给一个有意义的布尔变量，以提高可读性。说明：很多if语句内的逻辑相当复杂，阅读者需要分析条件表达式的最终结果，才能明确什么样的条件执行什么样的语句，那么，如果阅读者分析逻辑表达式错误呢？ 12345678910Negative example: if ((file.open(fileName, &quot;w&quot;) != null) &amp;&amp; (...) || (...)) &#123; // ... &#125; Positive example: boolean existed = (file.open(fileName, &quot;w&quot;) != null) &amp;&amp; (...) || (...); if (existed) &#123; //... &#125; 集合初始化时，指定集合初始值大小。说明：HashMap使用如下构造方法进行初始化，如果暂时无法确定集合大小，那么指定默认值（16）即可。 12345Negative example: Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;(); Positive example: Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;(16);]]></content>
      <categories>
        <category>代码规范</category>
      </categories>
      <tags>
        <tag>代码规范</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[KMP字符串匹配（java）]]></title>
    <url>%2F2018%2F06%2F22%2FKMP%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%2F</url>
    <content type="text"><![CDATA[KMP算法介绍参考：字符串匹配的KMP算法 问题： 对于一个给定的 source 字符串和一个 target 字符串，你应该在 source 字符串中找出 target 字符串出现的第一个位置(从0开始)。如果不存在，则返回 -1。 样例如果 source = “source” 和 target = “target”，返回 -1。 如果 source = “abcdabcdefg” 和 target = “bcd”，返回 1。 暴力解法123456789101112131415161718192021222324252627282930public int strStr(String source, String target) &#123; // write your code here if (source == null) &#123; return -1; &#125; if (target == null) &#123; return -1; &#125; if (target.length() == 0) &#123; return 0; &#125; int sourceLength = source.length(); int targetLength = target.length(); char[] sourceCharArray = source.toCharArray(); char[] targetCharArray = target.toCharArray(); for (int i = 0; i &lt; sourceLength; ++i) &#123; if (sourceCharArray[i] == targetCharArray[0]) &#123; int tempI = i; for (int j = 0; j &lt; targetLength &amp;&amp; tempI &lt; sourceLength; ++j, ++tempI) &#123; if (sourceCharArray[tempI] != targetCharArray[j]) &#123; break; &#125; &#125; if (tempI == (i + targetCharArray.length)) &#123; return i; &#125; &#125; &#125; return -1;&#125; KMP算法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677// 获取字符串部分匹配表public int[] getPartMatchTable(String str) &#123; if (str == null || str.length() == 0) &#123; return null; &#125; int length = str.length(); char[] charArray = str.toCharArray(); int[] table = new int[str.length()]; int j = 0; int i = 1; int count = 0; table[0] = 0; while (i &lt; length) &#123; if (charArray[i] == charArray[j]) &#123; ++count; table[i] = count; ++i; ++j; &#125; else &#123; count = 0; table[i] = count; j = 0; ++i; &#125; &#125; return table;&#125;public int strStr(String source, String target) &#123; // write your code here if (source == null) &#123; return -1; &#125; if (target == null) &#123; return -1; &#125; if (target.length() == 0) &#123; return 0; &#125; int sourceLength = source.length(); int targetLength = target.length(); char[] sourceCharArray = source.toCharArray(); char[] targetCharArray = target.toCharArray(); // 获取字符串部分匹配表 int[] table = getPartMatchTable(target); // 遍历标记 int i = 0; // 记录已经匹配的字符数 int count = 0; // 定义临时标记 int tempI = 0; while (i &lt; sourceLength) &#123; if (sourceCharArray[i] == targetCharArray[0]) &#123; int j = 0; tempI = i; while (j &lt; targetLength &amp;&amp; tempI &lt; sourceLength) &#123; if (sourceCharArray[tempI] == targetCharArray[j]) &#123; ++count; &#125; else &#123; break; &#125; ++tempI; ++j; &#125; if (tempI == (i + targetCharArray.length)) &#123; return i; &#125; else &#123; // 关键代码 i = i + (count - table[j]); count = 0; &#125; &#125; else &#123; ++i; &#125; &#125; return -1;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线程池]]></title>
    <url>%2F2018%2F06%2F21%2F%E7%BA%BF%E7%A8%8B%E6%B1%A0%2F</url>
    <content type="text"><![CDATA[为什么使用线程池？ 可以降低资源的消耗。线程池通过重复利用资源来避免创建和销毁线程带来的资源消耗。 提高响应速度。不需要新创建线程来执行任务，直接利用线程池中已经创建好的线程来执行任务。 保证线程可管理。线程不能无限创建和销毁，通过线程池可以进行统一分配、调优和监控。 线程池原理 从图中可以看出，当提交一个新任务到线程池时，线程池的处理流程如下。1）线程池判断核心线程池里的线程是否都在执行任务。如果不是，则创建一个新的工作线程来执行任务。如果核心线程池里的线程都在执行任务，则进入下个流程。2）线程池判断工作队列是否已经满。如果工作队列没有满，则将新提交的任务存储在这个工作队列里。如果工作队列满了，则进入下个流程。3）线程池判断线程池的线程是否都处于工作状态。如果没有，则创建一个新的工作线程来执行任务。如果已经满了，则交给饱和策略来处理这个任务。 ThreadPoolExecutor执行execute步骤 ThreadPoolExecutor执行execute方法分下面4种情况。1）如果当前运行的线程少于corePoolSize，则创建新线程来执行任务（注意，执行这一步骤需要获取全局锁）。2）如果运行的线程等于或多于corePoolSize，则将任务加入BlockingQueue。3）如果无法将任务加入BlockingQueue（队列已满），则创建新的线程来处理任务（注意，执行这一步骤需要获取全局锁）。4）如果创建新线程将使当前运行的线程超出maximumPoolSize，任务将被拒绝，并调用RejectedExecutionHandler.rejectedExecution()方法。 ThreadPoolExecutor采取上述步骤的总体设计思路，是为了在执行execute()方法时，尽可能地避免获取全局锁（那将会是一个严重的可伸缩瓶颈）。在ThreadPoolExecutor完成预热之后（当前运行的线程数大于等于corePoolSize），几乎所有的execute()方法调用都是执行步骤2，而步骤2不需要获取全局锁。 线程池使用创建线程1234567ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) 对各参数说明： corePoolSize（线程池的基本大小）： 当提交一个任务到线程池时，线程池会创建一个线程来执行任务，即使其他空闲的基本线程能够执行新任务也会创建线程，等到需要执行的任务数大于线程池基本大小时就不再创建。如果调用了线程池的prestartAllCoreThreads()方法，线程池会提前创建并启动所有基本线程。 maximumPoolSize（线程池最大数量）：线程池允许创建的最大线程数。如果队列满了，并且已创建的线程数小于最大线程数，则线程池会再创建新的线程执行任务。值得注意的是，如果使用了无界的任务队列这个参数就没什么效果。（ps:无界的任务队列，队列不会满，该参数自然无效） keepAliveTime（线程活动保持时间）：线程池的工作线程空闲后，保持存活的时间。所以，如果任务很多，并且每个任务执行的时间比较短，可以调大时间，提高线程的利用率。 这个说的让人感觉比较模糊，总结一下大概意思为：比如说线程池中最大的线程数为50，而其中只有40个线程任务在跑，相当于有10个空闲线程，这10个空闲线程不能让他一直在开着，因为线程的存在也会特别好资源的，所有就需要设置一个这个空闲线程的存活时间，这么解释应该就很清楚了。 unit（线程活动保持时间的单位）：可选的单位有天（DAYS）、小时（HOURS）、分钟（MINUTES）、毫秒（MILLISECONDS）、微秒（MICROSECONDS，千分之一毫秒）和纳秒（NANOSECONDS，千分之一微秒）。 workQueue（任务队列）：用于保存等待执行的任务的阻塞队列。可以选择以下几个阻塞队列。 ArrayBlockingQueue：是一个基于数组结构的有界阻塞队列，此队列按FIFO（先进先出）原则对元素进行排序。 LinkedBlockingQueue：一个基于链表结构的阻塞队列，此队列按FIFO排序元素，吞吐量通常要高于ArrayBlockingQueue。静态工厂方法Executors.newFixedThreadPool()使用了这个队列。 SynchronousQueue：一个不存储元素的阻塞队列。每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于Linked-BlockingQueue，静态工厂方法Executors.newCachedThreadPool使用了这个队列。 PriorityBlockingQueue：一个具有优先级的无限阻塞队列。 threadFactory：用于设置创建线程的工厂，可以通过线程工厂给每个创建出来的线程设置更有意义的名字。使用开源框架guava提供的ThreadFactoryBuilder可以快速给线程池里的线程设置有意义的名字，代码如下。 1new ThreadFactoryBuilder().setNameFormat("XX-task-%d").build(); handler:（饱和策略）：当队列和线程池都满了，说明线程池处于饱和状态，那么必须采取一种策略处理提交的新任务。这个策略默认情况下是AbortPolicy，表示无法处理新任务时抛出异常。在JDK 1.5中Java线程池框架提供了以下4种策略。 AbortPolicy：直接抛出异常。 CallerRunsPolicy：只用调用者所在线程来运行任务。 DiscardOldestPolicy：丢弃队列里最近的一个任务，并执行当前任务。 DiscardPolicy：不处理，丢弃掉。当然，也可以根据应用场景需要来实现RejectedExecutionHandler接口自定义策略。如记录日志或持久化存储不能处理的任务。 向线程池提交任务可以使用两个方法向线程池提交任务，分别为execute()和submit()方法。 execute()方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功。通过以下代码可知execute()方法输入的任务是一个Runnable类的实例。 123456threadsPool.execute(new Runnable() &#123; @Override public void run() &#123; // TODO Auto-generated method stub &#125;&#125;); submit()方法用于提交需要返回值的任务。线程池会返回一个future类型的对象，通过这个future对象可以判断任务是否执行成功，并且可以通过future的get()方法来获取返回值，get()方法会阻塞当前线程直到任务完成，而使用get（long timeout，TimeUnit unit）方法则会阻塞当前线程一段时间后立即返回，这时候有可能任务没有执行完。 Future&lt;Object&gt; future = executor.submit(harReturnValuetask); try { Object s = future.get(); } catch (InterruptedException e) { // 处理中断异常 } catch (ExecutionException e) { // 处理无法执行任务异常 } finally { // 关闭线程池 executor.shutdown(); } 关闭线程池可以通过调用线程池的shutdown或shutdownNow方法来关闭线程池。它们的原理是遍历线程池中的工作线程，然后逐个调用线程的interrupt方法来中断线程，所以无法响应中断的任务可能永远无法终止。但是它们存在一定的区别，shutdownNow首先将线程池的状态设置成STOP，然后尝试停止所有的正在执行或暂停任务的线程，并返回等待执行任务的列表，而shutdown只是将线程池的状态设置成SHUTDOWN状态，然后中断所有没有正在执行任务的线程。 只要调用了这两个关闭方法中的任意一个，isShutdown方法就会返回true。当所有的任务都已关闭后，才表示线程池关闭成功，这时调用isTerminaed方法会返回true。至于应该调用哪一种方法来关闭线程池，应该由提交到线程池的任务特性决定，通常调用shutdown方法来关闭线程池，如果任务不一定要执行完，则可以调用shutdownNow方法。 合理配置线程池要想合理地配置线程池，就必须首先分析任务特性，可以从以下几个角度来分析。 任务的性质：CPU密集型任务、IO密集型任务和混合型任务。 任务的优先级：高、中和低。 任务的执行时间：长、中和短。 任务的依赖性：是否依赖其他系统资源，如数据库连接。 性质不同的任务可以用不同规模的线程池分开处理。CPU密集型任务应配置尽可能小的线程，如配置Ncpu+1个线程的线程池。由于IO密集型任务线程并不是一直在执行任务，则应配置尽可能多的线程，如2*Ncpu。混合型的任务，如果可以拆分，将其拆分成一个CPU密集型任务和一个IO密集型任务，只要这两个任务执行的时间相差不是太大，那么分解后执行的吞吐量将高于串行执行的吞吐量。如果这两个任务执行时间相差太大，则没必要进行分解。可以通过Runtime.getRuntime().availableProcessors()方法获得当前设备的CPU个数。 优先级不同的任务可以使用优先级队列PriorityBlockingQueue来处理。它可以让优先级高的任务先执行。 注意： 如果一直有优先级高的任务提交到队列里，那么优先级低的任务可能永远不能执行。 执行时间不同的任务可以交给不同规模的线程池来处理，或者可以使用优先级队列，让执行时间短的任务先执行。 依赖数据库连接池的任务，因为线程提交SQL后需要等待数据库返回结果，等待的时间越长，则CPU空闲时间就越长，那么线程数应该设置得越大，这样才能更好地利用CPU。 建议使用有界队列。有界队列能增加系统的稳定性和预警能力，可以根据需要设大一点儿，比如几千。有一次，我们系统里后台任务线程池的队列和线程池全满了，不断抛出抛弃任务的异常，通过排查发现是数据库出现了问题，导致执行SQL变得非常缓慢，因为后台任务线程池里的任务全是需要向数据库查询和插入数据的，所以导致线程池里的工作线程全部阻塞，任务积压在线程池里。如果当时我们设置成无界队列，那么线程池的队列就会越来越多，有可能会撑满内存，导致整个系统不可用，而不只是后台任务出现问题。当然，我们的系统所有的任务是用单独的服务器部署的，我们使用不同规模的线程池完成不同类型的任务，但是出现这样问题时也会影响到其他任务。 监控线程池如果在系统中大量使用线程池，则有必要对线程池进行监控，方便在出现问题时，可以根据线程池的使用状况快速定位问题。可以通过线程池提供的参数进行监控，在监控线程池的时候可以使用以下属性。 taskCount：线程池需要执行的任务数量。 completedTaskCount：线程池在运行过程中已完成的任务数量，小于或等于taskCount。 largestPoolSize：线程池里曾经创建过的最大线程数量。通过这个数据可以知道线程池是否曾经满过。如该数值等于线程池的最大大小，则表示线程池曾经满过。 getPoolSize：线程池的线程数量。如果线程池不销毁的话，线程池里的线程不会自动销毁，所以这个大小只增不减。 getActiveCount：获取活动的线程数。 通过扩展线程池进行监控。可以通过继承线程池来自定义线程池，重写线程池的beforeExecute、afterExecute和terminated方法，也可以在任务执行前、执行后和线程池关闭前执行一些代码来进行监控。例如，监控任务的平均执行时间、最大执行时间和最小执行时间等。这几个方法在线程池里是空方法。]]></content>
      <categories>
        <category>java并发</category>
      </categories>
      <tags>
        <tag>java并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Exchanger使用]]></title>
    <url>%2F2018%2F06%2F15%2FExchanger%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Exchanger（交换者）是一个用于线程间协作的工具类。 Exchanger用于进行线程间的数据交换。它提供一个同步点，在这个同步点，两个线程可以交换彼此的数据。这两个线程通过exchange方法交换数据，如果第一个线程先执行exchange()方法，它会一直等待第二个线程也执行exchange方法，当两个线程都到达同步点时，这两个线程就可以交换数据，将本线程生产出来的数据传递给对方。 应用场景： Exchanger可以用于遗传算法，遗传算法里需要选出两个人作为交配对象，这时候会交换两人的数据，并使用交叉规则得出2个交配结果。Exchanger也可以用于校对工作，比如我们需要将纸制银行流水通过人工的方式录入成电子银行流水，为了避免错误，采用AB岗两人进行录入，录入到Excel之后，系统需要加载这两个Excel，并对两个Excel数据进行校对，看看是否录入一致。 代码： 123456789101112131415161718192021222324252627282930313233343536package EigthChapter.Exchanger;import java.util.concurrent.Exchanger;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;public class ExchangerTest &#123; private static final Exchanger&lt;String&gt; exgr = new Exchanger&lt;String&gt;(); private static ExecutorService threadPool = Executors.newFixedThreadPool(2); public static void main(String[] args) &#123; threadPool.execute(() -&gt; &#123; try &#123; String A = "银行流水A";// A录入银行流水数据 exgr.exchange(A); &#125; catch (InterruptedException e) &#123; &#125; &#125; ); threadPool.execute(() -&gt; &#123; try &#123; String B = "银行流水B";// B录入银行流水数据 String A = exgr.exchange("B"); System.out.println("A和B数据是否一致：" + A.equals(B) + "，A录入的是：" + A + "，B录入是：" + B); &#125; catch (InterruptedException e) &#123; &#125; &#125; ); threadPool.shutdown(); &#125;&#125; 执行结果： 1A和B数据是否一致：false，A录入的是：银行流水A，B录入是：银行流水B 如果两个线程有一个没有执行exchange()方法，则会一直等待，如果担心有特殊情况发生，避免一直等待，可以使用exchange（V x，longtimeout，TimeUnit unit）设置最大等待时长。]]></content>
      <categories>
        <category>java并发</category>
      </categories>
      <tags>
        <tag>java并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Semaphore使用]]></title>
    <url>%2F2018%2F06%2F15%2FSemaphore%2F</url>
    <content type="text"><![CDATA[Semaphore（信号量）是用来控制同时访问特定资源的线程数量，它通过协调各个线程，以保证合理的使用公共资源。 理解： 比如××马路要限制流量，只允许同时有一百辆车在这条路上行使，其他的都必须在路口等待，所以前一百辆车会看到绿灯，可以开进这条马路，后面的车会看到红灯，不能驶入××马路，但是如果前一百辆中有5辆车已经离开了××马路，那么后面就允许有5辆车驶入马路，这个例子里说的车就是线程，驶入马路就表示线程在执行，离开马路就表示线程执行完成，看见红灯就表示线程被阻塞，不能执行。 应用场景： Semaphore可以用于做流量控制，特别是公用资源有限的应用场景，比如数据库连接。假如有一个需求，要读取几万个文件的数据，因为都是IO密集型任务，我们可以启动几十个线程并发地读取，但是如果读到内存后，还需要存储到数据库中，而数据库的连接数只有10个，这时我们必须控制只有10个线程同时获取数据库连接保存数据，否则会报错无法获取数据库连接。这个时候，就可以使用Semaphore来做流量控制。 代码： 12345678910111213141516171819202122232425package EigthChapter.Semaphore;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.Semaphore;public class SemaphoreTest &#123; private static final int THREAD_COUNT = 30; private static ExecutorService threadPool = Executors.newFixedThreadPool(THREAD_COUNT); private static Semaphore s = new Semaphore(10); public static void main(String[] args) &#123; for (int i = 0; i &lt; THREAD_COUNT; ++i) &#123; threadPool.execute(() -&gt; &#123; try &#123; s.acquire(); System.out.println("save data"); s.release(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;); &#125; threadPool.shutdown(); &#125;&#125; 运行结果： 12345save datasave datasave datasave data......... 在代码中，虽然有30个线程在执行，但是只允许10个并发执行。Semaphore的构造方法Semaphore（int permits）接受一个整型的数字，表示可用的许可证数量。Semaphore（10）表示允许10个线程获取许可证，也就是最大并发数是10。Semaphore的用法也很简单，首先线程使用Semaphore的acquire()方法获取一个许可证，使用完之后调用release()方法归还许可证。还可以用tryAcquire()方法尝试获取许可证。]]></content>
      <categories>
        <category>java并发</category>
      </categories>
      <tags>
        <tag>java并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CyclicBarrier使用]]></title>
    <url>%2F2018%2F06%2F14%2FCyclicBarrier%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[CyclicBarrier的字面意思是可循环使用（Cyclic）的屏障（Barrier）。它要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续运行。 基本使用CyclicBarrier默认的构造方法是CyclicBarrier(int parties)，其参数表示屏障拦截的线程数量，每个线程调用await方法告诉CyclicBarrier我已经到达了屏障，然后当前线程被阻塞。 123456789101112131415161718192021222324252627282930313233package EigthChapter.CyclicBarrier;import java.util.concurrent.BrokenBarrierException;import java.util.concurrent.CyclicBarrier;public class CyclicBarrierTest &#123; static CyclicBarrier c = new CyclicBarrier(2); public static void main(String[] args) &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; c.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (BrokenBarrierException e) &#123; e.printStackTrace(); &#125; System.out.println(1); &#125; &#125;).start(); try &#123; c.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (BrokenBarrierException e) &#123; e.printStackTrace(); &#125; System.out.println(2); &#125;&#125; 运行结果： 1234521-----12 因为主线程和子线程的调度是由CPU决定的，两个线程都有可能先执行，所以会产生两种输出 进阶用法CyclicBarrier还提供一个更高级的构造函数CyclicBarrier(int parties,Runnable barrierAction)，用于在线程到达屏障时，优先执行barrierAction，方便处理更复杂的业务场景 12345678910111213141516171819202122232425262728293031323334353637package EigthChapter.CyclicBarrier;import java.util.concurrent.BrokenBarrierException;import java.util.concurrent.CyclicBarrier;public class CyclicBarrierTest2 &#123; static CyclicBarrier c = new CyclicBarrier(2, new A()); public static void main(String[] args) &#123; new Thread(() -&gt; &#123; try &#123; c.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (BrokenBarrierException e) &#123; e.printStackTrace(); &#125; System.out.println(1); &#125; ).start(); try &#123; c.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (BrokenBarrierException e) &#123; e.printStackTrace(); &#125; System.out.println(2); &#125; static class A implements Runnable &#123; @Override public void run() &#123; System.out.println(3); &#125; &#125;&#125; 运行结果：123312 因为CyclicBarrier设置了拦截线程的数量是2，所以必须等代码中的第一个线程和线程A都执行完之后，才会继续执行主线程，然后输出2 CyclicBarrier的应用场景CyclicBarrier可以用于多线程计算数据，最后合并计算结果的场景。 场景用一个Excel保存了用户所有银行流水，每个Sheet保存一个账户近一年的每笔银行流水，现在需要统计用户的日均银行流水，先用多线程处理每个sheet里的银行流水，都执行完之后，得到每个sheet的日均银行流水，最后，再用barrierAction用这些线程的计算结果，计算出整个Excel的日均银行流水 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package EigthChapter.CyclicBarrier;import java.util.Map;import java.util.concurrent.*;public class BankWaterService implements Runnable&#123; /** * 创建4个屏障，处理完之后执行当前类的run方法 */ private CyclicBarrier c = new CyclicBarrier(4, this); /** * 假设只有4个sheet，所以只启动4个线程 */ private Executor executor = Executors.newFixedThreadPool(4); /** * 保存每个sheet计算出的银流结果 */ private ConcurrentHashMap&lt;String, Integer&gt; sheetBankWaterCount = new ConcurrentHashMap&lt;&gt;(); private void count() &#123; for (int i = 0; i &lt; 4; ++i) &#123; executor.execute(() -&gt; &#123; //计算当前sheet的银流数据，计算代码省略 sheetBankWaterCount.put(Thread.currentThread().getName(), 1); // 银流计算完成，插入一个屏障 try &#123; c.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (BrokenBarrierException e) &#123; e.printStackTrace(); &#125; &#125;); &#125; &#125; @Override public void run() &#123; int result = 0; // 汇总每个sheet计算出的结果 for (Map.Entry&lt;String, Integer&gt; entry : sheetBankWaterCount.entrySet()) &#123; result += entry.getValue(); &#125; // 输出结果 sheetBankWaterCount.put("result", result); System.out.println(result); &#125; public static void main(String[] args) &#123; BankWaterService bankWaterService = new BankWaterService(); bankWaterService.count(); &#125;&#125; 使用线程池创建4个线程，分别计算每个sheet里的数据，每个sheet计算结果是1，再由BankWaterService线程汇总4个sheet计算出的结果 运行结果： 14 CyclicBarrier和CountDownLatch的区别CountDownLatch的计数器只能使用一次，而CyclicBarrier的计数器可以使用reset()方法重置。所以CyclicBarrier能处理更为复杂的业务场景。例如，如果计算发生错误，可以重置计数器，并让线程重新执行一次。 CyclicBarrier还提供其他有用的方法，比如getNumberWaiting方法可以获得Cyclic-Barrier阻塞的线程数量。isBroken()方法用来了解阻塞的线程是否被中断。 12345678910111213141516171819202122232425package EigthChapter.CyclicBarrier;import java.util.concurrent.CyclicBarrier;public class CyclicBarrierTest3 &#123; static CyclicBarrier c = new CyclicBarrier(2); public static void main(String[] args) &#123; Thread thread = new Thread(() -&gt; &#123; try &#123; c.await(); &#125; catch (Exception e) &#123; &#125; &#125;); thread.start(); thread.interrupt(); try &#123; c.await(); &#125; catch (Exception e) &#123; System.out.println(c.isBroken()); &#125; &#125;&#125; 运行结果： 1true]]></content>
      <categories>
        <category>java并发</category>
      </categories>
      <tags>
        <tag>java并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CountDownLatch使用]]></title>
    <url>%2F2018%2F06%2F13%2FCountDownLatch%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[CountDownLatch允许一个或多个线程等待其他线程完成操作。 问题 我们需要解析一个Excel里多个sheet的数据，此时可以考虑使用多线程，每个线程解析一个sheet里的数据，等到所有的sheet都解析完之后，程序需要提示解析完成。 使用join方法实现测试代码如下：1234567891011121314151617181920212223242526package EigthChapter;public class JoinCountDownLatchTest &#123; public static void main(String[] args) throws InterruptedException &#123; Thread parser1 = new Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println("parser1 finished"); &#125; &#125;); Thread parser2 = new Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println("parser2 finished"); &#125; &#125;); parser1.start(); parser2.start(); parser1.join(); parser2.join(); System.out.println("parser all finished"); &#125;&#125; 运行结果：123parser2 finishedparser1 finishedparser all finished join用于让当前执行线程等待join线程执行结束。其实现原理是不停检查join线程是否存活，如果join线程存活则让当前线程永远等待。其中，wait（0）表示永远等待下去，代码片段如下 123while (isAlive()) &#123; wait(0);&#125; 使用CountDownLatch方法实现测试代码：1234567891011121314151617181920package EigthChapter;import java.util.concurrent.CountDownLatch;public class CountDownLatchTest &#123; public static void main(String[] args) throws InterruptedException&#123; CountDownLatch c = new CountDownLatch(2); new Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println(1); c.countDown(); System.out.println(2); c.countDown(); &#125; &#125;).start(); c.await(); System.out.println(3); &#125;&#125; 运行结果： 123123 CountDownLatch的构造函数接收一个int类型的参数作为计数器，如果你想等待N个点完成，这里就传入N。 当我们调用CountDownLatch的countDown方法时，N就会减1，CountDownLatch的await方法会阻塞当前线程，直到N变成零。由于countDown方法可以用在任何地方，所以这里说的N个点，可以是N个线程，也可以是1个线程里的N个执行步骤。用在多个线程时，只需要把这个CountDownLatch的引用传递到线程里即可。 如果有某个解析sheet的线程处理得比较慢，我们不可能让主线程一直等待，所以可以使用另外一个带指定时间的await方法——await（long time，TimeUnit unit），这个方法等待特定时间后，就会不再阻塞当前线程。join也有类似的方法。]]></content>
      <categories>
        <category>java并发</category>
      </categories>
      <tags>
        <tag>java并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringAop日志埋点]]></title>
    <url>%2F2018%2F06%2F08%2FSpringAop%E6%97%A5%E5%BF%97%E5%9F%8B%E7%82%B9%2F</url>
    <content type="text"><![CDATA[最近项目中使用了springAop来统一处理日志，总结下用法 springAop用法maven导入aspectj jar包12345&lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.8.9&lt;/version&gt;&lt;/dependency&gt; 定义切面类12345@Aspect@Componentpublic class LoggingAspect &#123;........&#125; 注意：需要通过@Component注解把切面类添加进容器中。 定义切面类中的相关方法定义切入点表达式1234567/** * 定义一个方法, 用于声明切入点表达式. 一般地, 该方法中再不需要添入其他的代码. * 使用 @Pointcut 来声明切入点表达式. * 后面的其他通知直接使用方法名来引用当前的切入点表达式. */@Pointcut(&quot;execution(public int com.atguigu.spring.aop.ArithmeticCalculator.*(..))&quot;)public void declareJointPointExpression()&#123;&#125; 定义切入点表达式是为了方便后面“通知方法的调用”，也相当于在写代码时候定义一个变量，来避免后面冗余的代码。 ==定义切入点表达式有个小技巧：== 可以定义一个注解类：123@Target(&#123; ElementType.METHOD, ElementType.TYPE &#125;)@Retention(RUNTIME)public @interface AopLog &#123;&#125; 在需要植入通知的方法上加上该注解1234@RequestMapping(value = &quot;/api/text/trans&quot;, method = RequestMethod.POST)@AopLogpublic ResponseResult transText(@RequestBody TransArticleAO transArticleAO, @RequestHeader(&quot;appkey&quot;) String appKey) &#123;&#125; 定义切入点表达式 123@Pointcut(&quot;@annotation(com.atguigu.spring.annotation.AopLog)&quot;)public void OpenApiAopLogPoint() &#123;&#125; 这样可以更加灵活的给需要植入通知的方法植入通知 定义前置通知方法123456789/** * 在 com.atguigu.spring.aop.ArithmeticCalculator 接口的每一个实现类的每一个方法开始之前执行一段代码 */@Before(&quot;declareJointPointExpression()&quot;)public void beforeMethod(JoinPoint joinPoint)&#123; String methodName = joinPoint.getSignature().getName(); Object [] args = joinPoint.getArgs(); System.out.println(&quot;The method &quot; + methodName + &quot; begins with &quot; + Arrays.asList(args));&#125; 定义后置通知方法12345678/** * 在方法执行之后执行的代码. 无论该方法是否出现异常 */@After(&quot;declareJointPointExpression()&quot;)public void afterMethod(JoinPoint joinPoint)&#123; String methodName = joinPoint.getSignature().getName(); System.out.println(&quot;The method &quot; + methodName + &quot; ends&quot;);&#125; 定义返回通知方法12345678910/** * 在方法法正常结束后执行的代码 * 返回通知是可以访问到方法的返回值的! */@AfterReturning(value=&quot;declareJointPointExpression()&quot;, returning=&quot;result&quot;)public void afterReturning(JoinPoint joinPoint, Object result)&#123; String methodName = joinPoint.getSignature().getName(); System.out.println(&quot;The method &quot; + methodName + &quot; ends with &quot; + result);&#125; 定义异常通知方法12345678910/** * 在目标方法出现异常时会执行的代码. * 可以访问到异常对象; 且可以指定在出现特定异常时再执行通知代码 */@AfterThrowing(value=&quot;declareJointPointExpression()&quot;, throwing=&quot;e&quot;)public void afterThrowing(JoinPoint joinPoint, Exception e)&#123; String methodName = joinPoint.getSignature().getName(); System.out.println(&quot;The method &quot; + methodName + &quot; occurs excetion:&quot; + e);&#125; 定义环绕通知方法1234567891011121314151617181920212223242526272829/** * 环绕通知需要携带 ProceedingJoinPoint 类型的参数. * 环绕通知类似于动态代理的全过程: ProceedingJoinPoint 类型的参数可以决定是否执行目标方法. * 且环绕通知必须有返回值, 返回值即为目标方法的返回值 *//*@Around(&quot;execution(public int com.atguigu.spring.aop.ArithmeticCalculator.*(..))&quot;)public Object aroundMethod(ProceedingJoinPoint pjd)&#123; Object result = null; String methodName = pjd.getSignature().getName(); try &#123; //前置通知 System.out.println(&quot;The method &quot; + methodName + &quot; begins with &quot; + Arrays.asList(pjd.getArgs())); //执行目标方法 result = pjd.proceed(); //返回通知 System.out.println(&quot;The method &quot; + methodName + &quot; ends with &quot; + result); &#125; catch (Throwable e) &#123; //异常通知 System.out.println(&quot;The method &quot; + methodName + &quot; occurs exception:&quot; + e); throw new RuntimeException(e); &#125; //后置通知 System.out.println(&quot;The method &quot; + methodName + &quot; ends&quot;); return result;&#125; 环绕通知是前面几种通知的融合。但是需要注意的是环绕通知方法是有返回值的，如果不设置返回值，会影响目标方法的结果返回。 上面几种方法可以根据实际情况在代码中使用。 log4j配置日志单独打印到独立文件中在log4j配置文件中添加如下配置 12345678910//配置单独打印到的日志目录别名，日志级别等log4j.logger.com.netease.mind.nmt.aop=$&#123;log4j.level&#125;, aoplog4j.additivity.com.netease.mind.nmt.aop=falselog4j.appender.aop=org.apache.log4j.DailyRollingFileAppenderlog4j.appender.aop.DatePattern=&apos;_&apos;yyyy-MM-ddlog4j.appender.aop.File=$&#123;log4j.path&#125;/nmtp_aop.loglog4j.appender.aop.Append=truelog4j.appender.aop.Threshold=$&#123;log4j.level&#125;log4j.appender.aop.layout=org.apache.log4j.PatternLayoutlog4j.appender.aop.layout.ConversionPattern=%m%n 日志具体参数参考：https://blog.csdn.net/foreverling/article/details/51385128]]></content>
      <categories>
        <category>日志</category>
      </categories>
      <tags>
        <tag>springAop</tag>
        <tag>日志</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[日志组件slf4j结合log4j使用]]></title>
    <url>%2F2018%2F06%2F01%2F%E6%97%A5%E5%BF%97%E7%BB%84%E4%BB%B6slfj4%E7%BB%93%E5%90%88log4j%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[总结下slf4j和log4j日志框架的使用 参考：java日志框架log4j详细配置及与slf4j联合使用教程 参考：Log4j将不同Package的日志输出到不同的文件]]></content>
      <tags>
        <tag>日志</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Quartz任务调度框架简单使用]]></title>
    <url>%2F2018%2F05%2F31%2FQuartz%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E6%A1%86%E6%9E%B6%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Quartz是什么？Quartz是一个任务调度框架！Quartz是一个任务调度框架!!Quartz是一个任务调度框架!!! 为什么使用Quartz？你可能遇到这样的问题： 想每月25号，信用卡自动还款 想每年4月1日自己给当年暗恋女神发一封匿名贺卡 想每隔1小时，备份一下自己的学习笔记到云盘 这些问题总结起来就是：在某一个有规律的时间点干某件事。并且时间的触发的条件可以非常复杂（比如每月最后一个工作日的17:50），复杂到需要一个专门的框架来干这个事。 Quartz就是来干这样的事，你给它一个触发条件的定义，它负责到了时间点，触发相应的Job起来干活。 搭建一个简单demo？maven导入jar包123456789101112&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.quartz-scheduler&lt;/groupId&gt; &lt;artifactId&gt;quartz&lt;/artifactId&gt; &lt;version&gt;2.2.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.quartz-scheduler&lt;/groupId&gt; &lt;artifactId&gt;quartz-jobs&lt;/artifactId&gt; &lt;version&gt;2.2.1&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 编写测试用例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package top.miao;import static org.quartz.JobBuilder.newJob;import static org.quartz.SimpleScheduleBuilder.simpleSchedule;import static org.quartz.TriggerBuilder.newTrigger;import org.quartz.JobDetail;import org.quartz.Scheduler;import org.quartz.Trigger;import org.quartz.impl.StdSchedulerFactory;/** * @author zhangmiao3 * @Description: quartz测试 * @date 11:47 2018/5/30 */public class QuartzTest &#123; public static void main(String[] args) &#123; try &#123; //创建scheduler Scheduler scheduler = StdSchedulerFactory.getDefaultScheduler(); /* 定义一个Trigger 1、定义name/group 2、一旦加入scheduler，立即生效 3、使用SimpleTrigger 4、一直执行，奔腾到老不停歇 */ Trigger trigger = newTrigger().withIdentity("trigger1", "group1") .startNow() .withSchedule(simpleSchedule() .withIntervalInSeconds(1) .repeatForever()) .build(); /* 定义一个JobDetail 1、定义Job类为HelloQuartz类，这是真正的执行逻辑所在 2、定义name/group 3、定义属性 */ JobDetail job = newJob(HelloQuartz.class) .withIdentity("job1", "group1") .usingJobData("name", "quartz") .build(); //加入这个调度 scheduler.scheduleJob(job, trigger); //启动之 scheduler.start(); //运行一段时间后关闭 Thread.sleep(10000); scheduler.shutdown(true); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 123456789101112131415161718192021package top.miao;import java.util.Date;import org.quartz.Job;import org.quartz.JobDetail;import org.quartz.JobExecutionContext;/** * @author zhangmiao3 * @Description: * @date 11:49 2018/5/30 */public class HelloQuartz implements Job &#123; @Override public void execute(JobExecutionContext context) &#123; JobDetail detail = context.getJobDetail(); String name = detail.getJobDataMap().getString(&quot;name&quot;); System.out.println(&quot;say hello to &quot; + name + &quot; at &quot; + new Date()); &#125;&#125; 运行结果 job每秒执行一次 分析说明这个例子很好的覆盖了Quartz最重要的3个基本要素： Scheduler：调度器。所有的调度都是由它控制。 Trigger： 定义触发的条件。例子中，它的类型是SimpleTrigger，每隔1秒中执行一次（什么是SimpleTrigger下面会有详述）。 JobDetail &amp; Job： JobDetail 定义的是任务数据，而真正的执行逻辑是在Job中，例子中是HelloQuartz。 为什么设计成JobDetail + Job，不直接使用Job？这是因为任务是有可能并发执行，如果Scheduler直接使用Job，就会存在对同一个Job实例并发访问的问题。而JobDetail &amp; Job 方式，sheduler每次执行，都会根据JobDetail创建一个新的Job实例，这样就可以规避并发访问的问题。 参考： Quartz使用总结]]></content>
      <categories>
        <category>Quartz</category>
      </categories>
      <tags>
        <tag>Quartz</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring websocket使用总结]]></title>
    <url>%2F2018%2F05%2F29%2Fspring-websocket%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[最近使用了下websocket，总结下~ websocket原理概念WebSocket是HTML5提供的一种全双工通信的协议，通常是浏览器（或其他客户端）与Web服务器之间的通信。这使得它适合于高度交互的Web应用程序，如及时通讯聊天等。相比较于Http的短连接，Websocket的作用是可以保持长连接，也就是服务器也能够向客户端发送信息。从而实现了全双工通讯。 具体原理可以参考：阮一峰的websocket原理讲解 实现websocket客户端的两种方式js实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;script type="text/javascript"&gt; var websocket = null; //判断当前浏览器是否支持WebSocket if ('WebSocket' in window) &#123; //websocket协议格式用ws / wss(加密)开始，可以类比http协议 websocket = new WebSocket("ws://localhost:8088/ws/api/audiostream?appkey=zzzz&amp;lan=zh&amp;trans=0"); //连接成功建立的回调方法 websocket.onopen = function () &#123; //给ws服务端发送消息 websocket.send("客户端链接成功"); websocket.send("Hello"); &#125; //接收到消息的回调方法 websocket.onmessage = function (event) &#123; //处理接收到的消息 doSomething(event.data); &#125; //连接发生错误的回调方法 websocket.onerror = function () &#123; alert("WebSocket连接发生错误"); &#125;; //连接关闭的回调方法 websocket.onclose = function () &#123; alert("WebSocket连接关闭"); &#125; //监听窗口关闭事件，当窗口关闭时，主动去关闭websocket连接，防止连接还没断开就关闭窗口，server端会抛异常。 window.onbeforeunload = function () &#123; closeWebSocket(); &#125; &#125; else &#123; alert('当前浏览器 Not support websocket') &#125; //处理消息 function doSomething(innerHTML) &#123; //...... &#125; //关闭WebSocket连接 function closeWebSocket() &#123; websocket.close(); &#125;&lt;/script&gt; java实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465import org.java_websocket.client.WebSocketClient;import org.java_websocket.drafts.Draft_17;import org.java_websocket.WebSocket.READYSTATE;import org.java_websocket.handshake.ServerHandshake;public class WebSocketClientTest &#123; public static WebSocketClient client; public static void main(String[] args) throws URISyntaxException, NotYetConnectedException, UnsupportedEncodingException, InterruptedException &#123; // new Draft_17()一定要加上 client = new WebSocketClient(new URI("ws://localhost:8088/ws/api/audiostream?appkey=zzzz&amp;lan=zh&amp;trans=0"), new Draft_17()) &#123; @Override public void onOpen(ServerHandshake serverHandshake) &#123; System.out.println("打开链接"); &#125; @Override public void onMessage(String arg0) &#123; System.out.println("收到消息:" + arg0); &#125; @Override public void onError(Exception arg0) &#123; arg0.printStackTrace(); System.out.println("发生错误已关闭"); &#125; @Override public void onClose(int arg0, String arg1, boolean arg2) &#123; System.out.println("链接已关闭"); &#125; @Override public void onMessage(ByteBuffer bytes) &#123; try &#123; System.out.println(new String(bytes.array(), "utf-8")); &#125; catch (UnsupportedEncodingException e) &#123; e.printStackTrace(); &#125; &#125; &#125;; client.connect(); while (!client.getReadyState().equals(READYSTATE.OPEN)) &#123; System.out.println("还没有打开"); &#125; System.out.println("打开了"); //发送json文本信息 sendTextMessage(JSON.toJSONString("hello")); //发送二进制信息 sendByte("".getBytes()); &#125; public static void sendByte(byte[] bytes) &#123; client.send(bytes); &#125; public static void sendTextMessage(String jsonString) &#123; client.send(jsonString); &#125;&#125; 用spring websocket处理websocket客户端发送过来的信息导入 maven jar包12345&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-websocket&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;&lt;/dependency&gt; 添加配置类12345678910111213141516171819202122232425262728@Configuration@EnableWebSocketpublic class WebSocketConfig implements WebSocketConfigurer &#123; @Override public void registerWebSocketHandlers(WebSocketHandlerRegistry registry) &#123; // 注册拦截器 // 注册webSocket url和处理器映射关系 registry.addHandler(audioStreamWebSocketHandler(), &quot;/ws/audiostream&quot;) .addHandler(audioStreamOpenApiWebSocketHandler(), &quot;/ws/api/audiostream&quot;) .addInterceptors(myAudioStreamInterceptor()); &#125; @Bean public AudioStreamWebSocketHandler audioStreamWebSocketHandler() &#123; return new AudioStreamWebSocketHandler(); &#125; @Bean public AudioStreamOpenApiWebSocketHandler audioStreamOpenApiWebSocketHandler() &#123; return new AudioStreamOpenApiWebSocketHandler(); &#125; @Bean public AudioStreamWebSocketHandshakeInterceptor myAudioStreamInterceptor() &#123; return new AudioStreamWebSocketHandshakeInterceptor(); &#125;&#125; 配置拦截器和处理器123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// 拦截器public class AudioStreamWebSocketHandshakeInterceptor implements HandshakeInterceptor &#123; private static final Logger LOGGER = Logger.getLogger(AudioStreamWebSocketHandshakeInterceptor.class); //握手前处理请求 @Override public boolean beforeHandshake(ServerHttpRequest request, ServerHttpResponse response, WebSocketHandler wsHandler, Map&lt;String, Object&gt; attributes) throws Exception &#123; if (request instanceof ServletServerHttpRequest) &#123; ServletServerHttpRequest serverHttpRequest = (ServletServerHttpRequest) request; ServletServerHttpResponse serverHttpResponse = (ServletServerHttpResponse) response; // 转化为servlet request和response HttpServletRequest servletRequest = serverHttpRequest.getServletRequest(); HttpServletResponse servletResponse = serverHttpResponse.getServletResponse(); // 获取http session HttpSession httpSession = servletRequest.getSession(); String uri = servletRequest.getRequestURI(); if (&quot;/ws/api/audiostream&quot;.equals(uri)) &#123; String appkey = servletRequest.getParameter(&quot;appkey&quot;); String lan = servletRequest.getParameter(&quot;lan&quot;); String trans = servletRequest.getParameter(&quot;trans&quot;); if (StringUtils.isBlank(appkey) || StringUtils.isBlank(lan) || StringUtils.isBlank(trans)) &#123; LOGGER.error(&quot;直播ws开放接口传参错误！&quot;); return false; &#125; attributes.put(&quot;appkey&quot;, appkey); attributes.put(&quot;lan&quot;, lan); attributes.put(&quot;trans&quot;, trans); &#125; else if (&quot;/ws/audiostream&quot;.equals(uri)) &#123; String liveId = servletRequest.getParameter(&quot;liveId&quot;); if (StringUtils.isBlank(liveId)) &#123; LOGGER.error(&quot;直播id不能为空！&quot;); return false; &#125; attributes.put(&quot;liveId&quot;, liveId); &#125; else &#123; return false; &#125; &#125; return true; &#125; @Override public void afterHandshake(ServerHttpRequest request, ServerHttpResponse response, WebSocketHandler wsHandler, Exception exception) &#123; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667public class AudioStreamWebSocketHandler extends TextWebSocketHandler &#123; // 监听连接状态 @Override public void afterConnectionEstablished(WebSocketSession session) throws Exception &#123; System.out.println("websocket建立连接成功") &#125; // 处理接收到的文本信息 @Override public void handleTextMessage(WebSocketSession session, TextMessage message) &#123; if (!session.isOpen()) return; System.out.println("收到的文本信息为: " + message.getPayload()); &#125; // 判断心跳，检查服务器状态 @Override protected void handlePongMessage(WebSocketSession session, PongMessage message) throws Exception &#123; if (!session.isOpen()) return; super.handlePongMessage(session, message); &#125; // 处理接收到的二进制信息 @Override protected void handleBinaryMessage(WebSocketSession session, BinaryMessage message) &#123; if (!session.isOpen()) return; ByteBuffer byteBuffer = message.getPayload(); byte[] data = byteBuffer.array(); System.out.println("收到的二进制消息为: " + data) &#125; // 监听连接异常信息 @Override public void handleTransportError(WebSocketSession session, Throwable exception) throws Exception &#123; if (session.isOpen()) &#123; session.close(); &#125; System.out.println("websocket连接出错！"); &#125; // 监听连接关闭信息 @Override public void afterConnectionClosed(WebSocketSession session, CloseStatus status) throws Exception &#123; if (status.getCode() == MyCloseStatus.LIVE_REPEATABLE_ERROR.getCode() || status.getCode() == MyCloseStatus.LIVE_END_NORMALLY.getCode() || status.getCode() == MyCloseStatus.LIVE_STATUS_ERROR.getCode()) &#123; return; &#125; // 处理一些释放资源操作 .............. &#125; // 发送消息返回给客户端 public void sendMessage(WebSocketSession session, String message) &#123; if (session.isOpen()) &#123; try &#123; session.sendMessage(new TextMessage(message)); &#125; catch (IOException e) &#123; LOGGER.error("发送消息失败", e); &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>websocket</category>
      </categories>
      <tags>
        <tag>websocket</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo博客搭建]]></title>
    <url>%2F2018%2F04%2F29%2Fhexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[1、搭建博客 软件安装(git、nodejs、github配置、hexo安装、域名配置) 参数设置（具体参数设置参考Hexo官方文档） 主题配置 2、Next主题个性化 3、安装Hexo-admin方便管理博客 4、利用分支策略来实现多机编辑博客 5、给域名添加https(小绿锁) 博客效果如下：]]></content>
      <categories>
        <category>搭博客</category>
      </categories>
      <tags>
        <tag>Hexo博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql必知必会读书笔记]]></title>
    <url>%2F2018%2F04%2F25%2Fmysql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[基本知识 关系数据库设计把数据存储在多个表中，使数据更容易操纵、维护和重用。不用深究如何以及为什么进行关系数据库设计，在某种程度上说，设计良好的数据库模式都是关联的。 help show | select | update …; 查看相关命令的帮助 MySql语句都以（；）结尾。（多条SQL语句必须以分号（；）分隔。 MySQL如同多数DBMS一样，不需要在单条SQL语句后加分号。但特定的DBMS可能必须在单条SQL语句后加上分号。当然，如果愿意可以总是加上分号。事实上，即使不一定需要，但加上分号肯定没有坏处。如果你使用的是mysql命令行，必须加上分号来结束SQL语句。） 对所有SQL关键字使用大写，而对所有列和表名使用小写。（SQL语句不区分大小写，因此SELECT与select是相同的。同样，写成Select也没有关系。许多SQL开发人员喜欢对所有SQL关键字使用大写，而对所有列和表名使用小写，这样做使代码更易于阅读和调试。） 将SQL语句分成多行更容易阅读和调试。（使用空格 在处理SQL语句时，其中所有空格都被忽略。 SQL语句可以在一行上给出，也可以分成许多行。多数SQL开发人员认为将SQL语句分成多行更容易阅读和调试。） 连接MySQL数据库1mysql –u用户名 [–h主机名或者IP地址] –p密码 说明：用户名是你登录的用户，主机名或者IP地址为可选项，如果是本地连接则不需要，远程连接需要填写，端口默认是3306，否则需要填写端口号，密码是对应用户的密码。 注意： 该命令是在Windows命令行窗口下执行，而不是MySQL的命令行； 输入-p后可以直接跟上密码，也可以按回车，会提示你输入密码，二者都是相同的效果； –p密码选项不一定是要在最后； –u、-h、-p后无空格。 数据库基本操作选择数据库12345678USE 数据库名; ``` 注意： 必须先使用USE打开数据库，才能读取其中的数据。#### 2. 显示数据库和表```SQLSHOW DATABASES; 说明：返回可用数据库的一个列表。包含在这个列表中的可能有MySQL内部使用的数据库。 1SHOW TABLES; 说明：返回当前选择的数据库内可用表的列表。 12SHOW COLUMNS FROM 表名; DESCRIBE 表名;（更快捷的方式） 说明：要求给出一个表名，它对每个字段返回一行，行中包含字段名、数据类型、是否允许NULL、键信息、默认值以及其他信息。 数据查询1SELECT 列名 FROM 表名; 说明：上述语句利用SELECT语句从表中检索一列。所需的列名在SELECT关键字之后给出， FROM关键字指出从其中检索数据的表名。 注意：如果没有明确排序查询结果，则返回的数据的顺序没有特殊意义。返回数据的顺序可能是数据被添加到表中的顺序，也可能不是。只要返回相同数目的行，就是正常的。 1SELECT 列名1, 列名2, 列名3 FROM 表名; 说明：这条语句使用SELECT语句从表中选择数据。在这个例子中，指定了3个列名，列名之间用逗号分隔。 1SELECT * FROM 表名; 说明：如果给定一个通配符（*），则返回表中所有列。列的顺序一般是列在表定义中出现的顺序。但有时候并不是这样的，表的模式的变化（如添加或删除列）可能会导致顺序的变化。 注意： 一般，除非你确实需要表中的每个列，否则最好别使用*通配符。虽然使用通配符可能会使你自己省事，不用明确列出所需列，但检索不需要的列通常会降低检索和应用程序的性能。 使用通配符有一个大优点。由于不明确指定列名（因为星号检索每个列），所以能检索出名字未知的列。 1SELECT DISTINCT 列名 FROM 表名; 说明：SELECT DISTINCT列名告诉MySQL只返回不同（唯一）的对应列名的行，去掉重复行，如果使用DISTINCT关键字，它必须直接放在列名的前面。 注意：不能部分使用DISTINCT，DISTINCT关键字应用于所有列而不仅是前置它的列。如果给出SELECT DISTINCT 列1,列2，除非指定的两个列都不同，否则所有行都将被检索出来。 12SELECT 列名 FROM 表名 LIMIT 5, 5; SELECT 列名 FROM 表名 LIMIT 5; 说明： LIMIT 5, 5指示MySQL返回从行5开始的5行。第一个数为开始位置，第二个数为要检索的行数。 LIMIT 5 指示MySQL返回不多于5行。 注意： 行0检索出来的第一行为行0而不是行1。因此，LIMIT 1, 1将检索出第二行而不是第一行。 在行数不够时，LIMIT中指定要检索的行数为检索的最大行数。如果没有足够的行（例如，给出LIMIT 10, 5，但只有13行），MySQL将只返回它能返回的那么多行。 1SELECT 表名.列名 FROM 数据库名.表名; 说明：指定了一个完全限定的列名和表名。 排序查询数据1SELECT 列名 FROM 表名 ORDER BY 列名; 说明：将输出的结果根据列进行排序。 注意：通过非选择列进行排序。通常，ORDER BY子句中使用的列将是为显示所选择的列。但是，实际上并不一定要这样，用非检索的列排序数据是完全合法的。 1SELECT 列名1, 列名2, 列名3 FROM 表名 ORDER BY 列名1, 列名2; 说明：上面的代码将检索3个列，并按其中两个列对结果进行排序，首先按列1，然后再按列2排序。 1SELECT 列名1, 列名2, 列名3 FROM 表名 ORDER BY 列名1 DESC, 列名2 ; 说明：DESC关键字只应用到直接位于其前面的列名。在上例中，只对列名1指定DESC，对列名2不指定。因此，列名1以降序排序，而列名2（在每个价格内）仍然按标准的升序排序。 注意：在多个列上降序排序，如果想在多个列上进行降序排序，必须对每个列指定DESC关键字。 应用：使用ORDER BY和LIMIT的组合，能够找出一个列中最高或最低的值。 1SELECT prod_price FROM products ORDER BY prod_price DESC LIMIT 1; 分析：prod_price DESC保证行是按照由最昂贵到最便宜检索的，而LIMIT 1告诉MySQL仅返回一行。 过滤查询数据123SELECT 列名1, 列名2 FROM 表名 WHERE 列名 [ = | &lt; | &lt;= | &gt; | &gt;= | &lt;&gt; | != ] 值; SELECT 列名1, 列名2 FROM 表名 WHERE 列名 BETWEEN 值1 AND 值2; SELECT 列名1, 列名2 FROM 表名 WHERE 列名 IS NULL; 说明：单引号用来限定字符串。如果将值与串类型的列进行比较，则需要限定引号。用来与数值列进行比较的值不用引号。 注意：不匹配不会返回空值（不匹配的前提表示有值，而NULL值根本就没有值，所以不会在有值的范围内，因此需要对无值进行单独处理。） 参考：过滤数据 复合的过滤查询数据123456SELECT 列名1, 列名2 FROM 表名 WHERE 条件1 AND 条件2; SELECT 列名1, 列名2 FROM 表名 WHERE 条件1 OR 条件2; SELECT 列名1, 列名2 FROM 表名 WHERE 条件1 OR 条件2 AND 条件3; SELECT 列名1, 列名2 FROM 表名 WHERE (条件1 OR 条件2) AND 条件3;SELECT 列名1, 列名2 FROM 表名 WHERE 列名 IN (值1,值2) ORDER BY 列名;SELECT 列名1, 列名2 FROM 表名 WHERE 列名 NOT IN (值1,值2) ORDER BY 列名; 说明： SQL（像多数语言一样）在处理OR操作符前，优先处理AND操作符。 IN操作符和OR操作符完成相同功能 IN 操作符的优点： 在使用长的合法选项清单时，IN操作符的语法更清楚且更直观。 在使用IN时，计算的次序更容易管理（因为使用的操作符更少）。 IN操作符一般比OR操作符清单执行更快。 IN的最大优点是可以包含其他SELECT语句，使得能够更动态地建立WHERE子句。 NOT操作符：对于简单的WHERE子句，使用NOT确实没有什么优势。但在更复杂的子句中，NOT是非常有用的。例如，在与IN操作符联合使用时，NOT使找出与条件列表不匹配的行非常简单。 通配符过滤查询数据1SELECT 列名1, 列名2 FROM 表名 WHERE 列名 LIKE 'jet%'; 说明：在执行这条子句时，将检索任意以jet起头的词。 1SELECT 列名1, 列名2 FROM 表名 WHERE 列名 LIKE '_ ton anvil'; 说明：在执行这条子句时，将检索任意以一个字符开头， ton anvil结尾的词。 通配符：%： 代表搜索模式中给定位置的0个、1个或多个字符。_ : 与%能匹配0个字符不一样，_总是匹配一个字符，不能多也不能少。 注意： MySQL的通配符很有用。但是通配符搜索的处理一般要比前面讨论的其他搜索所花时间更长。 根据MySQL的配置方式，搜索可以是区分大小写的。如果区分大小写，’jet%’与JetPack 1000将不匹配。 技巧： 不要过度使用通配符。如果其他操作符能达到相同的目的，应该使用其他操作符。 在确实需要使用通配符时，除非绝对有必要，否则不要把它们用在搜索模式的开始处。把通配符置于搜索模式的开始处，搜索起来是最慢的。 仔细注意通配符的位置。如果放错地方，可能不会返回想要的数 正则表达式说明： 当出现复杂的过滤条件时，可以使用正则表达式。 所有种类的程序设计语言、文本编辑器、操作系统等都支持正则表达式。 MySQL仅支持多数正则表达式实现的一个很小的子集。 1SELECT prod_name FROM products WHERE prod_name REGEXP '.000' ORDER BY prod_name; 结果：JetPack 1000JetPack 2000 分析：这里使用了正则表达式.000。 .是正则表达式语言中一个特殊的字符。它表示匹配任意一个字符，因此， 1000和2000都匹配且返回。 LIKE与REGEXP区别： LIKE匹配整个列。如果被匹配的文本在列值中出现，LIKE将不会找到它，相应的行也不被返回（除非使用通配符）。 REGEXP在列值内进行匹配，如果被匹配的文本在列值中出现，REGEXP将会找到它，相应的行将被返回。这是一个非常重要的差别。 注意：MySQL中的正则表达式匹配（自版本3.23.4后）不区分大小写（即，大写和小写都匹配）。为区分大小写，可使用BINARY关键字，如WHERE prod_name REGEXP BINARY ‘JetPack .000’。 OR 匹配等价‘1 | 2’ 匹配含1或2的字符串‘[123]’ 匹配含1或2或3的字符串‘[^123]’ 非123其中的字符 范围匹配[1-3] [6-9] [a-z] 匹配特殊字符‘\\.’用来匹配. 说明：多数正则表达式实现使用单个反斜杠转义特殊字符，以便能使用这些字符本身。但MySQL要求两个反斜杠（ MySQL自己解释一个，正则表达式库解释另一个）。 匹配多个实例 符号 说明 * 0个或多个匹配 + 1个或多个匹配（等于{1,}） ? 0个或1个匹配（等于{0,1}） {n} 指定数目的匹配 {n,} 不少于指定数目的匹配 匹配特定位置 符号 说明 ^ 文本的开始 + 文本的结尾 [[:&lt;:]] 词的开始 [[:&gt;:]] 词的结尾 创建计算字段（别名）说明：计算字段并不实际存在于数据库表中。计算字段是运行时在SELECT语句内创建的。 拼接字段（Concat()） 注意：多数DBMS使用+或||来实现拼接，MySQL则使用Concat()函数来实现。当把SQL语句转换成MySQL语句时一定要把这个区别铭记在心。 删除多余空格LTrim() 删除左边空格RTrim() 删除右边空格Trim() 同时删除左右空格 AS 别名 实例：12SELECT prod_id, quantity, item_price, quantity * item_price AS expanded_price FROM orderitems WHERE order_num = 200005; 高级查询 分组查询 1SELECT cust_id, COUNT(*) AS orders FROM orders GROUP BY cust_id HAVING COUNT(*) &gt;= 2; 说明：通过GROUP BY关键字来分组，同时将分组后的数据通过HAVING关键字来过滤查询数据。 SELECT子句顺序 子句 说明 是否必须使用 SELECT 要返回的列或表达式 是 FROM 从中检索的数据表 仅在从表选择数据时使用 WHERE 行级过滤 否 GROUP BY 分组说明 仅在按组计算聚集时使用 HAVING 组级过滤 否 ORDER BY 输出排序顺序 否 LIMIT 要检索的行数 否 子查询 123SELECT cust_name, cust_contact FROM customers WHERE cust_id IN (SELECT cust_id FROM orders WHERE order_num IN (SELECT order_num FROM orderitems WHERE prod_id = 'TNT2')); 说明：为了执行上述SELECT语句， MySQL实际上必须执行3条SELECT语句。最里边的子查询返回订单号列表，此列表用于其外面的子查询的WHERE子句。外面的子查询返回客户ID列表，此客户ID列表用于最外层查询的WHERE子句。最外层查询确实返回所需的数据。 联结查询1) 内部联结123SELECT vend_name, prod_name, prod_price FROM vendors INNER JOIN products ON vendors.vend_id = products.vend_id; 说明：这里，两个表之间的关系是FROM子句的组成部分，以INNER JOIN指定。在使用这种语法时，联结条件用特定的ON子句而不是WHERE子句给出。传递给ON的实际条件与传递给WHERE的相同。（无法检索出含有空的信息）。 2) 外部联结定义：联结包含了那些在相关表中没有关联行的行。这种类型的联结称为外部联结。12SELECT customers.cust_id, orders.order_num FROM customers LEFT OUTER JOIN orders ON customers.cust_id = orders.cust_id; 说明：在使用OUTER JOIN语法时，必须使用RIGHT或LEFT关键字指定包括其所有行的表（RIGHT指出的是OUTER JOIN右边的表，而LEFT指出的是OUTER JOIN左边的表）。 3) 自联结 1234SELECT p1.prod_id, p1.prod_nameFROM products AS p1, products AS p2WHERE p1.vend_id = p2.vend_idAND p2.prod_id = 'DTNTR'; 说明： 此查询中需要的两个表实际上是相同的表，因此products表在FROM子句中出现了两次。虽然这是完全合法的，但对products的引用具有二义性，因为MySQL不知道你引用的是products表中的哪个实例。（也可以用子查询实现） 4) 自然联结定义：自然联结排除多次出现，使每个列只返回一次。123456SELECT c.*, o.order_num, o.order_date,oi.prod_id, oi.quantity, OI.item_priceFROM customers AS c, orders AS o, orderitems AS oiWHERE c.cust_id = o.cust_idAND oi.order_num = o.order_numAND prod_id = 'FB'; 说明：在这个例子中，通配符只对第一个表使用。所有其他列明确列出，所以没有重复的列被检索出来。 高级联结（博客帮助理解） 5) 组合查询1234567SELECT vend_id, prod_id, prod_priceFROM productsWHERE prod_price &lt;= 5UNION SELECT vend_id, prod_id, prod_priceFROM productsWHERE vend_id IN (1001, 1002); 说明：UNION指示MySQL执行两条SELECT语句，并把输出组合成单个查询结果集。对于更复杂的过滤条件，或者从多个表（而不是单个表）中检索数据的情形，使用UNION可能会使处理更简单。注意：返回重复行，可使用UNION ALL而不是UNION。 6) 全文本搜索 性能相比一般通配符，正则表达式效率要高。 可以将搜索出来的结果按照更好的匹配来排列它们，还可以匹配出不包含该词，但是包含其它词的记录。 插入数据1234567891011121314151617INSERT INTO customers( cust_name, cust_email, cust_address, cust_city, cust_state, cust_zip, cust_country)VALUES( 'Pep E. LaPew', NULL, NULL, '100 Main Street', 'Los Angeles', 'CA', '90046', 'USA'); 说明：总是使用列的列表一般不要使用没有明确给出列的列表的INSERT语句。使用列的列表能使SQL代码继续发挥作用，即使表结构发生了变化。 注意：INSERT操作可能很耗时（特别是有很多索引需要更新时），而且它可能降低等待处理的SELECT语句的性能。如果数据检索是最重要的（通常是这样），则可以通过在INSERT和INTO之间添加关键字LOW_PRIORITY，指示MySQL降低INSERT语句的优先级。这也适合于UPDATE 和 DELETE 语句。 更新数据123UPDATE customers SET cust_email = 'elmer@fudd.com'WHERE cust_id = 1005; 说明：UPDATE语句以WHERE子句结束，它告诉MySQL更新哪一行。没有WHERE子句，MySQL将会用这个电子邮件地址更新customers表中所有行。 注意： 为了删除某个列的值，可设置它为NULL（假如表定义允许NULL值） 在更新多个列时，只需要使用单个SET命令，每个“列=值”对之间用逗号分隔（最后一列之后不用逗号）。 删除数据12DELETE FROM customers WHERE cust_id = 10006; 注意： ELETE不需要列名或通配符。DELETE删除整行而不是删除列。为了删除指定的列，请使用UPDATE语句。 如果想从表中删除所有行，不要使用DELETE。可使用TRUNCATETABLE语句，它完成相同的工作，但速度更快（ TRUNCATE实际是删除原来的表并重新创建一个表，而不是逐行删除表中的数据）。 表操作创建表12345678910111213CREATE TABLE customers( cust_id int NOT NULL AUTO_INCREMENT, cust_name char(50) NOT NULL, cust_address char(50) NULL, cust_city char(50) NULL, cust_state char(5) NULL, cust_zip char(10) NULL, cust_country char(50) NULL, cust_contact char(50) NULL, cust_email char(255) NULL, PRIMARY KEY (cust_id)) ENGINE=InnoDB; 注意：在创建新表时，指定的表名必须不存在，否则将出错。如果要防止意外覆盖已有的表，SQL要求首先手工删除该表（请参阅后面的小节），然后再重建它，而不是简单地用创建表语句覆盖它。 更新表12ALTER TABLE vendorsADD vend_phone CHAR(20); 说明：这条语句给vendors表增加一个名为vend_phone的列，必须明确其数据类型。 12ALTER TABLE vendorsDROP COLUMN vend_phone; 说明：删除某列。 ALTER TABLE的一种常见用途是定义外键123ALTER TABLE orderitemsADD CONSTRAINT fk_orderitems_ordersFOREIGN KEY (order_num) REFERENCES orders (order_num); 说明：对单个表进行多个更改，可以使用单条ALTER TABLE语句，每个更改用逗号分隔。 删除表1DROP TABLE customers2; 说明：这条语句删除customers2表（假设它存在）。删除表没有确认，也不能撤销，执行这条语句将永久删除该表。 重命名表1RENAME TABLE customers2 TO customers; 说明：将表customers2 重命名为customers. 视图定义：视图是虚拟的表。与包含数据的表不一样，视图只包含使用时动态检索数据的查询。 视图用CREATE VIEW语句来创建。 使用SHOW CREATE VIEW viewname；来查看创建视图的语句。 用DROP删除视图，其语法为DROP VIEW viewname;。 更新视图时，可以先用DROP再用CREATE，也可以直接用CREATE OR REPLACE VIEW。如果要更新的视图不存在，则第2条更新语句会创建一个视图；如果要更新的视图存在，则第2条更新语句会替换原有视图。 视图的最常见的应用之一是隐藏复杂的SQL，这通常都会涉及联结。 12345CREATE VIEW productcustomers ASSELECT cust_name, cust_contact, prod_idFROM customers, orders, orderitemsWHERE customers.cust_id = orders.cust_idAND orderitems.order_num = orders.order_num; 说明：这条语句创建一个名为productcustomers的视图，它联结三个表，以返回已订购了任意产品的所有客户的列表。如果执行SELECT * FROM productcustomers，将列出订购了任意产品的客户。 存储过程（函数）定义： 存储过程简单来说，就是为以后的使用而保存的一条或多条MySQL语句的集合。可将其视为批文件，虽然它们的作用不仅限于批处理。 创建存储过程 1） 简化版本 12345CREATE PROCEDURE productpricing()BEGIN SELECT Avg(prod_price) AS priceaverage FROM products;END; 说明: 在MySQL处理这段代码时，它创建一个新的存储过程productpricing。没有返回数据，因为这段代码并未调用存储过程，这里只是为以后使用而创建它。 注意：如果是命令行实用程序要解释存储过程自身内的 ; 字符，它们不会成为存储过程的一部分，会出现语法错误。 可以如下操作(临时更改分隔符）：123456789DELIMITER //CREATE PROCEDURE productpricing()BEGIN SELECT Avg(prod_price) AS priceaverage FROM products;END //DELIMITER ; 注意： 除\符号外，任何字符都可以用作语句分隔符。 2) 带参数版本 12345678910111213141516CREATE PROCEDURE productpricing( OUT p1 DECIMAL(8,2), OUT ph DECIMAL(8,2), OUT pa DECIMAL(8,2))BEGIN SELECT Min(prod_price) INTO p1 FROM products; SELECT Max(prod_price) INTO ph FROM products; SELECT Avg(prod_price) INTO pa FROM products;END; 说明： 此存储过程接受3个参数： pl存储产品最低价格， ph存储产品最高价格， pa存储产品平均价格。每个参数必须具有指定的类型，这里使用十进制值。关键字OUT指出相应的参数用来从存储过程传出一个值（返回给调用者）。MySQL支持IN（传递给存储过程）、 OUT（从存储过程传出，如这里所用）和INOUT（对存储过程传入和传出）类型的参数。存储过程的代码位于BEGIN和END语句内，如前所见，它们是一系列SELECT语句，用来检索值，然后保存到相应的变量（通过指定INTO关键字） 删除存储过程1DROP PROCEDURE productpricing; 注意： 这条语句删除刚创建的存储过程。请注意没有使用后面的()，只给出存储过程名。 当过程存在想删除它时（如果过程不存在也不产生错误）可使用DROP PROCEDURE IF EXISTS。 执行存储过程1CALL productpricing(@pricelow, @pricehigh, @priceaverage); 说明： 由于此存储过程要求3个参数，因此必须正好传递3个参数，不多也不少。所以，这条CALL语句给出3个参数。它们是存储过程将保存结果的3个变量的名字。 注意： 所有MySQL变量都必须以@开始。 游标来源：使用简单的SELECT语句，例如，没有办法得到第一行、下一行或前10行，也不存在每次一行地处理所有行的简单方法（相对于成批地处理它们）。有时，需要在检索出来的行中前进或后退一行或多行。这就是使用游标的原因。 定义：就自己的理解是，游标相当于一个指针，用来灵活的处理从表中查询出来的数据，通常是与存储过程结合起来一起使用的。 创建游标123456CREATE PROCEDURE productpricing()BEGIN DECLARE ordernumbers CURSOR FOR SELECT order_num FROM orders;END; 打开和关闭游标12345-- 打开游标OPEN ordernumbers;-- 关闭游标CLOSE rodernumbers; 游标使用可参考: 游标的具体使用详解 触发器来源：想要某条语句（或某些语句）在事件发生时自动执行。定义：触发器是MySQL响应以下任意语句而自动执行的一条MySQL语句（语句执行之前或者之后）（或位于BEGIN和END语句之间的一组语句）。仅支持： DELETE INSERT UPDATE 其他MySQL语句不支持触发器。 注意： 在MySQL 5中，触发器名必须在每个表中唯一，但不是在每个数据库中唯一。 现在最好是在数据库范围内使用唯一的触发器名。 12CREATE TRIGGER newproduct AFTER INSERT ON productsFOR EACH ROW SELECT 'Product added'; 说明：对每个成功的插入，控制台都会显示Product added信息。 各语句具体使用查阅相关资料。 事务管理定义： 事务处理是一种机制，用来管理必须成批执行的MySQL操作，以保证数据库不包含不完整的操作结果。 说明：利用事务处理，可以保证一组操作不会中途停止，它们或者作为整体执行，或者完全不执行（除非明确指示）。如果没有错误发生，整组语句提交给（写到）数据库表。如果发生错误，则进行回退（撤销）以恢复数据库到某个已知且安全的状态。 MyISAM引擎不支持事务处理 InnoDB引擎支持事务处理 基本术语： 事务（transaction）指一组SQL语句； 回退（rollback）指撤销指定SQL语句的过程； 提交（commit）指将未存储的SQL语句结果写入数据库表； 保留点（savepoint）指事务处理中设置的临时占位符（placeholder），你可以对它发布回退（与回退整个事务处理不同）。 12-- 事务开始START TRANSACTION 1234567-- 回退事务SELECT * FROM ordertotals;START TRANSACTION;DELETE FROM ordertotals;SELECT * FROM ordertotals;ROLLBACK;SELECT * FROM ordertotals; 说明： 首先执行一条SELECT以显示该表不为空。然后开始一个事务处理，用一条DELETE语句删除ordertotals中的所有行。另一条SELECT语句验证ordertotals确实为空。这时用一条ROLLBACK语句回退START TRANSACTION之后的所有语句，最后一条SELECT语句显示该表不为空。 注意： ROLLBACK只能在一个事务处理内使用（在执行一条START TRANSACTION命令之后）。 事务处理用来管理INSERT、 UPDATE和DELETE语句。你不能回退SELECT语句。（这样做也没有什么意义。）你不能回退CREATE或DROP操作。事务处理块中可以使用这两条语句，但如果你执行回退，它们不会被撤销。 12345-- 提交事务START TRANSACTION;DELETE FROM orderitems WHERE order_num = 2010;DELETE FROM orders WHERE order_num = 20010;COMMIT; 说明：在这个例子中，从系统中完全删除订单20010。因为涉及更新两个数据库表orders和orderItems，所以使用事务处理块来保证订单不被部分删除。最后的COMMIT语句仅在不出错时写出更改。如果第一条DELETE起作用，但第二条失败，则DELETE不会提交（实际上，它是被自动撤销的）。 注意： 一般MySQL语句的使用都是隐含提交的，但是在事务处理中，提交不会隐含进行，需要使用COMMIT语句。 当COMMIT或ROLLBACK语句执行后，事务会自动关闭（将来的更改会隐含提交）。 12345-- 保留点-- 设置保留点SAVEPOINT delete1;-- 事务回退到保留点ROLLBACK TO delete1; 说明：为了支持回退部分事务处理，必须能在事务处理块中合适的位置放置占位符。这样，如果需要回退，可以回退到某个占位符。 注意：保留点在事务处理完成（执行一条ROLLBACK或COMMIT）后自动释放。 12-- 设置数据库不默认提交SET autocommit=0; 说明：autocommit标志决定是否自动提交更改，不管有没有COMMIT语句。设置autocommit为0（假）指示MySQL不自动提交更改（直到autocommit被设置为真为止） 注意： autocommit标志是针对每个连接而不是服务器的。 用户管理12-- 创建用户账号CREATE USER ben IDENTIFIED BY '123456'; 说明：创建用户名为 ‘ben’, 密码为 ‘123456’的用户。 用户的账号信息存储在Mysql.user表中。 1234-- 重命名用户RENAME USER ben TO bforta;-- 删除用户账号DROP USER bforta; 123456-- 显示用户的权限信息SHOW GRANTS FOR bforta;-- 此GRANT允许用户在crashcourse.*（crashcourse数据库的所有表）上使用SELECT。在所有表中只有只读访问权限。GRANT SELECT ON crashcourse.* TO bforta;-- 撤销特定访问权限REVOKE SELECT ON crashcourse.* FROM bforta; 1234-- 修改bforta账户密码SET PASSWORD FOR bforta = Password('root');-- 修改登录账户密码SET PASSWORD = Password('root');]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis基本操作]]></title>
    <url>%2F2018%2F04%2F20%2FRedis%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[Redis简介Redis是一个速度非常快的非关系数据库（non-relational database），它可以存储键（key）与5种不同类型的值（value）之间的映射（mapping），可以将存储在内存的键值对数据持久化到硬盘，可以使用复制特性来扩展读性能，还可以使用客户端分片来扩展写性能 与关系数据库对比Redis属于人们常说的NoSQL数据库或者非关系数据库：Redis不使用表，它的数据库也不会预定义或者强制去要求用户对Redis存储的不同数据进行关联。 与memcached对比这两者都可用于存储键值映射，彼此的性能也相差无几，但是Redis能够自动以两种不同的方式将数据写入硬盘，并且Redis除了能存储普通的字符串键之外，还可以存储其他4种数据结构，而memcached只能存储普通的字符串键。这些不同之处使得Redis可以用于解决更为广泛的问题，并且既可以用作主数据库（primary database）使用，又可以作为其他存储系统的辅助数据库（auxiliary database）使用。 Redis安装配置(windows版本)下载地址 (Redis-x64-xxx.zip) 打开cmd窗口必须切换到存放Redis原文件的目录下（可以将目录设置到环境变量中），并运行如下命令来启动服务端1redis-server.exe redis.windows.conf 打开另一个cmd窗口切换到对应目录下运行如下命令（若设置了环境变量则不需要切换目录），就可以访问服务端了。1redis-cli.exe -h 127.0.0.1 -p 6379 Redis命令 连接远程redis服务12345678//host:主机名 port:端口名 password:密码$ redis-cli -h host -p port -a password//默认连接本机，等同于下一条命令$ redis-cli$ redis-cli -h 127.0.0.1 -p 6379 -a &quot;mypass&quot;redis 127.0.0.1:6379&gt;redis 127.0.0.1:6379&gt; PINGPONG PING命令用于检测redis服务是否启动。 数据类型 Redis字符串(String)（命令手册）1234567//语法redis 127.0.0.1:6379&gt; COMMAND KEY_NAME//实例redis 127.0.0.1:6379&gt; SET runoobkey redisOKredis 127.0.0.1:6379&gt; GET runoobkey&quot;redis&quot; Redis哈希(Hash)（命令手册） 说明：Redis hash 是一个string类型的field和value的映射表，hash特别适合用于存储对象。Redis 中每个 hash 可以存储 232 - 1 键值对（40多亿）。1234567891011121314//runoobkey为键名，后面的数据都是一对一对存储的，比如name和&quot;redis tutorial&quot;是一对键值对127.0.0.1:6379&gt; HMSET runoobkey name &quot;redis tutorial&quot; description &quot;redis basic commands for caching&quot; likes 20 visitors 23000OK//显示所有hash中的所有数据127.0.0.1:6379&gt; HGETALL runoobkey1) &quot;name&quot;2) &quot;redis tutorial&quot;3) &quot;description&quot;4) &quot;redis basic commands for caching&quot;5) &quot;likes&quot;6) &quot;20&quot;7) &quot;visitors&quot;8) &quot;23000&quot; Redis列表(List)（命令手册）说明： Redis列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素导列表的头部（左边）或者尾部（右边）一个列表最多可以包含 232 - 1 个元素 (4294967295, 每个列表超过40亿个元素)。 12345678910111213//在runoobkey头插入值（LPUSH在头部插入，RPUSH在尾部插入）redis 127.0.0.1:6379&gt; LPUSH runoobkey redis(integer) 1redis 127.0.0.1:6379&gt; LPUSH runoobkey mongodb(integer) 2redis 127.0.0.1:6379&gt; LPUSH runoobkey mysql(integer) 3//返回第1个元素到第11个元素区间内的值redis 127.0.0.1:6379&gt; LRANGE runoobkey 0 101) &quot;mysql&quot;2) &quot;mongodb&quot;3) &quot;redis&quot; Redis集合(Set)（命令手册）说明：Redis的Set是string类型的无序集合。集合成员是唯一的，这就意味着集合中不能出现重复的数据。Redis中集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)。集合中最大的成员数为 232 - 1 (4294967295, 每个集合可存储40多亿个成员)。 123456789101112131415//向集合添加一个成员redis 127.0.0.1:6379&gt; SADD runoobkey redis(integer) 1redis 127.0.0.1:6379&gt; SADD runoobkey mongodb(integer) 1redis 127.0.0.1:6379&gt; SADD runoobkey mysql(integer) 1redis 127.0.0.1:6379&gt; SADD runoobkey mysql(integer) 0//返回集合中的所有成员redis 127.0.0.1:6379&gt; SMEMBERS runoobkey1) &quot;mysql&quot;2) &quot;mongodb&quot;3) &quot;redis&quot; Redis有序集合(sorted set)（命令手册）说明：Redis 有序集合和集合一样也是string类型元素的集合,且不允许重复的成员。不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。有序集合的成员是唯一的,但分数(score)却可以重复。集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)。 集合中最大的成员数为 232 - 1 (4294967295, 每个集合可存储40多亿个成员)。 123456789101112131415161718redis 127.0.0.1:6379&gt; ZADD runoobkey 1 redis(integer) 1redis 127.0.0.1:6379&gt; ZADD runoobkey 2 mongodb(integer) 1redis 127.0.0.1:6379&gt; ZADD runoobkey 3 mysql(integer) 1redis 127.0.0.1:6379&gt; ZADD runoobkey 3 mysql(integer) 0redis 127.0.0.1:6379&gt; ZADD runoobkey 4 mysql(integer) 0redis 127.0.0.1:6379&gt; ZRANGE runoobkey 0 10 WITHSCORES1) &quot;redis&quot;2) &quot;1&quot;3) &quot;mongodb&quot;4) &quot;2&quot;5) &quot;mysql&quot;6) &quot;4&quot; Redis HyperLogLog1) Redis 在 2.8.9 版本添加了 HyperLogLog 结构。2) Redis HyperLogLog 是用来做基数统计的算法，HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定 的、并且是很小的。在 Redis 里面，每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基 数。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比。3) 因为HyperLogLog只会根据输入元素来计算基数，而不会储存输入元素本身，所以 HyperLogLog 不能像集合那样，返回输入的各个元素。 说明：基数：集合中不同元素的数量。比如 {‘apple’, ‘banana’, ‘cherry’, ‘banana’, ‘apple’} 的基数就是3。估算值：算法给出的基数并不是精确的，可能会比实际稍微多一些或者稍微少一些，但会控制在合理的范围之内。 12345678910//向HyperLogLog中添加元素redis 127.0.0.1:6379&gt; PFADD runoobkey &quot;redis&quot;1) (integer) 1redis 127.0.0.1:6379&gt; PFADD runoobkey &quot;mongodb&quot;1) (integer) 1redis 127.0.0.1:6379&gt; PFADD runoobkey &quot;mysql&quot;1) (integer) 1//统计基数的数量redis 127.0.0.1:6379&gt; PFCOUNT runoobkey(integer) 3 Redis发布订阅发布订阅—菜鸟教程 Redis事务Redis事务—菜鸟教程 Java使用RedisJava使用Redis—菜鸟教程]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Memcached基本操作]]></title>
    <url>%2F2018%2F04%2F10%2FMemcached%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[Memcached简介Memcached是一个自由开源的，高性能，分布式内存对象缓存系统。 Memcached是一种基于内存的key-value存储，用来存储小块的任意数据（字符串、对象）。这些数据可以是数据库调用、API调用或者是页面渲染的结果。 本质上，它是一个简洁的key-value存储系统。 一般的使用目的是，通过缓存数据库查询结果，减少数据库访问次数，以提高动态Web应用的速度、提高可扩展性。 Memcached安装配置Memcached安装配置—菜鸟教程1234567891011//注意：路径对应修改为自己的安装路径//安装和卸载memcached服务c:\memcached\memcached.exe -d installc:\memcached\memcached.exe -d uninstall//启动和关闭memcached服务c:\memcached\memcached.exe -d startc:\memcached\memcached.exe -d stop//-m 512 意思是设置 memcached 最大的缓存配置为512M。c:\memcached\memcached.exe -d runservice -m 512//该命令可以用来查看命令帮助和参数配置c:\memcached\memcached.exe -h Memcached 连接1234//执行任何命令时需要先启动memcached服务(路径对应修改为自己的安装路径)c:\memcached\memcached.exe -d start//telnet HOST PORT --------- HOST：主机名 PORT：端口telnet 127.0.0.1 11211 Memcached 存储命令1. set命令123//语法set key flags exptime bytes [noreply] value 参数说明：key：键值 key-value 结构中的 key，用于查找缓存值。flags：可以包括键值对的整型参数，客户机使用它存储关于键值对的额外信息。exptime：在缓存中保存键值对的时间长度（以秒为单位，0 表示永远）bytes：在缓存中存储的字节数noreply（可选）： 该参数告知服务器不需要返回数据value：存储的值（始终位于第二行）（可直接理解为key-value结构中的value） 例子：123456789set runoob 0 900 9memcachedSTOREDget runoobVALUE runoob 0 9memcachedEND 说明：12345key → runoobflag → 0exptime → 900 (以秒为单位)bytes → 9 (数据存储的字节数)value → memcached 输出：12//数据设置成功STORED 输出信息说明：12STORED：保存成功后输出。ERROR：在保持失败后输出。 2. add命令123//语法add key flags exptime bytes [noreply]value 参数说明：key：键值 key-value 结构中的 key，用于查找缓存值。flags：可以包括键值对的整型参数，客户机使用它存储关于键值对的额外信息。exptime：在缓存中保存键值对的时间长度（以秒为单位，0 表示永远）bytes：在缓存中存储的字节数noreply（可选）： 该参数告知服务器不需要返回数据value：存储的值（始终位于第二行）（可直接理解为key-value结构中的value） 例子：1234567add new_key 0 900 10data_valueSTOREDget new_keyVALUE new_key 0 10data_valueEND 说明：12345key → new_keyflag → 0exptime → 900 (以秒为单位)bytes → 10 (数据存储的字节数)value → data_value 输出：12//数据设置成功STORED 输出信息说明：12STORED：保存成功后输出。NOT_STORED ：在保持失败后输出。 3. replace命令123//语法replace key flags exptime bytes [noreply]value 参数说明：key：键值 key-value 结构中的 key，用于查找缓存值。flags：可以包括键值对的整型参数，客户机使用它存储关于键值对的额外信息。exptime：在缓存中保存键值对的时间长度（以秒为单位，0 表示永远）bytes：在缓存中存储的字节数noreply（可选）： 该参数告知服务器不需要返回数据value：存储的值（始终位于第二行）（可直接理解为key-value结构中的value） 例子：12345678910111213add mykey 0 900 10data_valueSTOREDget mykeyVALUE mykey 0 10data_valueENDreplace mykey 0 900 16some_other_valueget mykeyVALUE mykey 0 16some_other_valueEND 说明：12345key → mykeyflag → 0exptime → 900 (以秒为单位)bytes → 10 (数据存储的字节数)value → data_value 输出：12//数据设置成功STORED 输出信息说明：12STORED：保存成功后输出。NOT_STORED ：在保持失败后输出。 4. append命令(prepend在键值的前面追加数据)123//语法append key flags exptime bytes [noreply]value 参数说明：key：键值 key-value 结构中的 key，用于查找缓存值。flags：可以包括键值对的整型参数，客户机使用它存储关于键值对的额外信息。exptime：在缓存中保存键值对的时间长度（以秒为单位，0 表示永远）bytes：在缓存中存储的字节数noreply（可选）： 该参数告知服务器不需要返回数据value：存储的值（始终位于第二行）（可直接理解为key-value结构中的value） 例子：1234567891011121314set runoob 0 900 9memcachedSTOREDget runoobVALUE runoob 0 9memcachedENDappend runoob 0 900 5redisSTOREDget runoobVALUE runoob 0 14memcachedredisEND 说明： 首先我们在 Memcached 中存储一个键 runoob，其值为 memcached。然后，我们使用 get 命令检索该值。然后，我们使用 append 命令在键为 runoob 的值后面追加 “redis”。最后，我们再使用 get 命令检索该值。 输出：12//数据设置成功STORED 输出信息说明：123STORED：保存成功后输出。NOT_STORED：该键在 Memcached 上不存在。CLIENT_ERROR：执行错误。 5. CAS命令说明：Memcached CAS（Check-And-Set 或 Compare-And-Swap） 命令用于执行一个”检查并设置”的操作它仅在当前客户端最后一次取值后，该key 对应的值没有被其他客户端修改的情况下， 才能够将值写入。检查是通过cas_token参数进行的，这个参数是Memcach指定给已经存在的元素的一个唯一的64位值。 123//语法cas key flags exptime bytes unique_cas_token [noreply]value 参数说明：key：键值 key-value 结构中的 key，用于查找缓存值。flags：可以包括键值对的整型参数，客户机使用它存储关于键值对的额外信息。exptime：在缓存中保存键值对的时间长度（以秒为单位，0 表示永远）bytes：在缓存中存储的字节数unique_cas_token通过 gets 命令获取的一个唯一的64位值。noreply（可选）： 该参数告知服务器不需要返回数据value：存储的值（始终位于第二行）（可直接理解为key-value结构中的value） 例子：要在 Memcached 上使用 CAS 命令，你需要从 Memcached 服务商通过 gets 命令获取令牌（token）。gets 命令的功能类似于基本的 get 命令。两个命令之间的差异在于，gets 返回的信息稍微多一些：64 位的整型值非常像名称/值对的 “版本” 标识符。123456789101112131415161718192021222324cas tp 0 900 9ERROR &lt;− 缺少 tokencas tp 0 900 9 2memcachedNOT_FOUND &lt;− 键 tp 不存在set tp 0 900 9memcachedSTOREDgets tpVALUE tp 0 9 1memcachedENDcas tp 0 900 5 1redisSTOREDget tpVALUE tp 0 5redisEND 说明： 如果没有设置唯一令牌，则 CAS 命令执行错误。如果键 key 不存在，执行失败。添加键值对。通过 gets 命令获取唯一令牌。使用 cas 命令更新数据。使用 get 命令查看数据是否更新。 输出：12//数据设置成功STORED 输出信息说明：1234STORED：保存成功后输出。ERROR：保存出错或语法错误。EXISTS：在最后一次取值后另外一个用户也在更新该数据。NOT_FOUND：Memcached 服务上不存在该键值。 Memcached 查找命令1. get命令说明：Memcached get 命令获取存储在 key(键) 中的 value(数据值) ，如果 key 不存在，则返回空。1234//语法get key//多个 key 使用空格隔开get key1 key2 key3 参数说明：key：键值 key-value 结构中的 key，用于查找缓存值。 例子：1234567set runoob 0 900 9memcachedSTOREDget runoobVALUE runoob 0 9memcachedEND 说明：使用 runoob 作为 key，过期时间设置为 900 秒。 2. gets命令Memcached gets 命令获取带有 CAS 令牌存 的 value(数据值) ，如果 key 不存在，则返回空。1234//语法get key//多个 key 使用空格隔开get key1 key2 key3 参数说明：key：键值 key-value 结构中的 key，用于查找缓存值。 例子：1234567set runoob 0 900 9memcachedSTOREDgets runoobVALUE runoob 0 9 1memcachedEND 说明：在使用gets命令的输出结果中，在最后一列的数字1代表了key为runoob的CAS令牌。 3. delete命令Memcached delete 命令用于删除已存在的 key(键)。12//语法delete key [noreply] 参数说明：key：键值 key-value 结构中的 key，用于查找缓存值。noreply（可选）： 该参数告知服务器不需要返回数据。 例子：12345678910111213set runoob 0 900 9memcachedSTOREDget runoobVALUE runoob 0 9memcachedENDdelete runoobDELETEDget runoobENDdelete runoobNOT_FOUND 说明：使用runoob作为key，过期时间设置为900秒。之后我们使用delete命令删除该key。 输出信息说明：123DELETED：删除成功。ERROR：语法错误或删除失败。NOT_FOUND：key不存在。 3. incr / decr 命令Memcached incr 与 decr 命令用于对已存在的 key(键) 的数字值进行自增或自减操作。incr与decr命令操作的数据必须是十进制的32位无符号整数。如果key不存在返回NOT_FOUND，如果键的值不为数字，则返回 CLIENT_ERROR，其他错误返回 ERROR。12//语法incr key increment_value 参数说明：key：键值 key-value 结构中的 key，用于查找缓存值。increment_value： 增加的数值。 例子：12345678910111213set visitors 0 900 210STOREDget visitorsVALUE visitors 0 210ENDincr visitors 515get visitorsVALUE visitors 0 215END 说明：使用 visitors 作为 key，初始值为 10，之后进行加 5 操作。 输出信息说明：123NOT_FOUND：key 不存在。CLIENT_ERROR：自增值不是对象。ERROR其他错误，如语法错误等。 decr命令与此类似 Memcached 统计命令1. Memcached stats 命令说明：Memcached stats 命令用于返回统计信息例如 PID(进程号)、版本号、连接数等。12//语法stats 2. Memcached stats items命令说明：Memcached stats items 命令用于显示各个slab中 item的数目和存储时长(最后一次访问距离现在的秒数)。12//语法stats items 3. Memcached stats slabs命令说明：Memcached stats slabs 命令用于显示各个slab的信息，包括chunk的大小、数目、使用情况等。12//语法stats slabs Memcached stats sizes命令说明：Memcached stats sizes 命令用于显示所有item的大小和个数。该信息返回两列，第一列是item的大小，第二列是item的个数。12//语法stats sizes 例子：123stats sizesSTAT 96 1END 4. Memcached flush_all 命令说明：Memcached flush_all 命令用于用于清理缓存中的所有 key=&gt;value(键=&gt;值) 对。该命令提供了一个可选参数 time，用于在制定的时间后执行清理缓存操作。12//语法flush_all [time] [noreply] 例子：1234567891011set runoob 0 900 9memcachedSTOREDget runoobVALUE runoob 0 9memcachedENDflush_allOKget runoobEND Java连接Memcached服务Java连接Memcached服务—菜鸟教程]]></content>
      <categories>
        <category>memcached</category>
      </categories>
      <tags>
        <tag>memcached</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HeadFirst设计模式读书笔记]]></title>
    <url>%2F2018%2F03%2F30%2FHeadFirst%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[设计模式（原则） 将设计模式装进大脑里，然后在你的设计和已有的应用中，寻找何处可以使用它们。以往是代码复用，现在是经验复用。 设计原则1：封装变化。找出应用中可能需要变化之处，把它们独立出来，不需要和那些不需要变化的代码混合在一起。（将会变化的部分取出并“封装”起来，好让其他部分不会受到影响。 设计原则2：针对接口编程，而不是针对实现编程。（“针对接口编程”的真正意思是“针对超类型（supertype）编程”，超类型可以是抽象类“或”接口。 设计原则3：多用组合，少用继承。 设计原则4：为了交互对象之间的松耦合设计而努力。（松耦合设计能让我们建立有弹性的OO系统，能够应对变化，因为对象之间的互相依赖降到了最低水平。） 设计原则5：类应该对扩展开放，对修改关闭。（我们的目标是允许类容易扩展，在不修改现有代码的情况下，就可以搭配新的行为。这样的设计具有弹性可以应付改变，可以接受新的功能来应对改变的需求） 设计原则6：要依赖抽象，不要依赖具体类。（不让高层组件依赖低层组件，而且，不管高层或低层组件，“两者”都应该依赖于抽象）。 设计原则7：最少知识原则：只和你的密友交谈。（在设计中，不要让太多的类耦合在一起，免得修改系统中一部分，会影响到其他部分。）关键：不要调用从另一个调用中返回的对象的方法，也就是不要向另一个对象的子部分发请求。 设计原则8：好莱坞原则。（别调用（打电话给）我们，我们会调用（打电话给）你）。 注意： 有一些面向对象的原则，适用于所有的模式。当无法找到合适的模式来解决问题时，采用这些原则可以达到目的。 在设计模式中，“实现一个接口”并“不一定”表示“写一个类，并利用implement关键词来实现某个java接口”。“实现一个接口”泛指“实现某个超类型（可以是类或接口）的某个方法”。 策略(Strategy)模式 定义： 定义了算法簇，分别将其封装起来，让它们之间可以相互替换，该模式让算法的变化独立于使用算法的客户。（当需要给朋友留下深刻的印象，或者想影响关键主管的决策时，可以使用“这个”定义。） 抽象方法的作用：在该类中不用实现它，或者说在该类中不确定该如何实现它，它是用来被重载的方法。（比如有一个鸭子类，它的外观都不相同，display()方法可以定义为抽象的） 当涉及“维护”时，为了“复用”（reuse)目的而使用继承，结果并不好。（比如当在父类鸭子中加入fly()方法时，那些不会飞的鸭子（橡皮鸭）也会同时继承）。 当使用Flyable接口来实现时(只有会飞的鸭子才能继承Flyable接口），可以解决上面问题，但是又会导致代码无法复用的问题。 实例代码—-&gt;headfirst/strategy 菜鸟教程策略模式 观察者(Observer)模式注意：当试图使用观察者模式时，可以比拟出版者和订阅者的关系。 定义：定义了对象之间的一对多的依赖关系，这样一来，当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新。 观察者模式有两种实现方式： 自己实现Subject接口和Observer类。 java.util包内有最基本的Obserer(Subject)接口与Observable(Observer)类，（同时提供了推(push)和拉(pull)两种方式来传送数据）。push方式被认为更正确。 注意： 不要依赖观察者被通知的次序。（java自带的观察者模式，Observable是一个类，它会自己实现notifyObservers()方法，该方法会自定义其观察者的顺序） 应用：在JavaBeans和Swing中也使用了观察者模式。实例代码—-&gt;headfirst/observer菜鸟教程观察者模式 装饰者(Decorator)模式 定义：动态地将责任附加到对象上。若要扩展功能，装饰者提供了比继承更有弹性的替代方案。 注意： 通常装饰者模式采用抽象类，但是在java中可以使用接口。应用： 在java I/O中使用了装饰者设计模式。 实例代码—-&gt;headfirst/decorator菜鸟教程装饰者模式 工厂(Factory)模式应用： Collection中的iterator方法 JDBC数据库开发 简单工厂注意：简单工厂不是一个设计模式，它更像是一种编程习惯。 静态工厂： 利用静态方法定义一个简单工厂。 优点：不需要使用创建对象的方法来实例化对象。缺点：不能通过继承来改变创建方法的行为。（因为静态方法只和类相关，不能通过继承来重写该方法）。实例代码—-&gt;headfirst/factory/pizzas菜鸟教程工厂模式 工厂方法 定义：定义一个创建对象的接口，但是由子类决定要实例化的类是哪一个。工厂方法让类把实例化推迟到子类。（所谓的“决定”，并不是指模式允许子类本身在运行时做出决定，而是指在编写创建者类时，不需要知道实际创建的产品是哪一个。）实例代码—-&gt;headfirst/factory/pizzafm菜鸟教程工厂模式 抽象工厂 定义：提供一个接口，用于创建相关或依赖对象的家族，而不需要明确的指定具体类。 实例代码—-&gt;headfirst/factory/pizzaaf菜鸟教程抽象工厂模式 要点： 所有的工厂都是用来封装对象的创建。 简单工厂，虽然不是真正的设计模式，但依然是一个简单的方法，将客户程序从具体类中解耦。 工厂方法使用继承：把对象的创建委托给子类，子类实现工厂方法来创建对象。 抽象工厂使用对象组合：对象的创建被实现在工厂接口所暴露出来的方法中。 所有工厂模式都通过减少应用程序和具体类之间的依赖促进松耦合。 工厂方法允许类将实例化延迟到子类中进行。 抽象工厂创建相关的对象家族，而不需要依赖它们的具体类。 依赖倒置原则，指导我们避免依赖具体类型，而要尽量依赖抽象。 工厂是很有威力的技巧，帮助我们针对抽象编程，而不要针对具体类编程。单件模式 定义：确保一个类只有一个实例，并提供一个全局访问点。（注意处理多线程的情况） 饿汉式: 类一加载就创建对象懒汉式: 用的时候才去创建对象 应用：Runtime类中提供了饿汉式单例模式，jdk都是用饿汉式，我们开发时就要使用饿汉式（单面试的时候面试官叫你写一个单例模式那你要写懒汉式，因为他要考你的是线多程安全问题）实例代码—-&gt;headfirst/singleton菜鸟教程单例模式 适配器模式 定义：将一个类的接口，转换成客户期望的另一各接口。适配器让原本接口不兼容的类可以合作无间。 使用场景：当需要使用一个现有的类而其接口并不符合你的需要时，就使用适配器。 注意：适配器模式有两种形式，对象适配器和类适配器。而类适配器需要用到多重继承。 应用：将Enumeration(旧世界的枚举类)适配到Iterator（新世界的迭代器）。实例代码—-&gt;headfirst/adapter菜鸟教程适配器模式 外观模式 定义：提供了一个统一的接口，用来访问子系统中的一群接口。外观定义了一个高层接口，让子系统更容易使用。 使用场景：当需要简化并统一一个很大的接口或者一群复杂的接口时，使用外观。 实例代码—-&gt;headfirst/facade菜鸟教程外观模式 对比： 适配器将一个对象包装起来以改变其接口； 装饰者将一个对象包装起来以增加新的行为和责任； 外观将一群对象包装起来以简化其接口。 模板方法模式 定义：在一个方法中定义一个算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤。 注意： 为防止恶意操作，一般模板方法都加上 final 关键词。 策略模式和模板方法模式都封装算法，一个用组合，一个用继承。 工厂方法是模板方法的一种特殊版本。 钩子：钩子是一种被声明在抽象类中的方法，但只有空的或者默认的实现。 使用场景： Arrays.sort()排序算法（利用Comparable接口） Swing窗口程序 Applet 实例代码—-&gt;headfirst/templatemethod菜鸟教程模板方法模式]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java多线程基础]]></title>
    <url>%2F2018%2F03%2F25%2FJava%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[线程和进程的区别联系进程：操作系统运行中的程序（进程和程序的区别是程序只是一个静态的指令集合，而进程则是系统中一个活动的指令集合，加入了时间）。 线程：进程能够执行多项任务，而每一项任务就相当于一个线程。 进程之间不能共享资源，但是线程之间可以共享资源。 并发性和并行性区别并行: 有多条指令在多个处理器上同时执行。 并发: 同一时刻只有一条指令执行，但是多个进程指令会被快速轮换执行，使得看起来好像有多个进程在同时执行。 创建线程的方式1） 继承Thread类来创建线程类，然后要重写run()方法。 2）实现Runnable接口来创建线程类，然后实现run()方法，将创建的实现Runnable接口的对象作为Thread的target。 3）实现Callable接口，功能是Runnable的增强版本（java5之后提供）。接口中定义的方法有返回值，可以抛出异常。 实现Runnable或Callable接口优点： 1）线程类只是实现了Runnable接口或Callable接口，它依然还可以继承其他类。 2）多个线程可以同时共享一个target对象，十分适合多个相同线程来处理同一份资源。 缺点： 编码可能较为复杂，如果要访问当前线程的话，则必须要使用Thread.currentThread()方法。 继承Thread类优点： 程序编写起来简单，如果需要访问当前线程的话，不用使用Thread.currentThread()方法，直接使用this即可。 缺点： 线程类以及继承了Thread类，不能再继承其他父类了。 线程的生命周期线程5种状态： 1）new(创建)：线程通过new方法创建。 2）Runnable(就绪)：当线程调用start()方法，线程进入就绪状态，等待系统调度。 3）Running(运行): 当系统调度时，线程进入运行状态。 4）Blocked(阻塞): 一个正在运行的线程因某些原因不能继续运行时，它就进入阻塞状态。 5）Dead(死亡)：线程正常结束或异常退出。 线程阻塞的几种情形： 1）处于运行状态的线程若遇到sleep()方法，则线程进入睡眠状态，不会让出资源锁，sleep()方法结束，线程转为就绪状态，等待系统重新调度。2）处于运行状态的线程可能在等待io，也可能进入挂起状态。io完成，转为就绪状态。3）处于运行状态的线程调用yield()方法，线程转为就绪状态。（yield只让给权限比自己高的）。4）处于运行状态的线程遇到wait()方法（object的方法），线程处于等待状态，需要notify()/notifyALL()来唤醒线程，唤醒后的线程处于锁定状态，获取了“同步锁”，之后，线程才转为就绪状态。5）处于运行的线程synchronized，加上后变成同步操作。处于锁定状态，获取了“同步锁”，之后，线程才转为就绪状态。 线程控制1）join()方法（Thread类提供的静态方法） java 线程方法join的简单总结说明：让一个线程等待另一个线程执行完成。当前线程必须等待调用join()方法的线程执行完成后，才能继续向下执行。 2）sleep()方法（Thread类提供的静态方法）说明：暂停当前线程，并进入阻塞状态，这时，如果有其它线程，则其它线程会执行。 3）yield()方法（Thread类提供的静态方法）说明：暂停当前线程，将当前线程转入就绪状态，不是阻塞状态，这时只有大于等于当前线程优先级状态的线程才能获得从就绪状态转入运行状态的机会。 线程同步同步代码块 12345//格式synchronized(obj) &#123; ...... //此处代码为同步代码块代码&#125; 说明：上面格式中的obj就是同步监视器。当线程开始执行同步代码块之前，必须先得到同步监视器的锁定。这样可以保证同一时刻只有一个线程能执行当前代码，从而保证线程安全。 同步方法 1234//格式public synchronized void draw() &#123; ......&#125; 说明：对synchronized修饰的实例方法（非static方法）来说，不需要显示的指定同步监视器，同步方法的同步监视器是this，也就是调用该方法的对象。 释放同步监视器的时机： 1.）当前线程的同步方法、同步代码块执行结束，当前线程就会释放同步监视器。2）当前线程的同步方法、同步代码块出现了未处理的Error和Exception，导致代码块异常结束了。3）当前线程执行同步方法、同步代码块时，程序执行了同步监视器对象的wait()方法，则当前线程暂停，并释放同步监视器。 java中的synchronized（同步代码块和同步方法的区别） 同步锁Lock 通过显示定义同步锁对象来实现同步，此时同步锁是由Lock对象来充当。（java5之后实现） 常用： ReentrantLock（可重入锁）123456789101112131415161718//格式class X &#123; //定义锁对象 private final ReentrantLock lock = new ReentrantLock(); //... //定义需要保证线程安全的方法 public void m() &#123; //加锁 lock.lock(); try &#123; //需要保证线程安全的代码 //...method body &#125; finally &#123; lock.unlock(); &#125; &#125;&#125; 优点：使用同步锁Lock比同步方法和同步代码块更加灵活！ 死锁 两个线程相互等待对方释放同步监视器时就会发生死锁。 死锁很容易发生，特别是在系统中出现了多个同步监视器的情况下。 线程间通讯传统线程通讯（对应同步代码块和同步方法情况）调用Object类的wait()、notify()、notifyAll()方法来实现线程间通讯，这三个方法是jvm中的native方法。 wait(): 调用某个对象的wait()方法能让当前线程阻塞，并且当前线程必须拥有此对象的monitor（即锁） notify(): 调用某个对象的notify()方法能够唤醒一个正在等待这个对象的monitor的线程，如果有多个线程都在等待这个对象的monitor，则只能唤醒其中一个线程；。 notifyAll(): 调用notifyAll()方法能够唤醒所有正在等待这个对象的monitor的线程； 注意： 一个线程被唤醒不代表立即获取了对象的monitor，只有等调用完notify()或者notifyAll()并退出synchronized块，释放对象锁后，其余线程才可获得锁执行。 Condition（对应Lock的情况）（JDK1.5之后出现）Condition类中提供了await()、signal()、signalAll()方法来对应wait()、notify()、notifyAll()方法，使用方法基本相同。 123456789101112//格式class X &#123; //定义锁对象 private final Lock lock = new ReentrantLock(); private final Condition cond = lock.newCondition(); .... cond.await(); cond.signal(); cond.signalAll();&#125; 相比使用Object的wait()、notify()，使用Condition的await()、signal()这种方式实现线程间协作更加安全和高效。 BlockingQueue（java5提供）它是Queue的子接口，作用不是作为容器，而是作为一个线程同步的工具。 特征： （经典的生产者消费者模型） 当生产者线程尝试向BlockingQueue中放入元素时，如果队列已经满了，那么线程就会被阻塞； 当消费者线程尝试向BlockingQueue中取出元素时，如果队列已空，那么线程也会被阻塞； 对应put()方法和take()方法。 线程池线程池原理 1）线程池能够提高系统性能 说明： 系统启动线程成本高，因为涉及到和操作系统的交互。这种情况下，使用线程池能够提高系统性能。特别是需要创建大量生存期比较短的线程时候，才更需要使用线程池。 2）线程池的最大线程数参数可以控制系统中并发线程数目不会超过设置的线程数 说明： 当系统中包含大量并发线程时，会导致系统性能剧烈下降，甚至导致JVM崩溃。 过程： 线程池在系统启动时就会创建大量空闲的线程，程序将一个Runnable对象或Callable对象传给线程池，则线程池就会启动一个线程来执行它们的run()或call()方法，当run()或call()方法执行结束之后，线程不会死亡，它会再次返回到线程池中从而成为空闲状态，等待下一个run()或call()方法。 Executors工厂类来产生线程池。 1234567891011121314151617public class ThreadPoolTest &#123; public static void main(String[] args) throws Exception &#123; //创建一个具有固定线程数(6)的线程池 ExecutorService pool = Executors.newFixedThreadPool(6); //使用Lambda表达式创建Runnable对象 Runnable target = () -&gt; &#123; for (int i = 0; i &lt; 100; i++) &#123; System.out.println(Thread.currentThread().getName() + "的i值为：" + i); &#125; &#125;; //向线程池中提交两个线程 pool.submit(target); pool.submit(target); //关闭线程池 pool.shutdown(); &#125; &#125; ThreadLocal类 线程局部变量（ThreadLocal）为每一个使用该变量的线程都提供一个变量值的副本，使每一个线程都可以独立地改变自己的副本，而不会和其他线程的副本冲突。 ThreadLocal类方法 : T get() : 取得当前线程副本数据值 void remove() ：删除当前线程副本数据值 void set(T value) ：设置当前线程副本数据的值 ThreadLocal类是从另一个角度来解决多线程的并发访问，ThreadLocal将需要并发访问的资源复制多份，每个线程拥有一份资源，每个线程都拥有自己的资源副本，从而也就没有必要对该变量进行同步了。 实用场景： 1）如果多个线程之间需要共享资源，来达到线程之间的通信功能，就使用同步机制。 2）如果只需要隔离多个线程之间的共享冲突，可以使用ThreadLocal。 Volatile关键字深入分析volatile的实现原理]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法]]></title>
    <url>%2F2018%2F03%2F15%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[控制台运行编译java程序带中文乱码问题解决办法： javac -encoding utf-8 Test.java 稳定性：排序算法需要保留数组中重复元素的相对位置。（具体详见算法第四版P217） 冒泡排序思想： 两两比较相邻记录的关键字，如果反序则交换，直到没有反序的记录为止。 时间复杂度： O(N2) 空间复杂度： O(1) 稳定性： 稳定 123456789101112131415public class Sort &#123; public static void sort(int[] nums) &#123; int N = nums.length; int temp = 0; for (int i = 0; i &lt; N-1; i++) &#123; for (int j = 0; j &lt; N-i-1; j++) &#123; if (nums[j] &gt; nums[j + 1]) &#123; temp = nums[j]; nums[j] = nums[j+1]; nums[j+1] = temp; &#125; &#125; &#125; &#125;&#125; 选择排序思想： 每一趟在n-i+1(i=1,2,…,n-1)个记录中选取关键字最小的记录作为有序序列的第i个记录。 时间复杂度： O(N2) 空间复杂度： O(1) 稳定性： 不稳定（说明：举个例子，序列5 8 5 2 9， 我们知道第一遍选择第1个元素5会和2交换，那么原序列中2个5的相对前后顺序就被破坏了，所以选择排序不是一个稳定的排序算法） 123456789101112131415161718public class Sort &#123; public static void sort(int[] nums) &#123; int N = nums.length; for (int i = 0; i &lt; N; i++ ) &#123; int min = i; for (int j = i+1; j &lt; N; j++) &#123; if (nums[j] &lt; nums[min]) &#123; min = j; &#125; &#125; if (min != i) &#123; temp = nums[i]; nums[i] = nums[min]; nums[min] = temp; &#125; &#125; &#125;&#125; 插入排序思想： 将一个记录插入到已经排序好的有序表中，从而得到一个新的、记录数增1的有序表 时间复杂度： O(N2) 空间复杂度： O(1) 稳定性： 稳定 12345678910111213public class Sort &#123; public static void sort(int[] nums) &#123; int N = nums.length; int temp = 0; for (int i = 1; i &lt; N; i++ ) &#123; for (int j = i; j &gt; 0 &amp;&amp; nums[j] &lt; nums[j-1]; j--) &#123; temp = nums[j]; nums[j] = nums[j+1]; nums[j+1] = temp; &#125; &#125; &#125;&#125; 改进版本 12345678910111213141516public class Sort &#123; public static void sort(int[] nums) &#123; int N = nums.length; int i = 0; int j = 0; for (i = 1; i &lt; N; i++) &#123; if (nums[i] &lt; nums[i-1]) &#123; int temp = nums[i]; for (j = i-1; (j &gt;= 0) &amp;&amp; (nums[j] &gt; temp); j--) &#123; nums[j+1] = nums[j]; &#125; nums[j+1] = temp; &#125; &#125; &#125;&#125; 希尔排序（插入排序升级）思想： 将数据分为若干组记录，然后分别对每一组做插入排序。 时间复杂度： O(NlgN) 空间复杂度： O(1) 稳定性： 不稳定 1234567891011121314151617181920212223242526public class Sort &#123; public static void sort(int[] nums) &#123; int N = nums.length; int temp = 0; int h = 1; int i = 0; int j = 0; //固定步长：1,4,13,40... while (h &lt; N/3) &#123; h = 3*h + 1; &#125; while (h &gt;= 1) &#123; //下面操作和插入排序算法基本相同 for (i = h; i &lt; N; i++) &#123; if (nums[i] &lt; nums[i - h]) &#123; int temp = nums[i]; for (j = i-h; (j &gt;= 0) &amp;&amp; (nums[j] &gt; temp); j = j-h) &#123; nums[j+h] = nums[j]; &#125; nums[j+h] = temp; &#125; &#125; h = h / 3; &#125; &#125;&#125; 快速排序（冒泡排序增强）思想： 选取一个轴值(比较的基准)，将待排序记录分为独立的两个部分，左侧记录都是小于或等于轴值，右侧记录都是大于或等于轴值，然后分别对左侧部分和右侧部分重复前面的过程，也就是左侧部分又选择一个轴值，又分为两个独立的部分，这就使用了递归了。到最后，整个序列就变得有序了。 时间复杂度： O(NlgN) 空间复杂度： O(lgN)~O(N) 稳定性： 不稳定 123456789101112131415161718192021222324252627282930313233343536373839public class Sort &#123; public static void sort(int[] nums) &#123; //消除对输入的依赖 //StdRandom.shuffle(a); sort(nums, 0, nums.length - 1); &#125; public static void sort (int[] nums, int lo, int hi) &#123; if (hi &lt;= lo) return; //切分 int j = partition(nums, lo, hi); sort(nums, lo, j-1); sort(nums, j+1, hi); &#125; public static int partition(int[] nums, int lo, int hi) &#123; //定义左右扫描的指针 int i = lo, j = hi + 1; //定义切分的元素d int point = nums[lo]; int temp = 0; while (true) &#123; while (nums[++i] &lt; point) if (i == hi) break; while (point &lt; nums[--j]) if (j == lo) break; if (i &gt;= j) break; //交换两个元素 temp = nums[i]; nums[i] = nums[j]; nums[j] = temp; &#125; //将切分元素放到数组中合适位置 temp = nums[lo]; nums[lo] = nums[j]; nums[j] = temp; return j; &#125;&#125; 堆排序（选择排序增强）思想： 利用优先队列的删除最大元素的特点，依次将将删除的最大元素保存起来，就有序了。当然，这里的优先队列是用堆实现的。 第一步：需要保证堆有序，也就是每一个父节点要比它的任意子节点要大； 第二步：使用堆的下沉操作来实现排序； 时间复杂度： O(NlgN) 空间复杂度： O(1) 稳定性： 不稳定 1234567891011121314151617181920212223242526272829303132333435363738public class Sort &#123; public static void heapSort(int[] a) &#123; int N = a.length; //第一步：通过下沉操作来实现堆有序，这里只需要操作数组中前面的一半元素即可 for (int k = N / 2; k &gt;= 1; k--) &#123; sink(a, k, N); &#125; //第二步：将堆有序的数组使用下沉操作来得到有序数组 while (N &gt; 1) &#123; exch(a, 1, N--); sink(a, 1, N); &#125; &#125; //堆下沉操作 public static void sink(int[] a, int k, int N) &#123; while (2*k &lt;= N) &#123; int j = 2*k; //取两个子节点中较大的一个 if (j &lt; N &amp;&amp; less(a, j, j+1)) j++; //比较如果父节点比子节点中较大的一个小，则交换 if (!less(a, k, j)) break; exch(a, k, j); //继续往下面遍历 k = j; &#125; &#125; //之所以取i-1，是因为堆中下标是从1开始的，需要还原到数组中从0开始的。 public static boolean less(int[] a, int i, int j) &#123; return a[i-1] &lt; a[j-1]; &#125; public static void exch(int[] a, int i, int j) &#123; int temp = a[i-1]; a[i-1] = a[j-1]; a[j-1] = temp; &#125; &#125; 归并排序思想： 要将一个数组排序，可以先（递归地）将它们分成两半分别排序，然后将它们的结果归并起来。 时间复杂度： O(NlgN) 空间复杂度： O(N) 稳定性： 稳定 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public class Sort &#123; //1.将两个有序数组合并为一个有序数组 public static void merge(int[] a, int lo, int mid, int hi) &#123; //将a[lo..mid] 和 a[mid+1..hi]归并 //i代表左半边索引，j代表右半边索引 int i = lo, j = mid + 1; //定义一个辅助数组 int[] aux; //将a[lo..hi]复制到aux[lo..hi] for (int k = lo; k &lt;= hi; k++) &#123; aux[k] = a[k]; &#125; for (int k = lo; k &lt;= hi; k++) &#123; //左半边元素用尽，取右半边的元素 if (i &gt; mid) &#123; a[k] = aux[j++]; //右半边元素用尽，取左半边元素 &#125; else if (j &gt; hi) &#123; a[k] = aux[i++]; //右半边的当前元素小于左半边的当前元素，则取右半边的元素 &#125; else if (aux[j] &lt; aux[i]) &#123; a[k] = aux[j++]; //左半边的当前元素小于等于右半边的当前元素，则取左半边的元素 &#125; else &#123; a[k] = aux[i++]; &#125; &#125; &#125; //自顶向下 pubic static void sort (int[] a, int lo, int hi) &#123; if (hi &lt;= lo) &#123; return; &#125; int mid = lo + (hi - lo) / 2; //将左半边排序 sort(a, lo, mid); //将右半部分排序 sort(a, mid+1, hi); //归并结果 merger(a, lo, mid, hi); &#125; //自底向上 public static void sort (int[] a) &#123; int N = a.length; int[] aux = new int[N]; //定义子数组的大小 for (int sz = 1; sz &lt; N; sz = sz + sz) &#123; //子数组的索引 for (int lo = 0; lo &lt; N-sz; lo += sz+sz) &#123; //lo+sz+sz-1可能越界，因此需要一个min函数来取边界 merge(a, lo, lo+sz-1, Math.min(lo+sz+sz-1, N-1)); &#125; &#125; &#125;&#125; 总结时间复杂度：O(N)计数排序、基数排序 O(N2)冒泡排序、选择排序、插入排序 O(NlogN)希尔排序、堆排序、快速排序、归并排序 空间复杂度：O(1)插入排序、选择排序、冒泡排序、堆排序、希尔排序 O(logN) ~ O(N)快速排序 O(N)归并排序 O(M) M为桶的数量计数排序、基数排序 稳定性： 稳定的排序算法：冒泡排序、插入排序、归并排序、计数排序、基数排序、桶排序 不稳定的排序算法：选择排序、快速排序、希尔排序、堆排序]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java虚拟机]]></title>
    <url>%2F2018%2F03%2F05%2FJava%E8%99%9A%E6%8B%9F%E6%9C%BA%2F</url>
    <content type="text"><![CDATA[先来一个JVM物理结构图，后面基本是围绕这个图来说明各个部分。 JVM五大区 程序计数器说明：当前线程所执行的字节码的行号指示器。 1）线程私有； 2）线程执行Java方法时，记录其正在执行的虚拟机字节码指令地址，线程执行Native方法时，计数器记录为空（Undefined）； 3）唯一在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域； 虚拟机栈说明：存放方法执行时所需的数据，其中每个方法为一个栈帧，存储了局部变量表（编译期间可以知道的各种基本数据类型和对象引用（不是对象本身））、操作数栈、动态链接等信息，方法的调用就对应了栈帧在虚拟机栈中的入栈和出栈的过程。 1）线程私有； 2）线程请求的栈深度如果大于虚拟机所允许的栈深度，将会抛出StackOverflowError异常； 3）如果虚拟机栈在动态扩展内存后依然不能申请到足够的内存，会抛出OutOfMemoryError异常； 本地方法栈说明：作用基本同本地方法栈，只是虚拟机栈是为虚拟机执行Java方法（也就是字节码）服务的，而本地方法栈却是为虚拟机使用到的Native（使用的编程语言不固定）方法服务的。 1）线程私有； 2）线程请求的栈深度如果大于虚拟机所允许的栈深度，将会抛出StackOverflowError异常； 3）如果虚拟机栈在动态扩展内存后依然不能申请到足够的内存，会抛出OutOfMemoryError异常； Java堆说明：存放对象的实例。 1） 所有线程共享； 2）Java堆是Java虚拟机所管理的内存中最大的一块； 3）垃圾收集器管理的主要区域，也称为GC堆； 4）如果在堆中内存不够无法完成实例的分配，并且堆无法在扩展时，就会抛出OutOfMemoryError异常； 方法区 （包括其中的运行时常量池）说明：用于存储运行时常量池、已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。 1）所有线程共享； 2）当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。 运行时常量池： 说明： Class文件中的常量池（不是运行时常量池），用来存放编译期生成的各种字面量和符号引用，而这部分内容将会在类加载之后进入方法区的运行时常量池中存放。 注意： 运行时常量池不一定就一定要从字节码常量池中拿取常量，可能在程序运行期间将新的常量放入池中，比如String.intern()方法，这个方法的作用就是：先从方法区的运行时常量池中查找看是否有该值，如果有，则返回该值的引用，如果没有，那么就会将该值加入运行时常量池中。 参考：Java垃圾收集算法 对象标记算法 垃圾回收器在对堆内存进行回收前，第一件事情就是要确定哪些对象还”存活”中，哪些对象已经”死去”。 引用计数法原理：给对象中添加一个引用计数器，每当有一个地方引用到它，计算器的值就加1，当引用失效的时候，计数器就减1，任何时刻计数器为0的对象就是没有被使用的对象，表示可以回收。 说明：这种方法在主流的虚拟机里面没有被采用，原因是它很难解决对象之间循环引用的问题。 可达性分析算法原理：通过一系列称为”GC Roots”的对象作为起始起点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连时，则证明此对象没有被使用，可以被回收。 四中引用 （参考：Java的四种引用方式）强引用 说明：是指创建一个对象并把这个对象赋给一个引用变量。 软引用（SoftReference） 说明：如果一个对象具有软引用，内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。 弱引用（WeakReference） 说明：弱引用也是用来描述非必需对象的，当JVM进行垃圾回收时，无论内存是否充足，都会回收被弱引用关联的对象。 虚引用 说明：它并不影响对象的生命周期，无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。 垃圾回收算法标记清除算法思路： 第一步：使用可达性分析算法将无用的对象标记出来； 第二步：将第一步标记的对象进行回收清除； 缺点： 1）效率问题：标记和清除的效率都不高； 2）空间问题：清除后会产生大量不连续的内存碎片。 复制算法（新生代）思路： 第一步：将可用内存按容量划分为大小相等的两块，每次只使用其中的一块； 第二步：一块的内存用完了，就将还存活着的对象复制到另外一块上面； 第三步：把已使用的内存空间一次清理掉； 优点： 1）实现简单2）运行高效3）不容易产生碎片 缺点： 对内存空间的使用做出了高昂的代价，因为能够使用的内存缩减到原来的一半。 标记-整理算法（老年代）思想： 在完成标记之后，它不是直接清理可回收对象，而是将存活对象都向一端移动，然后清理掉端边界以外的内存。 分代收集算法思路： 根据对象存活的生命周期将内存划分为若干个不同的区域。 新生代： 包含有Enden (80%)、form survivor space (10%)、to survivor space(10%)三个区，绝大多数最新被创建的对象会被分配到这里，大部分对象在创建之后会变得很快不可达，在该区域发生的垃圾收集被称为Minor GC。 老年代： 从新生代存活下来的对象会被拷贝到这里，它的空间比新生代要大，所以在老年代上发生的GC要比新生代少得多。在该区域发生的垃圾收集被称为Major GC / Full GC。 持久代： 也被称为方法区，用来存放类常量和字符串常量，这个区域不是用来存储那些从老年代存活下来的对象。它也会发生GC操作。 内存分配与回收的策略 1）对象优先在Enden上分配 2）大对象可以直接进入老年代 （设置标签-XX:PretenureSizeThreshold = n） 3）长期存活的对象将进入老年代 注意：虚拟机给每个对象定义了一个对象年龄（Age）计数器。如果对象在Enden出生并且经过第一次Minor GC仍然存活，并且能够被Survivor空间容纳，进入移动到Survivor空间，并且设置对象年龄为1，对象在Survivor区每熬过一个Minor GC，年龄就增加1岁，当它的年龄到达一定的程度（默认为15岁），就会被移动到老年代，这个年龄阀值可以通过-XX:MaxTenuringThreshold设置。 动态对象年龄判断 说明：虚拟机并不是永远要求对象的年龄达到MaxTenuringThreshold才移动到老年代，如果Survivor区中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或者等于该年龄的对象也被移动到老年代。 空间分配担保 说明：在发生Minor GC之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那么Minor GC可以确保是安全的。如果不成立，则虚拟机会查看HandlePromotionFailure设置值是否允许担保失败。如果允许，那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次Minor GC，尽管这次Minor GC是有风险的；如果小于，或者HandlePromotionFailure设置不允许冒险，那这时也要改为进行一次Full GC。 垃圾收集器参考：Java HotSpot虚拟机的内存管理（垃圾收集）参考：7种垃圾收集器：主要特点 应用场景 设置参数 基本运行原理 新生代收集器： Serial、ParNew、Parallel Scavenge； 老年代收集器： Serial Old、Parallel Old、CMS； 整堆收集器： G1； 说明： 两个收集器间有连线，表明它们可以搭配使用。 Serial 收集器Serial是最基本的收集器，历史悠久。是一个单线程收集器，而且它在进行垃圾回收的时候，必须暂停其他所有的工作线程，直到收集结束。这就意味着，每次进行垃圾收集都必须停掉用户正常工作的线程。 线程：单线程； 算法：复制算法； ParNew 收集器（新生代）ParNew是Serial的多线程版本。仍要停顿 线程：多线程； 算法：复制算法； Parallel Scavenge 收集器（新生代）Parallel Scavenge是一个新生代收集器，使用多线程和复制算法。相比其他收集器，只有这个收集器是针对系统吞吐量进行改进，适用于后台运算并且交互不多的程序。其他收集器则更关注改善收集时的停顿时间，适用于用户交互的程序。 吞吐量： 用于运行用户代码的时间与CPU总消耗时间的比值； 即吞吐量=运行用户代码时间 /（运行用户代码时间+垃圾收集时间）； 线程：多线程； 算法：复制算法； 注意： 通常，平均响应时间越短，系统吞吐量越大；平均响应时间越长，系统吞吐量越小。但是，系统吞吐量越大，未必平均响应时间越短。因为在某些情况（例如，不增加任何硬件配置）吞吐量的增大，有时会把平均响应时间作为牺牲，来换取一段时间处理更多的请求。 Serial Old 收集器（老年代）Serial Old是Serial的老年代版本，专门用于收集老年代，采用“标记整理算法”。 线程：单线程； 算法：标记整理算法； Parallel Old 收集器（老年代）Parallel Old是Parallel Scavenge的老年代版本，使用多线程和“标记整理算法”。 线程：多线程； 算法：标记整理算法； CMS 收集器（老年代）说明： CMS收集器是一种以获取最短回收停顿时间为目标的收集器，给用用户带来较好的体验，可称之为并发低停顿收集器。基于标记-清除算法实现。可用于新、老代收集，一般用于老年代收集，然后搭配一个新生代收集器(可以是Serial和ParNew) 缺点： 1）对CPU资源敏感（因为是并发）。在并发阶段，虽然不会导致用户线程停顿，但是会因为占用了一部分线程（即CPU资源）而导致用户应用程序变慢，总吞吐量降低。 2）无法处理浮动垃圾。因为是边收集，边产生垃圾。 3）标记-清除算法会产生空间碎片。需要额外碎片整理过程，停顿时间变长。 线程：多线程； 算法：标记清除算法； G1 收集器说明： G1收集器是当前收集器技术发展最前沿的成果。基于标记-整理算法，可以精确控制停顿。基本不牺牲吞吐量的前提下完成低停顿的内存回收。这是由于它将新生代、老年代划分为多个区域，并维护一个每个区域收集的优先列表，保证了在有限的时间内可以获得最高的收集效率。 缺点：没有经过实际应用的考验，缺少测试。 应用场景总结：用户交互：ParNew、CMS 高吞吐量：Parallel Scavenge fullGC和MinorGC区别Minor GC（新生代GC）：发生在新生代的垃圾收集动作，因为Java对象大多数都具备朝生夕灭的特点，所以Minor GC 非常频繁，通常回收速度比较快。 Major GC / Full GC（老年代GC）：指发生在老年代的GC，速度一般会比Minor GC慢10倍以上。 触发条件： Minor GC：当Eden区满时，触发Minor GC。 Major / Full GC： 1）调用System.gc时，系统建议执行Full GC，但是不必然执行 2）老年代空间不足 3）方法区空间不足 说明： 1）通过Minor GC后进入老年代的平均大小大于老年代的可用内存 2）由Eden区、From Space区向To Space区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小。 类加载机制说明： Java虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的加载机制。 类从被加载到虚拟机内存中到卸载出内存为止，它的整个生命周期如下： 加载： 查找和导入Class文件； 连接： 把类的二进制数据合并到JRE中； 1）验证：检查载入Class文件数据的正确性； 2）准备：给类的静态变量分配存储空间； 3）解析：将常量池符号引用转成直接引用； 初始化： 对类的静态变量，静态代码块执行初始化操作； 注意： 加载、验证、准备、初始化和卸载这五个阶段的顺序是确定的，类的加载过程必须按照这个顺序来按部就班地开始，而解析阶段则不一定，它在某些情况下可以在初始化阶段后再开始。 说明： Java程序可以动态扩展是由运行期动态加载和动态链接实现的。比如：如果编写一个使用接口的应用程序，可以等到运行时再指定其实际的实现(多态)，解析过程有时候还可以在初始化之后执行；比如：动态绑定(多态)。 结束生命周期： 在以下情况的时候，Java虚拟机会结束生命周期 执行了System.exit()方法； 程序正常执行结束； 程序在执行过程中遇到了异常或错误而异常终止； 由于操作系统出现错误而导致Java虚拟机进程终止； 下面展开分析： 加载说明：1）将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内。 2）然后在堆区创建一个java.lang.Class对象，用来封装类在方法区内的数据结构。 3）类的加载的最终产品是位于堆区中的Class对象，Class对象封装了类在方法区内的数据结构，并且向Java程序员提供了访问方法区内的数据结构的接口。 注意： 类加载器并不需要等到某个类被“首次主动使用”时再加载它，JVM规范允许类加载器在预料某个类将要被使用时就预先加载它。 加载class文件方式： 1）从本地系统中直接加载 2）通过网络下载.class文件 3）从zip，jar等归档文件中加载.class文件 4）从专有数据库中提取.class文件 5）将Java源文件动态编译为.class文件 加载阶段，虚拟机完成工作： 1）通过一个类的全限定名称来获取定义此类的二进制字节流。 2）将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。 3）在java堆中生成一个代表这个类的java.lang.Class对象，作为方法区这些数据的访问入口。 验证说明： 验证的目的是为了确保Class文件中的字节流包含的信息符合当前虚拟机的要求，而且不会危害虚拟机自身的安全。不同的虚拟机对类验证的实现可能会有所不同，但大致都会完成以下四个阶段的验证：文件格式的验证、元数据的验证、字节码验证和符号引用验证。 1）文件格式的验证：验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理，该验证的主要目的是保证输入的字节流能正确地解析并存储于方法区之内。经过该阶段的验证后，字节流才会进入内存的方法区中进行存储，后面的三个验证都是基于方法区的存储结构进行的。 2）元数据验证：对类的元数据信息进行语义校验（其实就是对类中的各数据类型进行语法校验），保证不存在不符合Java语法规范的元数据信息。 3）字节码验证：该阶段验证的主要工作是进行数据流和控制流分析，对类的方法体进行校验分析，以保证被校验的类的方法在运行时不会做出危害虚拟机安全的行为。 4） 符号引用验证：这是最后一个阶段的验证，它发生在虚拟机将符号引用转化为直接引用的时候（解析阶段中发生该转化，后面会有讲解），主要是对类自身。 准备说明： 准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中进行分配。 1）这时候进行内存分配的仅包括类变量（static），而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在Java堆中。 2）这里所设置的初始值通常情况下是数据类型默认的零值（如0、0L、null、false等），而不是被在Java代码中被显式地赋予的值。 解析说明： 解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。 1）符号引用（Symbolic Reference）：符号引用以一组符号来描述所引用的目标，符号引用可以是任何形式的字面量，符号引用与虚拟机实现的内存布局无关，引用的目标并不一定已经在内存中。 2）直接引用（Direct Reference）：直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用是与虚拟机实现的内存布局相关的，同一个符号引用在不同的虚拟机实例上翻译出来的直接引用一般都不相同，如果有了直接引用，那引用的目标必定已经在内存中存在。 解析分析： 1）类或接口的解析：判断所要转化成的直接引用是对数组类型，还是普通的对象类型的引用，从而进行不同的解析。 2）字段解析：对字段进行解析时，会先在本类中查找是否包含有简单名称和字段描述符都与目标相匹配的字段，如果有，则查找结束；如果没有，则会按照继承关系从上往下递归搜索该类所实现的各个接口和它们的父接口，还没有，则按照继承关系从上往下递归搜索其父类，直至查找结束。 3）类方法解析：对类方法的解析与对字段解析的搜索步骤差不多，只是多了判断该方法所处的是类还是接口的步骤，而且对类方法的匹配搜索，是先搜索父类，再搜索接口。 4）接口方法解析：与类方法解析步骤类似，只是接口不会有父类，因此，只递归向上搜索父接口就行了。 初始化说明： 类初始化阶段是类加载过程的最后一步，前面的类加载过程中，除了加载（Loading）阶段用户应用程序可以通过自定义类加载器参与之外，其余动作完全由虚拟机主导和控制。到了初始化阶段，才真正开始执行类中定义的Java程序代码。 初始化： 为类的静态变量赋予正确的初始值，JVM负责对类进行初始化，主要对类变量进行初始化。在Java中对类变量进行初始值设定有两种方式： 1）声明类变量时指定初始值； 2）使用静态代码块为类变量指定初始值； 类初始化的触发条件: 只有当对类的主动使用的时候才会导致类的初始化。 1）遇到new、getstatic、putstatic或invokestatic这4条字节码指令时，如果类没有进行过初始化，则需要先触发其初始化。生成这4条指令的最常见的Java代码场景是：使用new关键字实例化对象的时候，读取或设置一个类的静态字段（被final修饰、已在编译期把结果放入常量池的静态字段除外）的时候，以及调用一个类的静态方法的时候。 2）使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。 3）当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。 4）当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类。 说明： 只有上述四种情况会触发初始化，也称为对一个类进行主动引用，除此以外，所有其他方式都不会触发初始化，称为被动引用。 通俗的解释对应下面的六种: 1）创建类的实例，也就是new的方式； 2）或者对该静态变量赋值； 3）调用类的静态方法； 4）反射（如Class.forName(“com.shengsiyuan.Test”)）； 5）初始化某个类的子类，则其父类也会被初始化； 6）Java虚拟机启动时被标明为启动类的类（Java Test），直接使用java.exe命令来运行某个主类； 类加载器与双亲委派模型类加载器说明： 在类加载的第一阶段“加载”过程中，需要通过一个类的全限定名来获取定义此类的二进制字节流，完成这个动作的代码块就是类加载器。这一动作是放在Java虚拟机外部去实现的，以便让应用程序自己决定如何获取所需的类。 注意： 1）虚拟机规范并没有指明二进制字节流要从一个Class文件获取，或者说根本没有指明从哪里获取、怎样获取。 2）JVM中两个类是否“相等”，首先就必须是同一个类加载器加载的，否则，即使这两个类来源于同一个Class文件，被同一个虚拟机加载，只要类加载器不同，那么这两个类必定是不相等的。 类加载器分类说明：从Java虚拟机的角度来说，只存在两种不同的类加载器：一种是（Bootstrap ClassLoader），这个类加载器使，是虚拟机自身的一部分；另一种就是所有其他的类加载器，这些类加载器都有Java语言实现，独立于虚拟机外部，并且全部继承自java.lang.ClassLoader。 JVM虚拟机角度： 1）启动类加载器（用C++语言实现（HotSpot虚拟机中），是虚拟机自身的一部分） 2）其他的类加载器（由Java语言实现，独立于虚拟机外部，继承自java.lang.ClassLoader类。） 开发者的角度： 1）启动（Bootstrap）类加载器（将Java_Home/lib下面的类库加载到内存中（比如rt.jar），开发者无法直接引用） 2）扩展（Extension）类加载器（将Java_Home/lib/ext或者由系统变量 java.ext.dir指定位置中的类库加载到内存中。开发者可以直接使用） 3）应用程序（Application）类加载器（将系统类路径（CLASSPATH）中指定的类库加载到内存中。开发者可以直接使用，由于这个类加载器是ClassLoader中的getSystemClassLoader()方法的返回值，因此一般称为系统（System）加载器。） 双亲委派模型说明： 该模型要求除了顶层的启动类加载器外，其余的类加载器都应该有自己的父类加载器，而这种父子关系一般通过组合（Composition）关系来实现，而不是通过继承（Inheritance）。 1234567891011121314151617181920212223protectedsynchronized Class&lt;?&gt; loadClass(String name,boolean resolve) throws ClassNotFoundException &#123; //首先判断该类型是否已经被加载 Class c = findLoadedClass(name); if (c ==null) &#123; //如果没有被加载，就委托给父类加载或者委派给启动类加载器加载 try &#123; //如果存在父类加载器，就委派给父类加载器加载 if (parent !=null) &#123; c = parent.loadClass(name,false); //如果不存在父类加载器，就检查是否是由启动类加载器加载的类，通过调用本地方法native Class findBootstrapClass(String name) &#125;else &#123; c = findBootstrapClass0(name); &#125; &#125;catch (ClassNotFoundException e) &#123; //如果父类加载器和启动类加载器都不能完成加载任务，才调用自身的加载功能 c = findClass(name); &#125; &#125; if (resolve) &#123; resolveClass(c); &#125; return c;&#125; 执行过程： 某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父类加载器，依次递归，如果父类加载器可以完成类加载任务，就成功返回；只有父类加载器无法完成此加载任务时，才自己去加载。 注意： 双亲委派模型是Java设计者推荐给开发者的类加载器的实现方式，并不是强制规定的。大多数的类加载器都遵循这个模型，但是JDK中也有较大规模破坏双亲模型的情况，例如线程上下文类加载器（Thread Context ClassLoader）的出现。 与垃圾回收相关的JVM参数-Xms / -Xmx ：堆的初始大小 / 堆的最大大小-Xmn ：堆中年轻代的大小-XX:-DisableExplicitGC ：让System.gc()不产生任何作用-XX:+PrintGCDetails ：打印GC的细节-XX:+PrintGCDateStamps ：打印GC操作的时间戳-XX:NewSize / XX:MaxNewSize ： 设置新生代大小/新生代最大大小-XX:NewRatio ：可以设置老生代和新生代的比例-XX:PrintTenuringDistribution： 设置每次新生代GC后输出幸存者乐园中对象年龄的分布-XX:InitialTenuringThreshold / -XX:MaxTenuringThreshold：设置老年代阀值的初始值和最大值-XX:TargetSurvivorRatio：设置幸存区的目标使用率 为什么新生代内存需要有两个Survivor区]]></content>
      <categories>
        <category>虚拟机</category>
      </categories>
      <tags>
        <tag>虚拟机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络基础知识]]></title>
    <url>%2F2018%2F03%2F02%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[基本概念1）宽带猫 ADSL（宽带）的猫准确的名称叫做“调制解调器”。它是在发送端通过调制将数字信号转换为模拟信号，而在接收端通过解调再将模拟信号转换为数字信号的一种装置。现在的光纤网络，大多都不再需要调制解调器。 2）集线器 集线器的英文称为“Hub”。“Hub”是“中心”的意思，集线器的主要功能是对接收到的信号进行再生整形放大，以扩大网络的传输距离，同时把所有节点集中在以它为中心的节点上。 3）路由器 路由器大家都知道，插进去网线，设定好拨号，可以给多台电脑共享网络了，一般路由器有两个部分组成，WAN和LAN，WAN是用来拨号的，是让路由自身能上网的一个部分，LAN是用来局域网内交换数据的，跟交换机的作用一样，我们的电脑插在LAN口才能上网。 4）交换机 是不能拨号的路由器，也就是说他只有LAN，没有WAN。 5）集线器和交换机区别 集线器采用的是共享带宽的工作方式，简单打个比如，集线器就好比一条单行道，“10M”的带宽分多个端口使用，当一个端口占用了大部分带宽后，另外的端口就会显得很慢。相反，交换机是一个独享的通道，它能确保每个端口使用的带宽，如百兆的交换机，它能确保每个端口都有百兆的带宽。正因为交换机比集线器有着明显的优势，目前的集线器可说绝迹市场了。 网络传输过程： 1）ISP（internet service provider)通过电话线将数据连接到猫； 2）猫经过调制解调将数据转换为计算机能识别的数据； 3）将转换出来的数据连接到路由器，路由器的WAN口用来实现拨号功能，LAN口用来扩展接口，以方便连接到多个计算机； 4）但是路由器的可扩展接口往往不够用，需要交换机来扩展更多的接口，交换机只有LAN口； OSI参考模型OSI（Open Systems Interconnection Reference Model）OSI/RM简称OSI开放系统互连参考模型，通俗的将就是我们说的7层协议的体系结构应用层、表示层、会话层、传输层、网络层、链路层、物理层。 注意： 这七层是在发送数据到网线之前，在计算机中内部就已经经过了这7层，不是在传输过程中才慢慢经过这7层的。 应用层： 所有产生网络流量的程序。 表示层： 在传输数据之前进行的一些操作(加密，压缩，发送数据使用的编码等)。 例如：发送数据使用的是UTF-8来编码，而在浏览器用别的编码来解码，就会出现乱码，这就是表示层出现了问题。 会话层： 在传输数据时，需要通道，就需要创建会话，以防请求方和目标方不知道谁是谁。 例如：访问百度，则会与主机上存放百度网页的地址创建了会话，请求接收到了全部数据，则会话结束。 传输层： 就是传输数据的过程，因为有了前面表示层和会话层做的一些事情，已经具备传输数据的条件了。 可靠传输：通过网址访问主机之间，进行的传输是一来一往，而且进行多次交流，多个数据包； 不可靠传输：通过网址到DNS解析器解析域名真实地址的过程，就是不可靠传输，只需要一个数据包，去一个，回一个就完成了。 网络层： 规划最佳路径，规划ip地址， 传输数据到目标地址的过程中，经过哪些路由器，也就是走什么路径，就是网络层做的事情。 数据链路层： 对数据帧的开始与结束 差错校验。 发送数据是分组发送的，不是一次性发送，每次发送一组数据，如何知道这一组数据就是我们发的呢？就需要在数据的开始和结束定义一个特殊的东西，让路由器或交换机知道该数据什么时候开始，什么时候结束。 差错校验，在接受完一组数据后，校验数据是否完整，如果有问题，则丢掉，让计算机重新发一次。 物理层： 定义网络接口标准 网线的水晶头，里面都是8根线，0101如果定义，用1V代表1，0V代表0，类似这样规定，不可能一个商家50V代表1，这样1V那个规定将会出现问题。 TCP/IP的体系结构分为4层： 网络接口层(物理层、链路层)、网际层(网络层IP)、传输层(UDP/TCP)、应用层(会话层、表示层、应用层) 原理体系结构： 物理层、链路层、网络层、传输层、应用层(会话层+表示层+应用层) 发送数据将数据封装起来，看看每个层次都做了什么事 看看数据封装之后的样子 网络层参考博客：网络层 IP地址：&lt;网络地址&gt; + &lt;端口地址&gt;网络地址=IP地址和子网掩码进行与运算 例如： 已知ip地址141.14.72.24，所在网络的子网掩码是255.255.192.0，试求其网络地址？ 子网掩码：255.255.192.0 ————–11111111，11111111，11000000，00000000 IP地址：141.14.72.24 —————— 10001101，00001110，01001000，00011000 说明： 根据子网掩码知道ip地址的前18位为网络号，网络地址就为：10001101.00001110.01000000.00000000 转换为10进制就是141.14.64.0 网关： 路由器的IP地址 IP地址和MAC地址的区别？MAC地址：物理地址 IP地址：网络中的地址 说明： 在网络中通过主机的IP地址，先找到他的网络地址，到达了网络地址后，然后通过该网络中的老大(路由器)来分析一下这个IP地址是你网路中的哪个主机，这时，老大(路由器)就通过该目标ip地址改到对应主机的MAC地址，既然知道了MAC地址，就能找到该计算机了。就好比什么呢。路由器是每次分配给你的IP地址不一样，但是你的MAC地址肯定不会变，所以就根据IP地址找到你的MAC地址。但是怎么找到的呢？就要通过网络层中的ARP(地址解析协议)解析了。 ARP协议地址解析协议：通过IP地址来解析主机的MAC地址。 过程： 拿局域网来说，一个局域网中有很多主机，主机A想和局域网中的主机B通话，但是只知道对方的IP地址，所以他就通过发广播，给局域网中所有的主机，问这个IP地址是谁，主机B收到了这个信息，通过网络适配器(网卡)就发现自己是这个IP地址，然后就把自己的MAC地址发给源主机，这样就知道了MAC地址，就能够通信了。 在跨网络中就不是直接发广播了，先通过IP地址找到对应的网络地址，如何找到的对应的网络地址呢，通过路由器，每个路由器都有三层。网络层、链路层、物理层，也就是说最高能够识别网络层中的东西来，那么路由器也就有ARP协议了，每个路由器都能识别出目标IP地址在哪个路由器上，这其中涉及到了很多算法，我们这里不做更多的解释，简单来说，路由器能根据目标IP地址找到下一跳路由器的MAC地址，然后一步一步跳下去，直到找到目标IP地址的网络地址的路由器，然后通过该路由器来找到目标IP地址的MAC地址，这样就能够找到目标主机了。这就是ARP协议。 IP协议IP协议通过看一下IP数据包(报)的格式就知道IP协议是干嘛的了，就是来规定数据报的格式，以及定义的功能。 ICMP协议这个比较简单，就两部分ICMP差错报告报文、ICMP询问报文。这个挺使用的，比如我们经常用来测试网络连接畅通的ping命令等。 ICMP差错报告报文：检测在传送数据的过程中，发生的错误，如果发生了错误，会通过该协议返回给源主机一个带有错误原因的数据包。 ICMP询问报文： 1）回送请求和回答： 主机向特定目标发出询问，收到此报文必须返回一个ICMP回送回答报文。用于测试目的站是否可达。 2）时间戳请求和回答： 请某个路由器或主机回答当前的日期和时间，用于进行时钟的同步和测量时间。 IGMP协议主要用于多播。 广播： 老师在台上讲课，你们能随时看到老师的电脑屏幕，因为采用的广播，每个人都能接受到老师屏幕上所有的数据包。 多播： 在一个局域网中，有三个多播组，A、B、C，A在放java视频，B在放C++视频，C在放娱乐视频，如果你想看Java视频，那么你就调到A这个多播组中学习java视频，学习累了，你就可以换到C这个多播组中看看娱乐节目，这就是多播的意思，相对广播来说，自己需要什么就调什么，而不是跟广播一样，被动接受，他播到哪，就只能看到哪，多播能自由控制速度。 单播： 50个人想看视频，就得发送50个数据包。多播的话就发一个，然后通过路由器转发50分给不同的人， 传输层参考博客：传输层 运输层提供应用层提供端到端通信服务，网络层通过IP地址和MAC地址找到了主机，要实现两主机进程间的通讯，需要找到对应主机的端口号，一个端口号对应一个进程。 UDP协议UDP： User Datagram Protocol 用户数据报协议。 特点： 1. 无连接： 在通讯之前不需要建立连接，直接传输数据。 2. 不可靠： 是将数据报的分组从一台主机发送到另一台主机，但并不保证数据报能够到达另一端，任何必须的可靠性都由应用程序提供。在UDP情况下，虽然可以确保发送消息的大小，却不能保证消息一定会达到目的端。没有超时和重传功能，当UDP数据封装到IP数据报传输时，如果丢失，会发送一个ICMP差错报文给源主机。即使出现网络阻塞情况，UDP也无法进行流量控制。此外，传输途中即使出现丢包，UDP也不负责重发，甚至当出现包的到达顺序杂乱也没有纠正的功能。 应用场景： 1）应用层协议中DNS，也就是根据域名解析ip地址的一个协议，他使用的就是UDP； 2）DHCP，这个是给各电脑分配IP地址的协议，其中用的也是UDP协议； 3）IGMP，我们说的多播，也就是使用的UDP，在多媒体教师，老师拿笔记本讲课，我们在下面通过各自的电脑看到老师的画面，这就是通过UDP传输数据，所以会出现有的同学卡，有的同学很流畅，就是因为其不可靠传输，但是卡一下，对接下来的观看并没有什么映像。 TCP协议TCP： Transmission Control Protocol传输控制协议。 TCP协议是面向连接的、可靠传输、有流量控制，拥塞控制，面向字节流传输等很多优点的协议。其最终功能和UDP一样，在端和端之间进行通信，但是和UDP的区别还是很大的。 应用场景： 1）FTP：定义了文件传输协议，使用21端口。常说某某计算机开了FTP服务便是启动了文件传输服务。下载文件，上传主页，都要用到FTP服务。 2）Telnet：它是一种用于远程登陆的端口，用户可以以自己的身份远程连接到计算机上，通过这种端口可以提供一种基于DOS模式下的通信服务。如以前的BBS是-纯字符界面的，支持BBS的服务器将23端口打开，对外提供服务。 3）SMTP：定义了简单邮件传送协议，现在很多邮件服务器都用的是这个协议，用于发送邮件。如常见的免费邮件服务中用的就是这个邮件服务端口，所以在电子邮件设置-中常看到有这么SMTP端口设置这个栏，服务器开放的是25号端口。 4）POP3：Post Office Protocol 3的简称,即邮局协议的第3个版本，它是和SMTP对应，POP3用于接收邮件。通常情况下，POP3协议所用的是110端口。也是说，只要你有相应的使用POP3协议的程序（例如Fo-xmail或Outlook），就可以不以Web方式登陆进邮箱界面，直接用邮件程序就可以收到邮件（如是163邮箱就没有必要先进入网易网站，再进入自己的邮-箱来收信）。 5） HTTP：这是大家用得最多的协议，它就是常说的”超文本传输协议”。上网浏览网页时，就得在提供网页资源的计算机上打开80号端口以提供服务。常说”WWW服务”、”Web服务器”用的就是这个端口。 TCP三次握手建立连接 参考博客：（TCP三次握手） 有趣的例子： A:“喂，你听得到吗？”A-&gt;SYN_SEND B:“我听得到呀，你听得到我吗？”应答与请求同时发出 B-&gt;SYN_RCVD | A-&gt;ESTABLISHED A:“我能听到你，今天balabala……”B-&gt;ESTABLISHED 相关符号： 1. ACK： 确认，当ACK为1时，确认序号才有效。当ACK为0时，确认序号没用；2. SYN： 同步序号，用来发起一个连接；3. FIN： 终止标志，在释放连接时使用；（和SYN一样，一个FIN将占用一个序号）4. seq： 序号；5. ack： 确认序号；6. ISN： 初始序号(Initial Sequence Number),是随机产生的； 注意： 建立连接的最重要目是让连接的双方交换初始序号ISN(Initial Sequence Number)。 图片中x和y分别是客户端和服务器的ISN。 三次握手过程： 1）客户端发送SYN包(seq=x)到服务器，并进入SYN_SEND状态，等待服务器确认； 2）服务器收到SYN包，必须确认客户的SYN（ack=x+1），同时自己也发送一个SYN包（seq=y），即SYN+ACK包，此时服务器进入SYN_RECV状态； 3）客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=y+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。 TCP的三次握手过程？为什么会采用三次握手，若采用二次握手可以吗？TCP三次握手的思考，为什么要有三次握手 答：建立连接的过程是利用客户服务器模式，假设主机A为客户端，主机B为服务器端。 1）TCP的三次握手过程：主机A向B发送连接请求；主机B对收到的主机A的报文段进行确认；主机A再次对主机B的确认进行确认。 2）采用三次握手是为了防止失效的连接请求报文段突然又传送到主机B，因而产生错误。失效的连接请求报文段是指：主机A发出的连接请求没有收到主机B的确认，于是经过一段时间后，主机A又重新向主机B发送连接请求，且建立成功，顺序完成数据传输。考虑这样一种特殊情况，主机A第一次发送的连接请求并没有丢失，而是因为网络节点导致延迟达到主机B，主机B以为是主机A又发起的新连接，于是主机B同意连接，并向主机A发回确认，但是此时主机A根本不会理会，主机B就一直在等待主机A发送数据，导致主机B的资源浪费。 3）采用两次握手不行，原因就是上面说的实效的连接请求的特殊情况。 TCP四次挥手断开连接 有趣的例子： A:“喂，我不说了。”A-&gt;FIN_WAIT1 B:“我知道了。等下，上一句还没说完。Balabala…..”B-&gt;CLOSE_WAIT | A-&gt;FIN_WAIT2 B:”好了，说完了，我也不说了。”B-&gt;LAST_ACK A:”我知道了。”A-&gt;TIME_WAIT | B-&gt;CLOSED A等待2MSL,保证B收到了消息,否则重说一次”我知道了”,A-&gt;CLOSED TCP四次挥手断开连接过程 假设主机A为客户端，主机B为服务器，其释放TCP连接的过程如下： 1）关闭客户端到服务器的连接：首先客户端A发送一个FIN，用来关闭客户到服务器的数据传送，然后等待服务器的确认。其中终止标志位FIN=1，序列号seq=u 2）服务器收到这个FIN，它发回一个ACK，确认号ack为收到的序号加1。 3）关闭服务器到客户端的连接：也是发送一个FIN给客户端。 4）客户段收到FIN后，并发回一个ACK报文确认，并将确认序号seq设置为收到序号加1。 首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。 为什么TCP释放连接需要四次？ TCP建立连接要进行三次握手，而断开连接要进行四次。这是由于TCP的半关闭造成的。因为TCP连接是全双工的(即数据可在两个方向上同时传递)所以进行关闭时每个方向上都要单独进行关闭。这个单方向的关闭就叫半关闭。当一方完成它的数据发送任务，就发送一个FIN来向另一方通告将要终止这个方向的连接。 A为什么等待2MSL，从TIME_WAIT到CLOSE？ 在Client发送出最后的ACK回复，但该ACK可能丢失。Server如果没有收到ACK，将不断重复发送FIN片段。所以Client不能立即关闭，它必须确认Server接收到了该ACK。Client会在发送出ACK之后进入到TIME_WAIT状态。Client会设置一个计时器，等待2MSL的时间。如果在该时间内再次收到FIN，那么Client会重发ACK并再次等待2MSL。所谓的2MSL是两倍的MSL(Maximum Segment Lifetime)。MSL指一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大时间。如果直到2MSL，Client都没有再次收到FIN，那么Client推断ACK已经被成功接收，则结束TCP连接。 应用层参考博客：DNS协议 参考博客：HTTP协议 参考博客：HTTP断线续传原理 参考博客：Http和Https区别参考博客：Https原理解析 访问一个网站的基本流程参考：访问一个网站的基本流程]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Servlet基本知识]]></title>
    <url>%2F2018%2F02%2F28%2FServlet%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[注意：开发Servlet需要导入servlet-api.jar包。 get和post的区别get是form默认的提交方式。如果通过一个超链访问某个地址，是get方式如果在地址栏直接输入某个地址，是get方式提交数据会在浏览器显示出来不可以用于提交二进制数据，比如上传文件。 哪些是get方式呢？ 1）form默认的提交方式2）如果通过一个超链访问某个地址3）如果在地址栏直接输入某个地址4）ajax指定使用get方式的时候 post必须在form上通过 method=”post” 显示指定。提交数据不会在浏览器显示出来可以用于提交二进制数据，比如上传文件。 哪些是post方式呢？ 1）在form上显示设置 method=”post”的时候2）ajax指定post方式的时候 生命周期Servlet 生命周期可被定义为从创建直到毁灭的整个过程。以下是 Servlet 遵循的过程： 1）实例化：当用户通过浏览器输入一个路径，这个路径对应的servlet被调用的时候，该Servlet就会被实例化。注意： 不管访问多少次servlet，只会实例化一次，这是由Tomcat服务器实例化的。 2）初始化：init方式是一个实例方法，所以会在构造方法执行后执行。注意： init初始化 只会执行一次。 3）提供服务：接下来就是执行service()方法，然后通过浏览器传递过来的信息进行判断，是调用doGet()还是doPost()方法。 4）销毁：调用destroy()方法。 5） 被回收：当该Servlet被销毁后，就满足垃圾回收的条件了。当下一次垃圾回收GC来临的时候，就有可能被回收。 在如下几种情况下，会调用destroy()： 1）该Servlet所在的web应用重新启动。 2）关闭tomcat的时候 destroy()方法会被调用，但是这个一般都发生的很快，不易被发现。 Servlet三种实现方式参考博客：（Servlet三种实现方式） 1）实现Servlet接口，然后实现接口中的五个方法； 2）继承GenericServlet，只需要实现一个方法：service； 3）继承HttpServlet,复写doGet和doPost方法；（最常用） Servlet中页面的跳转1）在服务端进行页面跳转 request.getRequestDispatcher(“success.html”).forward(request, response); 2）在客户端进行页面跳转 response.sendRedirect(“fail.html”);]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>servlet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jsp基础知识]]></title>
    <url>%2F2018%2F02%2F25%2FJsp%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[通过Servlet进行整个网站的开发是可以的。不过在Servlet中输出html代码，特别是稍微复杂一点的html代码，就会给人一种很酸爽的感觉。 Jsp文件开头1&lt;%@page contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot; import=&quot;java.util.*&quot;%&gt; 是JSP的&lt;%@page指令 1contentType=&quot;text/html; charset=UTF-8&quot; 相当于response.setContentType(“text/html; charset=UTF-8”); 通知浏览器以UTF-8进行中文解码1pageEncoding=&quot;UTF-8&quot; 如果jsp文件中出现了中文，这些中文使用UTF-8进行编码1import=&quot;java.util.* 导入其他类，如果导入多个类，彼此用,逗号隔开，像这样 import=”java.util.,java.sql.“ 为什么Jsp是Servlet?页面元素jsp由这些页面元素组成： 1）静态内容就是html,css,javascript等内容 2）指令以&lt;%@开始 %&gt; 结尾，比如&lt;%@page import=”java.util.*”%&gt; 3）表达式 &lt;%=%&gt;用于输出一段html 4）Scriptlet在&lt;%%&gt; 之间，可以写任何java 代码 5）声明在&lt;%!%&gt; 之间可以声明字段或者方法。但是不建议这么做。 6）动作&lt;jsp:include page=”Filename” &gt; 在jsp页面中包含另一个页面。在包含的章节有详细的讲解 7）注释 &lt;%– – %&gt;不同于 html的注释 通过jsp的注释，浏览器也看不到相应的代码，相当于在servlet中注释掉了 指令include和动作include区别指令include1&lt;%@include file=&quot;footer.jsp&quot; %&gt; footer.jsp的内容会被插入到 hello.jsp 转译 成的hello_jsp.java中，最后只会生成一个hello_jsp.java文件 动作include1&lt;jsp:include page=&quot;footer.jsp&quot; /&gt; footer.jsp的内容不会被插入到 hello.jsp 转译成的hello_jsp.java中，还会有一个footer_jsp.java独立存在。 hello_jsp.java 会在服务端访问footer_.jsp.java,然后把返回的结果，嵌入到响应中。 传递参数 因为指令&lt;%@include 会导致两个jsp合并成为同一个java文件，所以就不存在传参的问题，在发出hello.jsp 里定义的变量，直接可以在footer.jsp中访问。 而动作&lt;jsp:include /&gt;其实是对footer.jsp进行了一次独立的访问，那么就有传参的需要。 cookie1）Cookie是一种浏览器和服务器交互数据的方式。 2）Cookie是由服务器端创建，但是不会保存在服务器。 3）创建好之后，发送给浏览器。浏览器保存在用户本地。 4）下一次访问网站的时候，就会把该Cookie发送给服务器。 sessionSession对应的中文翻译是会话。 会话指的是从用户打开浏览器访问一个网站开始，无论在这个网站中访问了多少页面，点击了多少链接，都属于同一个会话。 直到该用户关闭浏览器为止，都属于同一个会话。 session 原理（和cookie配合工作） 1）当在同一个浏览器中同时打开多个标签，发送同一个请求或不同的请求，仍是同一个session； 2）当不在同一个窗口中打开相同的浏览器时，发送请求，仍是同一个session； 3）当使用不同的浏览器时，发送请求，即使发送相同的请求，是不同的session； 4）当把当前某个浏览器的窗口全关闭，再打开，发起相同的请求时，就是本文所阐述的，是不同的session； 如果没有cookie，session如何工作 cookie和session区别和联系？ 具体来说cookie机制采用的是在客户端保持状态的方案，而session机制采用的是在服务器端保持状态的方案。两者存储的都是用户登录信息，操作行为等等的数据。 访问同一个服务器1） cookie是把用户的数据写在用户本地浏览器上,其他网站也可以扫描使用你的cookie，容易泄露自己网站用户的隐私，而且一般浏览器对单个网站站点有cookie数量与大小的限制。 2）Session是把用户的数据写在用户的独占session上，存储在服务器上，一般只将session的id存储在cookie中。但将数据存储在服务器对服务器的成本会高。 3）session是由服务器创建的，开发人员可以在服务器上通过request对象的getsession方法得到session。 4）一般情况，登录信息等重要信息存储在session中，其他信息存储在cookie中。 JSP有4个作用域1） pageContext 当前页面 2）requestContext 一次请求 注意： 服务端跳转算一次请求，而客户端跳转不算一次请求。 3）sessionContext 当前会话（当前用户） 4）applicationContext 全局，所有用户共享 JSP九大隐式对象1）request对象 request 对象是 javax.servlet.httpServletRequest类型的对象。 该对象代表了客户端的请求信息，主要用于接受通过HTTP协议传送到服务器的数据。（包括头信息、系统信息、请求方式以及请求参数等）。request对象的作用域为一次请求。 2）response对象 response 代表的是对客户端的响应，主要是将JSP容器处理过的对象传回到客户端。response对象也具有作用域，它只在JSP页面内有效。 3）session对象 session 对象是由服务器自动创建的与用户请求相关的对象。服务器为每个用户都生成一个session对象，用于保存该用户的信息，跟踪用户的操作状态。session对象内部使用Map类来保存数据，因此保存数据的格式为 “Key/value”。 session对象的value可以使复杂的对象类型，而不仅仅局限于字符串类型。 4）application对象 application 对象可将信息保存在服务器中，直到服务器关闭，否则application对象中保存的信息会在整个应用中都有效。与session对象相比，application对象生命周期更长，类似于系统的“全局变量”。 5）out 对象 out 对象用于在Web浏览器内输出信息，并且管理应用服务器上的输出缓冲区。在使用 out 对象输出数据时，可以对数据缓冲区进行操作，及时清除缓冲区中的残余数据，为其他的输出让出缓冲空间。待数据输出完毕后，要及时关闭输出流。 6）pageContext 对象 pageContext 对象的作用是取得任何范围的参数，通过它可以获取 JSP页面的out、request、reponse、session、application 等对象。pageContext对象的创建和初始化都是由容器来完成的，在JSP页面中可以直接使用 pageContext对象。 7）config 对象 config 对象的主要作用是取得服务器的配置信息。通过 pageConext对象的 getServletConfig() 方法可以获取一个config对象。当一个Servlet 初始化时，容器把某些信息通过 config对象传递给这个 Servlet。 开发者可以在web.xml 文件中为应用程序环境中的Servlet程序和JSP页面提供初始化参数。 8）page 对象 page 对象代表JSP本身，只有在JSP页面内才是合法的。 page隐含对象本质上包含当前 Servlet接口引用的变量，类似于Java编程中的 this 指针。 9）exception 对象 exception 对象的作用是显示异常信息，exception对象只有当前页面的&lt;%@page 指令设置为isErrorPage=”true”的时候才可以使用。同时，在其他页面也需要设置 &lt;%@page 指令 errorPage=”” 来指定一个专门处理异常的页面。 JSTL标准标签库为了能够在JSP 中使用JSTL，首先需要两个jar包，分别是jstl.jar 和standard.jar EL表达式MVC架构M 代表 模型（Model），模型就是数据，就是dao,bean V 代表 视图（View），就是网页, JSP，用来展示模型中的数据 C 代表 控制器（controller），控制器的作用就是把不同的数据(Model)，显示在不同的视图(View)上。（控制将数据转发到什么视图）]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>jsp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring框架基础知识]]></title>
    <url>%2F2018%2F02%2F23%2FSpring%E6%A1%86%E6%9E%B6%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[IOC/DIIOC—Inversion of Control ，即“控制反转”，不是什么技术，而是一种设计思想。在Java开发中，Ioc意味着将你设计好的对象交给容器控制，而不是传统的在你的对象内部直接控制。 DI—Dependency Injection ，即“依赖注入”：组件之间依赖关系由容器在运行期决定，形象的说，即由容器动态的将某个依赖关系注入到组件之中。 理解： 在平时的java应用开发中，我们要实现某一个功能或者说是完成某个业务逻辑时至少需要两个或以上的对象来协作完成，在没有使用Spring的时候，每个对象在需要使用他的合作对象时，自己均要使用像new object() 这样的语法来将合作对象创建出来，这个合作对象是由自己主动创建出来的，创建合作对象的主动权在自己手上，自己需要哪个合作对象，就主动去创建，创建合作对象的主动权和创建时机是由自己把控的，而这样就会使得对象间的耦合度高了，A对象需要使用合作对象B来共同完成一件事，A要使用B，那么A就对B产生了依赖，也就是A和B之间存在一种耦合关系，并且是紧密耦合在一起，而使用了Spring之后就不一样了，创建合作对象B的工作是由Spring来做的，Spring创建好B对象，然后存储到一个容器里面，当A对象需要使用B对象时，Spring就从存放对象的那个容器里面取出A要使用的那个B对象，然后交给A对象使用，至于Spring是如何创建那个对象，以及什么时候创建好对象的，A对象不需要关心这些细节问题(你是什么时候生的，怎么生出来的我可不关心，能帮我干活就行)，A得到Spring给我们的对象之后，两个人一起协作完成要完成的工作即可。 DI其实就是IOC的另外一种说法。DI是由Martin Fowler 在2004年初的一篇论文中首次提出的。他总结：控制的什么被反转了？就是：获得依赖对象的方式反转了。 Bean的生命周期1）Spring IOC 容器对 Bean 的生命周期进行管理的过程： 1）通过构造器或工厂方法创建 Bean 实例2）为 Bean 的属性设置值和对其他 Bean 的引用3）调用 Bean 的初始化方法4）Bean 可以使用了5）当容器关闭时, 调用 Bean 的销毁方法 说明：在Bean的声明里设置 init-method 和 destroy-method 属性, 为Bean指定初始化和销毁方法。 2）（添加bean的后置处理器后）Spring IOC 容器对 Bean 的生命周期进行管理的过程： 1）通过构造器或工厂方法创建 Bean 实例2）为 Bean 的属性设置值和对其他 Bean 的引用3）将 Bean 实例传递给 Bean 后置处理器的postProcessBeforeInitialization 方法4）调用 Bean 的初始化方法5）将 Bean 实例传递给 Bean 后置处理器的postProcessAfterInitialization方法6）Bean 可以使用了7）当容器关闭时, 调用 Bean 的销毁方法 使用注解来注入对象@Autowired 注解 （推荐使用） 说明： 1）注解自动装配具有兼容类型的单个 Bean属性。 2）构造器, 普通字段(即使是非 public), 一切具有参数的方法都可以应用@Authwired 注解 @Resource 注解（要求提供一个 Bean名称的属性，若该属性为空，则自动采用标注处的变量或方法名作为 Bean 的名称） @Inject 注解（和@Autowired 注解一样也是按类型匹配注入的Bean，但没有 required 属性） 在classpath中扫描特定组件组件扫描(component scanning): Spring 能够从classpath下自动扫描，侦测和实例化具有特定注解的组件。 通过在配置文件中声明： 1&lt;context:component-scan base-package=&quot;com.atguigu.spring.beans&quot;&gt; 特定组件包括： @Repository Spring在容器初始化时将自动扫描base-package指定的包及其子包下的所有class文件，所有标注了 @Repository 的类都将被注册为Spring Bean。 为什么 @Repository 只能标注在DAO类上呢？ 这是因为该注解的作用不只是将类识别为Bean，同时它还能将所标注的类中抛出的数据访问异常封装为 Spring 的数据访问异常类型。 Spring本身提供了一个丰富的并且是与具体的数据访问技术无关的数据访问异常结构，用于封装不同的持久层框架抛出的异常，使得异常独立于底层的框架。 @Component 是一个泛化的概念，仅仅表示一个组件 (Bean) ，可以作用在任何层次。 @Service 通常作用在业务层，但是目前该功能与 @Component 相同。 @Constroller 通常作用在控制层，但是目前该功能与 @Component 相同。 Spring AOP代理设计模式的原理: 使用一个代理将对象包装起来，然后用该代理对象取代原始对象。任何对原始对象的调用都要通过代理。代理对象决定是否以及何时将方法调用转到原始对象上。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package com.atguigu.spring.aop.helloworld;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;import java.util.Arrays;public class ArithmeticCalculatorLoggingProxy &#123; //要代理的对象 private ArithmeticCalculator target; public ArithmeticCalculatorLoggingProxy(ArithmeticCalculator target) &#123; this.target = target; &#125; public ArithmeticCalculator getLoggingProxy() &#123; ArithmeticCalculator proxy = null; //代理对象由哪一个类加载器进行加载，getClass()运行时加载 ClassLoader loader = target.getClass().getClassLoader(); //代理对象的类型，即其中有哪些方法，".calss"编译时加载 Class [] interfaces = new Class[]&#123;ArithmeticCalculator.class&#125;; //当调用代理对象其中的方法时，该执行的代码 InvocationHandler h = new InvocationHandler() &#123; /** * proxy: 正在返回的那个代理对象。一般情况下，在invoke方法中都不使用该对象。 * method: 正在被调用的方法 * args: 调用方法时，传入的参数 */ @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; String methodName = method.getName(); //日志 System.out.println("The method" + methodName + "begins with " + Arrays.asList(args)); //执行方法 Object result = null; try &#123; //前置通知 //target:执行这个方法的对象; //args:执行这个方法的参数; result = method.invoke(target, args); //返回通知，可以访问到方法的返回值 &#125; catch (Exception e)&#123; e.printStackTrace(); //异常通知，可以访问到方法出现的异常 &#125; //后置通知，因为方法可能会出现异常，所以访问不到方法的返回值 //日志 System.out.println("The method" + methodName + " ends with " + result); return result; &#125; &#125;; proxy = (ArithmeticCalculator) Proxy.newProxyInstance(loader, interfaces, h); return proxy; &#125;&#125; 参考博客：AOP通俗理解 AOP 的好处: 1）每个事物逻辑位于一个位置, 代码不分散, 便于维护和升级； 2）业务模块更简洁, 只包含核心业务代码； 两种动态代理（JDK动态代理和CGLIB动态代理）区别： 1）前一种兄弟模式，spring会使用JDK的java.lang.reflect.Proxy类，它允许Spring动态生成一个新类来实现必要的接口，织入通知，并且把对这些接口的任何调用都转发到目标类。 2）后一种父子模式，spring使用CGLIB库生成目标类的一个子类，在创建这个子类的时候，spring织入通知，并且把对这个子类的调用委托到目标类。 相比之下，还是兄弟模式好些，他能更好的实现松耦合，尤其在今天都高喊着面向接口编程的情况下，父子模式只是在没有实现接口的时候，也能织入通知，应当做一种例外。 Spring事务管理事务管理是企业级应用程序开发中必不可少的技术,用来确保数据的完整性和一致性。 事务就是一系列的动作, 它们被当做一个单独的工作单元. 这些动作要么全部完成, 要么全部不起作用。 事务的四个关键属性(ACID)： 1. 原子性(atomicity)： 事务是一个原子操作, 由一系列动作组成. 事务的原子性确保动作要么全部完成要么完全不起作用。 2. 一致性(consistency)： 一旦所有事务动作完成, 事务就被提交。数据和资源就处于一种满足业务规则的一致性状态中。 3. 隔离性(isolation)： 可能有许多事务会同时处理相同的数据, 因此每个事物都应该与其他事务隔离开来, 防止数据损坏。 4. 持久性(durability)： 一旦事务完成, 无论发生什么系统错误, 它的结果都不应该受到影响. 通常情况下, 事务的结果被写到持久化存储器中。 Spring 支持编程式事务管理，也支持声明式事务管理： 1. 编程式事务管理: 将事务管理代码嵌入到业务方法中来控制事务的提交和回滚。在编程式管理事务时, 必须在每个事务操作中包含额外的事务管理代码。 2. 声明式事务管理: 大多数情况下比编程式事务管理更好用。它将事务管理代码从业务方法中分离出来, 以声明的方式来实现事务管理。事务管理作为一种横切关注点, 可以通过 AOP 方法模块化。Spring 通过 Spring AOP 框架支持声明式事务管理。 ###并发事务所导致的问题： 参考博客： 数据库事务隔离级别–脏读、不可重复读、幻读（清晰解释） 数据事务四种隔离机制和七种传播行为代码示例 1）脏读： 脏读就是指当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据，之后如果未提交的事务回滚了，则事务读取的数据就是无效的。 2）不可重复读： 是指在一个事务内，多次读同一数据。在这个事务还没有结束时，另外一个事务也访问该同一数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改，那么第一个事务两次读到的的数据可能是不一样的。这样就发生了在一个事务内两次读到的数据是不一样的，因此称为是不可重复读。（即不能读到相同的数据内容）。 例如，一个编辑人员两次读取同一文档，但在两次读取之间，作者重写了该文档。当编辑人员第二次读取文档时，文档已更改。原始读取不可重复。如果只有在作者全部完成编写后编辑人员才可以读取文档，则可以避免该问题。 3）幻读： 是指当事务不是独立执行时发生的一种现象，例如第一个事务对一个表中的数据进行了修改，这种修改涉及到表中的全部数据行。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入一行新数据。那么，以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行，就好象发生了幻觉一样。 例如，一个编辑人员更改作者提交的文档，但当生产部门将其更改内容合并到该文档的主复本时，发现作者已将未编辑的新材料添加到该文档中。如果在编辑人员和生产部门完成对原始文档的处理之前，任何人都不能将新材料添加到文档中，则可以避免该问题。 事务隔离级别 从理论上来说, 事务应该彼此完全隔离, 以避免并发事务所导致的问题。然而, 那样会对性能产生极大的影响, 因为事务必须按顺序运行。在实际开发中, 为了提升性能, 事务会以较低的隔离级别运行。 Oracle Sql Server默认隔离级别：Read committed Mysql默认隔离级别：Repeatable read ###事务传播属性： 当事务方法被另一个事务方法调用时, 必须指定事务应该如何传播。例如: 方法可能继续在现有事务中运行, 也可能开启一个新事务, 并在自己的事务中运行。 Spring 有7种，常用如下两种： REQUIRED: 如果有事务在运行，当前方法就在这个事务内运行，否则，就启动一个新的事务，并在自己的事务内运行。 REQUIRED_NEW：当前方法必须启动新事务，并在它自己的事务内运行。如果有事务正在运行，应该将它挂起。 ###面试题目：Spring是如何控制事务的？ Spring的事务，可以说是 Spring AOP 的一种实现。 AOP面向切面编程，即在不修改源代码的情况下，对原有功能进行扩展，通过代理类来对具体类进行操作。 spring是一个容器，通过spring这个容器来对对象进行管理，根据配置文件来实现spring对对象的管理。 spring的事务声明有两种方式，编程式和声明式。spring主要是通过“声明式事务”的方式对事务进行管理，即在配置文件中进行声明，通过AOP将事务切面切入程序，最大的好处是大大减少了代码量。]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringMVC框架基础知识]]></title>
    <url>%2F2018%2F02%2F20%2FSpringMVC%E6%A1%86%E6%9E%B6%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[SpringMVC运行流程 1）用户发送请求至前端控制器DispatcherServlet。 2）DispatcherServlet收到请求调用HandlerMapping处理器映射器。 3）处理器映射器找到具体的处理器，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet。 4）DispatcherServlet调用HandlerAdapter处理器适配器。 5）HandlerAdapter经过适配调用具体的处理器(Controller，也叫后端控制器)。 6）Controller执行完成返回ModelAndView。 7）HandlerAdapter将controller执行结果ModelAndView返回给DispatcherServlet。 8）DispatcherServlet将ModelAndView传给ViewReslover视图解析器。 9）ViewReslover解析后返回具体View。 10）DispatcherServlet根据View进行渲染视图（即将模型数据填充至视图中）。 11）DispatcherServlet响应用户。 说明： Handler: 也就是处理器，直接对应着MVC中的C也就是控制层。SpringMVC中用@RequestMapping标注的方法都可以看成一个Handler。也就是只要可以实际处理的请求就是Handleer。 HandlerMapping: 用来查找Handler。 HandlerAdapter: 适配器。因为SpringMVC中的Handler可以是任意形式，只要能处理请求就可以，但是Servlet需要的处理方法的结构是固定的，都是用request和response为参数的方法（比如doService方法）。如何让固定的Servlet处理方法调用灵活的Handler来进行处理？这就是HandlerAdapter所做的事情。 View: 用来展示数据。 ViewResolver: 用来查找View。]]></content>
      <categories>
        <category>springmvc</category>
      </categories>
      <tags>
        <tag>springMvc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mybatis框架面试题]]></title>
    <url>%2F2018%2F02%2F18%2Fmybatis%E6%A1%86%E6%9E%B6%E9%9D%A2%E8%AF%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[参考博客：Mybatis常见面试题 对于简单语句来说，使用注解代码会更加清晰，然而Java注解对于复杂语句来说就会混乱，应该限制使用。因此，如果你不得不做复杂的事情，那么最好使用XML来映射语句。 持久是相对于瞬时来说的，其实就是可以把数据固化在硬盘或者磁带一类可以保存很长时间的设备上，不像放在内存中一样断电就消失了。企业应用中数据很重要(各种订单数据、客户数据、库存数据之类的)，比应用程序本身更重要，所以需要把数据持久化。持久化可以通过很多方式，写文件和数据库都可以。只是现在企业一般都会选择把数据持久化到数据库中，因为可以很方便的查询统计分析，但数据库的数据最终还是会写到磁盘上的。 #、$区别参考博客：#、$区别 答：\${}是Properties文件中的变量占位符，它可以用于标签属性值和sql内部，属于静态文本替换，比如${driver}会被静态替换为com.mysql.jdbc.Driver。#{}是sql的参数占位符，Mybatis会将sql中的#{}替换为?号，在sql执行前会使用PreparedStatement的参数设置方法，按序给sql的?号占位符设置参数值，比如ps.setInt(0, parameterValue)，#{item.name}的取值方式为使用反射从参数对象中获取item对象的name属性值，相当于param.getItem().getName()。 Xml映射文件中，除了常见的select|insert|updae|delete标签之外，还有哪些标签？答：还有很多其他的标签：12345&lt;resultMap&gt;&lt;parameterMap&gt;&lt;sql&gt;&lt;include&gt;&lt;selectKey&gt; 加上动态sql的9个标签：1trim|where|set|foreach|if|choose|when|otherwise|bind 其中为sql片段标签，通过标签引入sql片段，为不支持自增的主键生成策略标签。 一级、二级缓存1）一级缓存: 基于 PerpetualCache 的 HashMap 本地缓存，其存储作用域为 Session，当 Session flush 或 close 之后，该 Session 中的所有 Cache 就将清空。 2）二级缓存与一级缓存其机制相同，默认也是采用 PerpetualCache，HashMap 存储，不同在于其存储作用域为 Mapper(Namespace)，并且可自定义存储源，如 Ehcache。要开启二级缓存，你需要在你的 SQL 映射文件中添加一行：1&lt;cache/&gt; 3）对于缓存数据更新机制，当某一个作用域(一级缓存 Session/二级缓存Namespaces)的进行了C/U/D 操作后，默认该作用域下所有 select 中的缓存将被 clear。]]></content>
      <categories>
        <category>mybatis</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[idea+springboot+freemarker热部署]]></title>
    <url>%2F2018%2F02%2F15%2Fidea-springboot-freemarker%E7%83%AD%E9%83%A8%E7%BD%B2%2F</url>
    <content type="text"><![CDATA[今天在学习springboot集成freemarker模板引擎修改代码时，发现每次修改一次freemarker文件时，都必须重启下应用，浏览器刷新才能显示修改后的内容，这样效率太低，每次启动一次应用都需要耗费大量时间。通过参考网上的资料终于解决了该问题，将部署步骤整理如下，方便后续参考。 第一步：在maven中加入devtools的依赖（这里我使用的是maven来管理项目） 第二步：在application.properties中设置禁用模板引擎缓存 12spring.freemarker.cache=falsespring.freemarker.settings.template_update_delay=0 第三步：修改IDEA的设置 打开 Settings –&gt; Build-Execution-Deployment –&gt; Compiler，将 Build project automatically.勾上。 点击 Help –&gt; Find Action..，或使用快捷键 Ctrl+Shift+A来打开 Registry…，将其中的compiler.automake.allow.when.app.running勾上。 全部设置完毕，重启一下IDEA。现在你就不必每次都手动的去点停止和启动了。]]></content>
      <categories>
        <category>技巧</category>
      </categories>
      <tags>
        <tag>springboot</tag>
        <tag>freemarker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql语句执行顺序]]></title>
    <url>%2F2018%2F02%2F13%2Fmysql%E8%AF%AD%E5%8F%A5%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[MySQL的语句一共分为11步，如下图所标注的那样，最先执行的总是FROM操作，最后执行的是LIMIT操作。其中每一个操作都会产生一张虚拟的表，这个虚拟的表作为一个处理的输入，只是这些虚拟的表对用户来说是透明的，但是只有最后一个虚拟的表才会被作为结果返回。如果没有在语句中指定某一个子句，那么将会跳过相应的步骤。 下面我们来具体分析一下查询处理的每一个阶段： （1）FORM: 对FROM的左边的表和右边的表计算笛卡尔积。产生虚表VT1。（选择相对小的表做基础表） （2）ON: 对虚表VT1进行ON筛选，只有那些符合的行才会被记录在虚表VT2中。 （3）JOIN： 如果指定了OUTER JOIN（比如left join、 right join），那么保留表中未匹配的行就会作为外部行添加到虚拟表VT2中，产生虚拟表VT3, 如果 from子句中包含两个以上的表的话，那么就会对上一个join连接产生的结果VT3和下一个表重复执行步骤1~3这三个步骤，一直到处理完所有的表为止。 （4）WHERE： 对虚拟表VT3进行WHERE条件过滤。只有符合的记录才会被插入到虚拟表VT4中。 （5）GROUP BY: 根据group by子句中的列，对VT4中的记录进行分组操作，产生VT5。 （6）CUBE | ROLLUP: 对表VT5进行cube或者rollup操作，产生表VT6。 （7）HAVING： 对虚拟表VT6应用having过滤，只有符合的记录才会被 插入到虚拟表VT7中。 （8）SELECT： 执行select操作，选择指定的列，插入到虚拟表VT8中。 （9）DISTINCT： 对VT8中的记录进行去重。产生虚拟表VT9. （10）ORDER BY: 将虚拟表VT9中的记录按照&lt;order_by_list&gt;进行排序操作，产生虚拟表VT10. （11）LIMIT：取出指定行的记录，产生虚拟表VT11, 并将结果返回。 有几个问题需要特别留意下： 1）对于包含outer join子句的查询，就有一个让人感到困惑的问题，到底在on筛选器还是用where筛选器指定逻辑表达式呢？ on和where的最大区别在于，如果在on应用逻辑表达式中，那么在第三步outer join中还可以把移除的行再次添加回来，而where的移除后得到的是最终结果。 举个简单的例子，有一个学生表（班级,姓名）和一个成绩表(姓名,成绩)，我现在需要返回一个x班级的全体同学的成绩，但是这个班级有几个学生缺考，也就是说在成绩表中没有记录。为了得到我们预期的结果我们就需要在on子句指定学生和成绩表的关系（学生.姓名=成绩.姓名）那么我们是否发现在执行第二步的时候，对于没有参加考试的学生记录就不会出现在vt2中，因为他们被on的逻辑表达式过滤掉了，但是我们用left outer join就可以把左表（学生）中没有参加考试的学生找回来，因为我们想返回的是x班级的所有学生，如果在on中应用学生.班级=’x’的话，left outer join会把所有班级的所有学生记录找回，所以只能在where筛选器中应用学生.班级=’x’ 因为它的过滤是最终的。 2）GROUP BY语句和DISTINCT语句不能同时用在同一个字段上！！！ 事实上如果应用了group by子句那么distinct是多余的，原因同样在于，分组的时候是将列中唯一的值分成一组，同时只为每一组返回一行记录，那么所以的记录都将是不相同的。]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git命令]]></title>
    <url>%2F2018%2F02%2F10%2Fgit%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[1. 将当前目录设置成一个Git仓库1234//进入需要创建Git仓库的目录，然后输入命令，则当前目录就被设置成了一个Git仓库，默认会自动生成一个.git文件夹git init //在创建项目时就将项目目录设置成一个Git仓库git init projectName 2. 将项目提交到本地仓库123456//将修改文件提交到暂存区的持久化容器中,可以同时提交多个文件git add fileName1 fileName2//将代码提交的Git仓库中，每次提交最好都加上后面的描述信息git commit -m &quot;description&quot;//查看git代码提交状态git status 3. 查看修改内容工作区和暂存区详细介绍 HEAD ———-&gt; commit版本 Index ———-&gt; staged版本(暂存区) 123456789//比较的是工作目录(Working tree)和暂存区域快照(index)之间的差异也就是修改之后还没有暂存起来的变化内容git diff//查看已经暂存起来的文件(staged)和上次提交时的快照之间(HEAD)的差异git diff --cachedgit diff --staged//显示工作区版本(Working tree)和HEAD的差别git diff HEAD//查看简化的diff结果，可以加上--stat参数git diff --stat 4. 查看git日志123456789101112//按照时间倒叙排列提交日志git log//显示提交信息的简单版本git log --oneline//可以显示每次提交包含的文件git log --stat//显示每次提交之间哪些内容改变git log --patch//查看分支合并图git log --graph//查询自己所有的操作以及对应版本的commit idgit reflog 5. 版本回退1234//回退到上一个版本，上一个版本就是HEAD^，上上一个版本就是HEAD^^，往上n个版本写n个^比较容易数不过来，所以写成HEAD~ngit reset --hard HEAD^//回退到之前的某个版本，commit_id可以通过git log命令得到,若要回到未来版本，需要用git reflog来得到commit_idgit reset --hard commit_id 6. 撤销修改123456789//场景1：当改乱了工作区某个文件的内容，想直接丢弃工作区的修改时git checkout --fileName//场景2：不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改//先回到场景1git reset HEAD fileNamegit checkout --fileName场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，可以使用版本回退命令，不过前提是没有推送到远程库。 7. 删除文件12345//将文件从版本库中删除，同时提交修改git rm fileNamegit commit -m &quot;remove test.txt&quot;//如果文件已经提交到版本库并且被误删了，还可以使用如下命令还原git checkout --fileName 8. 添加远程仓库1234//关联一个远程库git remote add origin git@server-name:path/repo-name.git//第一次推送master分支的所有内容，第一次推送需要-u选项git push -u origin master 9. 从远程仓库克隆12//后面填写需要克隆仓库的地址git clone git@github.com:michaelliao/gitskills.git 10. 创建与合并分支创建与合并分支详解123456789101112//查看分支git branch//创建分支(&lt;name&gt;为分支名)git branch &lt;name&gt;//切换分支git checkout &lt;name&gt;//创建+切换分支git checkout -b &lt;name&gt;//合并某分支到当前分支git merge &lt;name&gt;//删除分支git branch -d &lt;name&gt; 当多个分支同时修改了同一个文件时候，需要解决分支冲突，分支冲突通常需要手动解决。解决分支冲突详解 11. 分支管理策略在实际开发中，应该按照几个基本原则进行分支管理： 首先，master分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活； 那在哪干活呢？干活都在dev分支上，也就是说，dev分支是不稳定的，到某个时候，比如1.0版本发布时，再把dev分支合并到master上，在master分支发布1.0版本； 你和你的小伙伴们每个人都在dev分支上干活，每个人都有自己的分支，时不时地往dev分支上合并就可以了。 所以，团队合作的分支看起来就像这样： 12. BUG分支参考：BUG分支 13. 多人合作实际工作中的情况：多人合作详解]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux常用命令]]></title>
    <url>%2F2018%2F02%2F05%2FLinux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[竖杠 |管道就像水管一样，将前面命令的执行结果输送给后面的命令。 123//&apos;ls -l&apos;负责收集当前目录下的文件信息，然后将这些文件名作为结果输送到管道，//wc这个命令接着就从管道中把它们读取出来，并计算出行数，单词个数和总字符数。ls -l | wc 查看日志命令(tail)tail的功能就是输出文件的尾部内容。 Linux文件的日志文件通常存储在’/var/log’目录下。 123456//输出syslog文件的尾部几行tail /var/log/syslog//tail会继续监视日志文件，输出写入到文件的下一行。这意味着你可以在终端窗口里面实时关注什么写入到syslogtail -f /var/log/syslog//只想查看写入到syslog的尾部5行tail -f -n 5 /var/log/syslog CPU相关命令ps：查看当前瞬间系统的进程信息 pstree：以树状方式查看当前系统的进程 top：持续跟踪系统的进程情况1234//动态跟踪所有进程（&lt;向左翻页，&gt;向右翻页）top//动态跟踪PID为1234的进程top -p 1234 kill：给一个指定的进程发送一个信号123456//列出当前系统所支持的所有信号kill -l//给PID为1234的进程发送9号信号kill -9 1234 //给PID为1234的进程发送SIGINT信号kill -s SIGINT 1234 nice：以某一个指定的NICE值启动进程12//以NICE值为5的起始状态来启动程序./examplenice -n 5 ./example renice：动态修改一个进程的NICE值12//将PID为1234的进程的NICE值调整为15renice -n 15 1234 网络相关命令ifconfig：查看系统当前活跃的网络接口123456//查看系统当前所有的活跃的网络接口信息ifconfig //查看eth0相关的信息ifconfig eth0 //将网络接口eth0的IP地址设置为192.168.1.5ifconfig eth0 192.168.1.5 ping：给某主机发送ICMP数据包以检测网络 12//给百度服务器发送ICMP数据包以检测网络是否连通ping www.baidu.com netstat：查看系统网络连接的相关信息 123456//查看系统中所有状态的网络连接信息netstat -a//查看系统中处于监听状态的网络连接信息netstat -l//查看系统中所有状态的TCP（或者UDP 或者UNIX域）的网络连接信息netstat -at （或者 netstat -au 或者 netstat -ax） ifdown：禁用网络接口 12//禁用网络接口eth0ifdown eth0 ifup：启用网络接口 12//启用网络接口eth0ifup eth0 host：查看域名所对应的IP地址12//查看域名www.baidu.com所对应的IP地址，以此来检测本机的DNS服务设置正确与否host www.baidu.com route：查看、设置路由和网关相关信息 1234//查看网关地址route -n//添加默认网关为192.168.1.1route add default gw 192.168.1.1 ln：创建一个连接文件 1234//为文件file创建一个硬连接（别名）,叫file1ln file file1 //为文件file创建一个软连接，叫file2 ln -s file file2]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java IO 基础]]></title>
    <url>%2F2018%2F01%2F28%2Fjava-IO-%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[参考：Java IO技术博客 BIO（同步并阻塞） 字节输入流 字节输出流 字符输入流 字符输出流 抽象基类 InputStream OutputStream Reader Writer 访问文件 FileInputStream FileOutputStream FileReader FileWriter 访问数组 ByteArrayInputStream ByteArrayOutputStream CharArrayReader CharArrayWriter 缓冲流 BufferedInputStream BufferedOutputStream BufferedReader BufferedWriter 打印流 PrintStream PrintWriter 说明： 上面是一些比较常用的输入输出流，缓冲流可以一次处理一行文本，以换行符为标志，打印流的输出功能非常强大，方便处理打印操作。 注意： PrintWriter 的close()方法通常自带flush()。 使用场景： 输入输出内容为文本： 使用字符流 输入输出内容为二进制： 使用字节流 java使用处理流来包装节点流是一种典型的装饰器设计模式。 RandomAccessFile类说明： RandomAccessFile是java输入/输出流体系中功能最丰富的文件内容访问类，可以读取和向文件写入数据。 优点：支持“随机访问”，可以直接跳转到文件的任意位置读写数据。 （注意：在向文件指定位置插入内容时，会覆盖掉插入点之后原有的内容） 缺点：只能读写文件，不能读写其它IO节点。 使用场景： 1）只需要访问文件部分内容，而不是把文件从头读到尾。 2）向已存在的文件后面追加内容，而不是从文件开始的地方直接输出。 对象序列化说明：将实现序列化的Java对象转换成字节序列，这些字节序列可以保存在磁盘上，或者能够通过网络传输，方便以后重新再恢复成原来的对象。 注意：定义的类必须实现Serializable接口 NIO（同步非阻塞）（JDK1.4） 新IO采用了内存映射文件的方式来处理输入/输出，新IO将文件或文件的一段区域映射到内存中，这样就可以像访问内存一样来访问文件了（模拟了操作系统虚拟内存的概念），相比传统的输入/输出要快！ Channels and Buffers（通道和缓冲区）： 标准的IO基于字节流和字符流进行操作的，而NIO是基于通道（Channel）和缓冲区（Buffer）进行操作，数据总是从通道读取到缓冲区中，或者从缓冲区写入到通道中。 Selectors（选择器）： Java NIO引入了选择器的概念，选择器用于监听多个通道的事件（比如：连接打开，数据到达）。因此，单个的线程可以监听多个数据通道。 Asynchronous IO（异步IO）： Java NIO可以让你异步的使用IO，例如：当线程从通道读取数据到缓冲区时，线程还是可以进行其他事情。当数据被写入到缓冲区时，线程可以继续处理它。从缓冲区写入通道也类似。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java集合面试]]></title>
    <url>%2F2018%2F01%2F25%2Fjava%E9%9B%86%E5%90%88%E9%9D%A2%E8%AF%95%2F</url>
    <content type="text"><![CDATA[在Java集合框架源码中有如下几点说明： 1) 实现RandomAccess接口目的：说明支持快速访问，保证使用下标访问比用迭代器访问要快。否则，迭代器访问要快。 2) 实现Cloneable接口目的：保证对象能实现克隆。 3) AbstractList中的modCount变量（修改次数），通常会在迭代器中使用它，也就是说，在迭代器遍历的过程中，一旦发现这个对象的mcount和迭代器中存储的mcount不一样，那就抛异常。也就是Fail-Fast机制。对集合的add和remove都会改变modcount的值，那么在迭代器初始化过程中会将这个值赋给迭代器的expectedModCount。在迭代过程中，判断modCount跟expectedModCount是否相等，如果不相等就表示已经有其他线程修改了集合。 4) Fail-Fast VS Fail-Safe Fail-Safe（安全失败）：基于对底层集合做拷贝。因此，它不受源集合上修改的影响。java.util.concurrent包下面的所有的类都是安全失败的。 Fail-Fast（快速失败）：java.util包下面的所有的集合类都是快速失败的，快速失败的迭代器会抛出ConcurrentModificationException异常，而安全失败的迭代器永远不会抛出这样的异常。 List有序可重复集合 ArrayList底层实现： 基于动态数组 增：末尾添加元素，时间复杂度O(1); 任意位置添加元素，时间复杂度为O(N)。删：末尾删除元素，时间复杂度O(1); 任意位置删除元素，时间复杂度为O(N)。查：时间复杂度O(1)。 非线程安全（性能高） Vector功能基本同ArrayList。 线程安全（性能低） LinkedList底层实现： 双向链表 增：末尾添加元素，时间复杂度O(1); 任意位置添加元素，时间复杂度为O(N)。删：末尾删除元素，时间复杂度O(1); 任意位置删除元素，时间复杂度为O(N)。查：时间复杂度O(N)。 MapHashMap参考：HashMap源码解析ConcurrentHashMap源码解析 底层实现： 散列表+数组+链表+红黑树（JDK1.8增加了红黑树部分） 原理： 它根据键的hashCode值存储数据，大多数情况下可以直接定位到它的值，因而具有很快的访问速度，但遍历顺序却是不确定的。HashMap最多只允许一条记录的键为null，允许多条记录的值为null。 源码说明： HashMap在Map.Entry静态内部类实现中存储key-value对。HashMap使用哈希算法，在put和get方法中，它使用hashCode()和equals()方法。当我们通过传递key-value对调用put方法的时候，HashMap使用Key hashCode()和哈希算法来找出存储key-value对的索引。Entry存储在LinkedList中，所以如果存在entry，它使用equals()方法来检查传递的key是否已经存在，如果存在，它会覆盖value，如果不存在，它会创建一个新的entry然后保存。当我们通过传递key调用get方法时，它再次使用hashCode()来找到数组中的索引，然后使用equals()方法找出正确的Entry，然后返回它的值。下面的图片解释了详细内容。 其它关于HashMap比较重要的问题是容量、负荷系数和阀值调整。HashMap默认的初始容量是32，负荷系数是0.75。阀值是为负荷系数乘以容量，无论何时我们尝试添加一个entry，如果map的大小比阀值大的时候，HashMap会对map的内容进行重新哈希，且使用更大的容量。容量总是2的幂，所以如果你知道你需要存储大量的key-value对，比如缓存从数据库里面拉取的数据，使用正确的容量和负荷系数对HashMap进行初始化是个不错的做法。 线程安全： HashMap非线程安全，即任一时刻可以有多个线程同时写HashMap，可能会导致数据的不一致。如果需要满足线程安全，可以用Collections的synchronizedMap方法使HashMap具有线程安全的能力，或者使用ConcurrentHashMap。 对比Hashtable： Hashtable是遗留类，很多映射的常用功能与HashMap类似，不同的是它承自Dictionary类，并且是线程安全的，任一时间只有一个线程能写Hashtable，并发性不如ConcurrentHashMap，因为ConcurrentHashMap引入了分段锁。Hashtable不建议在新代码中使用，不需要线程安全的场合可以用HashMap替换，需要线程安全的场合可以用ConcurrentHashMap替换。（不允许键或值为空） weakHashMap用法基本同HashMap。 区别：HashMap中的key保留了对实际对象的强引用，只要该HashMap对象不被销毁，该HashMap的所有key所引用的对象就不会被垃圾回收。 WeakHashMap中的key只保留了对于实际对象的弱引用，如果WeakHashMap对象的key所引用的对象没有被其他强引用变量所引用，则这些key所引用的对象可能被垃圾回收。 LinkedHashMap参考：LinkedHashMap源码详解 底层实现： 散列表+数组+双向循环链表 说明： LinkedHashMap是HashMap的子类，实现的原理跟HashMap差不多，唯一的区别就是LinkedHashMap多了一个双向循环链表。因为有双向循环列表，所以LinkedHashMap能够记录插入元素的顺序，而HashMap不能，可以根据元素的插入顺序和访问顺序来遍历集合。 TreeMap参考：TreeMap源码详解 底层实现： 散列表+红黑树 说明： TreeMap存储key-value节点对时，需要根据key对节点进行排序。它能保证所有的key-value对处于一种有序的状态。 TreeMap有两种排序方式，自然排序和定制排序。 自然排序：TreeMap所有key必须实现Comparable接口。 定制排序：创建TreeMap时，传入一个Comparator对象，该对象负责对TreeMap中的所有key进行排序。使用定制排序的时候不需要Map的key来实现Comparable接口。 适用场景： 添加，查询元素：HashMap性能较好。(TreeMap需要红黑树算法来维护集合元素次序，性能低). 保存排序的集合：TreeMap. 遍历集合：LinkedHashMap. Set相当于一个罐子，不允许包含重复元素 HashSet参考： LinkedHashSet的实现原理 底层实现： 基于HashMap实现。在它里面放置的元素对应到map里面的key部分，而在map中与key对应的value用一个固定Object()对象保存。 LinkedHashSet说明： 会根据元素的插入顺序来访问集合中的元素。 底层实现： 它继承于HashSet，又基于LinkedHashMap来实现的。 TreeSet说明： 确保集合处于排序状态。 底层实现： TreeSet实际上是TreeMap实现的。 当构造TreeSet时；若使用不带参数的构造函数，则TreeSet的使用自然比较器；若用户需要使用自定义的比较器，则需要使用带比较器的参数。 适用场景： 添加，查询元素：HashSet性能较好。(TreeSet需要红黑树算法来维护集合元素次序，性能低). 保存排序的集合：TreeSet. 遍历集合：LinkedHashSet.]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java基础面试总结]]></title>
    <url>%2F2018%2F01%2F20%2Fjava%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[面向对象的三大特性1) 封装，也就是把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。 2) 继承，是指可以让某个类型的对象获得另一个类型的对象的属性和方法。 3) 多态，是指一个类实例的相同方法在不同情形有不同表现形式。 重载重写1） 重载是在同一个类中的两个或两个以上的方法，拥有相同的方法名，但是参数却不相同，方法体也不相同，最常见的重载的例子就是类的构造函数。 两同一不同原则： 两同：同一个类，方法名相同；不同：参数列表不同； 注意：方法的其它部分，比如方法的返回值类型、方法修饰符等都与方法重载没有任何关系。 2） 重写是子类的方法覆盖父类的方法，要求方法名和参数都相同。 两同两小一大原则： 两同：方法名相同、形参列表相同；两小：子类方法返回值类型小于父类方法返回值类型或相等；子类方法声明抛出的异常类型应比父类方法声明抛出的异常类型更小或相等。一大：子类方法的访问权限要大于等于父类方法的访问权限。 注意： private修饰的相同方法不是被重写了，而是另一个重新定义的方法，因为private只对当前类可见。 常用Object类的方法equals()方法== 运算符 对于基本类型变量，如果两者数值相同，则返回true。对于引用类型变量，只有两者指向同一个对象，才返回true。 Object默认提供的功能只是比较两个对象的地址是否相同。通常需要重载equals()方法。 例如：在String类中就重载了equals()方法，用来判断String对象包含的字符序列是否相同。 12345678910111213141516171819//比较严谨的重载equals()方法的实例如下public boolean equals(Object obj) &#123; //如果两个对象为同一个对象 if (this == obj) &#123; return true; &#125; //getClass()获得的是对象的运行时类型 if (obj != null &amp;&amp; obj.getClass() == Person.class) &#123; Person personObj = (Person)obj; //并且当前对象的idStr 与 obj对象的idStr 相等的时候才可以判断两个对象是相等的 if (this.getIdStr().equals(personObj.getIdStr()) &#123; return true; &#125; &#125; return false;&#125; toString()方法通常在打印对象信息时会使用到toString()方法，比如：12345System.out.println(p);//等价于//输出：Person@15db9742//打印格式为：类名+@+hashCodeSystem.out.println(p.toString); 通常需要重写toString()方法，该方法总是会返回该对象的所有令人感兴趣的信息所组成的字符串，可以返回如下格式的字符串：1类名[field1=值1, field2=值2,...] hashCode()方法 hashCode()方法主要在集合中才会用到。 将对象放入集合中的步骤： 1) 首先判断要放入对象的hashcode值与集合中的任意一个元素的hashcode值是否相等，如果不相等直接将该对象放入集合中。 2) 如果hashcode值相等，然后再通过equals方法判断要放入对象与集合中的任意一个对象是否相等，如果equals判断不相等，直接将该元素放入到集合中，否则不放入。 参考：hashCode与equals的区别与联系 finalize()方法 在垃圾回收机制回收某个对象占用的内存之前，需要程序调用一定的方法来清理资源。而java提供了默认的机制来清理该对象的资源，该机制就是finalize()方法。 注意： 垃圾回收机制什么时候调用对象的finalize()方法是完全透明的，只有当程序认为需要更多的额外内存空间时，它才能够进行垃圾回收的工作。也就是说finalize()方法是在垃圾回收之前执行的。 比如： 当一个对象虽然失去了引用，但是只占用了少量的内存资源，而且系统没有很严重的内存需求，此时，垃圾回收机制没有试图去回收对象所占用的资源，这样对象的finalize()方法是不会被调用的。 finalize()方法4个特点：1) 永远不要主动调用某个对象的finalize()方法，该方法应交给垃圾回收机制调用。 2) finalize()方法何时被调用，是否被调用具有不确定性，不要把finalize()方法当成一定会被执行的方法。 3) 当JVM执行可恢复对象的finalize()方法时，可能使该对象或系统中其他对象重新变成可达状态。 4) 当JVM执行finalize()方法时出现异常时，垃圾回收机制不会报告异常，程序继续执行。 getClass()方法 返回当前对象所属类对应的CLASS对象(具体方法查看API); clone()方法 用来帮助其他对象来实现“自我克隆”，也就是得到一个当前对象的副本，而且两者完全隔离。Object类提供的clone()方法使用了protected修饰符，该方法只能够被子类重写或调用。 注意： Object类中提供的Clone机制只可以对对象里面的各实例变量进行“简单复制”，如果实例变量的类型为引用类型，Object的Clone机制也只能够简单地复制这个引用变量。 参考：Java疯狂讲义 P247页 类访问权限 修饰词 本类 同一个包的类 继承类 其他类 private √ × × × 无（默认） √ √ × × protected √ √ √ × public √ √ √ √ String、stringbuffer、stringbuilder 联系、区别、源码String：字符串常量 StringBuffer：字符串变量（线程安全） StringBuilder：字符串变量（线程非安全） 三者在执行速度方面的比较：StringBuilder &gt; StringBuffer &gt; String 使用场景： 1) 如果要操作少量的数据用 = String 2) 单线程操作字符串缓冲区下操作大量数据 = StringBuilder 3) 多线程操作字符串缓冲区下操作大量数据 = StringBuffer 为什么线程安全比非线程安全性能低？ 1) 线程的安全是以牺牲性能为代价的，所谓线程安全就是多了个加锁，解锁的操作，比如100亿个操作中都要加锁和解锁，线程是安全了，但性能就下降了。 2) 有些软件是以性能为主的，为了提高性能，就少了加锁，解锁的操作，虽然容易出现并发性问题，但性能却提高了。 final修饰符 final修饰的变量不可改变。 final修饰成员变量说明：final修饰的成员变量必须由程序员显示地指定初始值。 类变量：必须在静态初始化块中指定初始值或声明该类变量时指定初始值，而且只能在两个地方的其中之一指定。 实例变量：必须在非静态初始化块、声明该变量或构造器中指定初始值，而且只能在三个地方的其中之一指定。 final修饰局部变量final修饰局部变量在定义时没有指定默认值，可以在后面代码中对该final变量赋初始值，但是只能一次，不可重复赋值。 final修饰的形参不能在方法体内赋值，因为形参在调用该方法时，是由系统根据传入的参数来完成初始化的。 final修饰基本类型变量和引用类型变量final修饰基本类型变量时，不可以对基本类型变量重新赋值，因此基本类型变量不能被改变。 final修饰引用类型变量时，只保证该引用类型变量所引用的地址不会改变，即一直引用同一个对象，但这个对象完全可以发生改变。 final修饰的方法final修饰的方法不能被重写，并不是不能被重载。（例如Object类中的getClass()方法就是一个final方法） final修饰类final修饰的类不可以有子类 immutable不可变类：当你获得这个类的一个实例引用时，你不可以改变这个实例的内容。不可变类的实例一但创建，其内在成员变量的值就不能被修改。 抽象类和接口的联系区别共同点： 1） 接口和抽象类都不能被实例化，它们都在继承树的顶端，用来被其他类实现和继承。 2） 接口和抽象类都可以包含抽象方法，实现接口或继承抽象类的普通子类都必须实现这些抽象方法。 设计目的： 接口主要体现一种规范，它类似于整个系统的“总纲”，它制定了系统各模块应该遵循的标准，因此一个系统中的接口不应该经常改变。 抽象类主要体现了一种模板式设计。可以认为是系统实现过程当中的中间产品。它已经实现了系统的部分功能（哪些已经提供实现的方法） 区别： 1）接口中只能包含抽象方法、静态方法和默认方法，不能为普通方法提供方法的实现；而抽象类则完全可以包含普通方法。 2）接口中只能定义静态常量，不能定义普通成员变量；抽象类里则可以定义普通成员变量，也可以定义静态常量。 3）接口里不包含构造器；抽象类里可以包含构造器；但是抽象类中的构造器不是用来创建对象，而是让其子类调用这些构造器来完成属于抽象类的初始化操作。 4）接口中不可以包含初始化块；但是抽象类中可以包含初始化块。 5）一个类最多只能有一个直接父类，包括抽象类；但一个类可以直接实现多个接口，通过实现多个接口可以弥补java单继承的不足。 什么时候用接口什么时候用抽象类？ 抽象类都是从一些相似的对象中抽象出来的一个相对无法具体描述的一个类，它的子类之间是有相似性的； 接口更侧重于对相同的动作进行抽象封装。当你关注一个事物的本质的时候，用抽象类；当你关注一个操作的时候，用接口。 对象的初始化过程1）初始化父类中的静态成员变量和静态代码块； 2）初始化子类中的静态成员变量和静态代码块； 3）初始化父类的普通成员变量和代码块，再执行父类的构造方法； 4）初始化子类的普通成员变量和代码块，再执行子类的构造方法； static修饰符static修饰变量1）对于静态变量在内存中只有一个拷贝（节省内存），JVM只为静态分配一次内存。 2）对于实例变量，每创建一个实例，就会为实例变量分配一次内存，实例变量可以在内存中有多个拷贝，互不影响（灵活）。 static方法静态方法中不能访问非静态成员方法和非静态成员变量，但是在非静态成员方法中是可以访问静态成员方法和变量的 static代码块static代码块是在类中独立于类成员的static语句块，可以有多个，位置可以随便放，它不在任何的方法体内，JVM加载类时会执行这些静态的代码块，如果static代码块有多个，JVM将按照它们在类中出现的先后顺序依次执行它们，每个代码块只会被执行一次。 关键的作用：用来形成静态代码块以优化程序性能。因为它只会在类加载的时候执行一次，所以能优化程序性能。 instanceof运算符编译时类型必须是如下3种情况： 1）要么与后面的类相同；2）要么是后面类型的父类；3）要么是后面类型的子类； 如果前面操作数的编译时类型与后面的类型没有任何关系，程序将没发通过编译。 运行阶段： 被转型变量所引用对象的实际类型必须是目标类型的实例，或者是目标类型的子类，实现类的实例，否则在运行时将引发ClassCastException异常。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>面试</tag>
      </tags>
  </entry>
</search>
