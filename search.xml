<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[java集合面试]]></title>
    <url>%2F2018%2F04%2F23%2Fjava%E9%9B%86%E5%90%88%E9%9D%A2%E8%AF%95%2F</url>
    <content type="text"><![CDATA[在Java集合框架源码中有如下几点说明： 1) 实现RandomAccess接口目的：说明支持快速访问，保证使用下标访问比用迭代器访问要快。否则，迭代器访问要快。 2) 实现Cloneable接口目的：保证对象能实现克隆。 3) AbstractList中的modCount变量（修改次数），通常会在迭代器中使用它，也就是说，在迭代器遍历的过程中，一旦发现这个对象的mcount和迭代器中存储的mcount不一样，那就抛异常。也就是Fail-Fast机制。对集合内容的修改都会改变modcount的值，那么在迭代器初始化过程中会将这个值赋给迭代器的expectedModCount。在迭代过程中，判断modCount跟expectedModCount是否相等，如果不相等就表示已经有其他线程修改了集合。 4) Fail-Fast VS Fail-Safe Fail-Safe（安全失败）：基于对底层集合做拷贝。因此，它不受源集合上修改的影响。java.util.concurrent包下面的所有的类都是安全失败的。 Fail-Fast（快速失败）：java.util包下面的所有的集合类都是快速失败的，快速失败的迭代器会抛出ConcurrentModificationException异常，而安全失败的迭代器永远不会抛出这样的异常。 List有序可重复集合 ArrayList底层实现： 基于动态数组 增：末尾添加元素，时间复杂度O(1); 任意位置添加元素，时间复杂度为O(N)。删：末尾删除元素，时间复杂度O(1); 任意位置删除元素，时间复杂度为O(N)。查：时间复杂度O(1)。 非线程安全（性能高） Vector功能基本同ArrayList。 线程安全（性能低） LinkedList底层实现： 双向链表 增：末尾添加元素，时间复杂度O(1); 任意位置添加元素，时间复杂度为O(N)。删：末尾删除元素，时间复杂度O(1); 任意位置删除元素，时间复杂度为O(N)。查：时间复杂度O(N)。 MapHashMap参考：HashMap源码解析ConcurrentHashMap源码解析 底层实现： 散列表+数组+链表+红黑树（JDK1.8增加了红黑树部分） 原理： 它根据键的hashCode值存储数据，大多数情况下可以直接定位到它的值，因而具有很快的访问速度，但遍历顺序却是不确定的。HashMap最多只允许一条记录的键为null，允许多条记录的值为null。 源码说明： HashMap在Map.Entry静态内部类实现中存储key-value对。HashMap使用哈希算法，在put和get方法中，它使用hashCode()和equals()方法。当我们通过传递key-value对调用put方法的时候，HashMap使用Key hashCode()和哈希算法来找出存储key-value对的索引。Entry存储在LinkedList中，所以如果存在entry，它使用equals()方法来检查传递的key是否已经存在，如果存在，它会覆盖value，如果不存在，它会创建一个新的entry然后保存。当我们通过传递key调用get方法时，它再次使用hashCode()来找到数组中的索引，然后使用equals()方法找出正确的Entry，然后返回它的值。下面的图片解释了详细内容。 其它关于HashMap比较重要的问题是容量、负荷系数和阀值调整。HashMap默认的初始容量是32，负荷系数是0.75。阀值是为负荷系数乘以容量，无论何时我们尝试添加一个entry，如果map的大小比阀值大的时候，HashMap会对map的内容进行重新哈希，且使用更大的容量。容量总是2的幂，所以如果你知道你需要存储大量的key-value对，比如缓存从数据库里面拉取的数据，使用正确的容量和负荷系数对HashMap进行初始化是个不错的做法。 线程安全： HashMap非线程安全，即任一时刻可以有多个线程同时写HashMap，可能会导致数据的不一致。如果需要满足线程安全，可以用Collections的synchronizedMap方法使HashMap具有线程安全的能力，或者使用ConcurrentHashMap。 对比Hashtable： Hashtable是遗留类，很多映射的常用功能与HashMap类似，不同的是它承自Dictionary类，并且是线程安全的，任一时间只有一个线程能写Hashtable，并发性不如ConcurrentHashMap，因为ConcurrentHashMap引入了分段锁。Hashtable不建议在新代码中使用，不需要线程安全的场合可以用HashMap替换，需要线程安全的场合可以用ConcurrentHashMap替换。（不允许键或值为空） weakHashMap用法基本同HashMap。 区别：HashMap中的key保留了对实际对象的强引用，只要该HashMap对象不被销毁，该HashMap的所有key所引用的对象就不会被垃圾回收。 WeakHashMap中的key只保留了对于实际对象的弱引用，如果WeakHashMap对象的key所引用的对象没有被其他强引用变量所引用，则这些key所引用的对象可能被垃圾回收。 LinkedHashMap参考：LinkedHashMap源码详解 底层实现： 散列表+数组+双向循环链表 说明： LinkedHashMap是HashMap的子类，实现的原理跟HashMap差不多，唯一的区别就是LinkedHashMap多了一个双向循环链表。因为有双向循环列表，所以LinkedHashMap能够记录插入元素的顺序，而HashMap不能，可以根据元素的插入顺序和访问顺序来遍历集合。 TreeMap参考：TreeMap源码详解 底层实现： 散列表+红黑树 说明： TreeMap存储key-value节点对时，需要根据key对节点进行排序。它能保证所有的key-value对处于一种有序的状态。 TreeMap有两种排序方式，自然排序和定制排序。 自然排序：TreeMap所有key必须实现Comparable接口。 定制排序：创建TreeMap时，传入一个Comparator对象，该对象负责对TreeMap中的所有key进行排序。使用定制排序的时候不需要Map的key来实现Comparable接口。 适用场景： 添加，查询元素：HashMap性能较好。(TreeMap需要红黑树算法来维护集合元素次序，性能低). 保存排序的集合：TreeMap. 遍历集合：LinkedHashMap. Set相当于一个罐子，不允许包含重复元素 HashSet参考： LinkedHashSet的实现原理 底层实现： 基于HashMap实现。在它里面放置的元素对应到map里面的key部分，而在map中与key对应的value用一个固定Object()对象保存。 LinkedHashSet说明： 会根据元素的插入顺序来访问集合中的元素。 底层实现： 它继承于HashSet，又基于LinkedHashMap来实现的。 TreeSet说明： 确保集合处于排序状态。 底层实现： TreeSet实际上是TreeMap实现的。 当构造TreeSet时；若使用不带参数的构造函数，则TreeSet的使用自然比较器；若用户需要使用自定义的比较器，则需要使用带比较器的参数。 适用场景： 添加，查询元素：HashSet性能较好。(TreeSet需要红黑树算法来维护集合元素次序，性能低). 保存排序的集合：TreeSet. 遍历集合：LinkedHashSet.]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java基础面试总结]]></title>
    <url>%2F2018%2F04%2F22%2Fjava%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[面向对象的三大特性1) 封装，也就是把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。 2) 继承，是指可以让某个类型的对象获得另一个类型的对象的属性和方法。 3) 多态，是指一个类实例的相同方法在不同情形有不同表现形式。 重载重写1） 重载是在同一个类中的两个或两个以上的方法，拥有相同的方法名，但是参数却不相同，方法体也不相同，最常见的重载的例子就是类的构造函数。 两同一不同原则： 两同：同一个类，方法名相同；不同：参数列表不同； 注意：方法的其它部分，比如方法的返回值类型、方法修饰符等都与方法重载没有任何关系。 2） 重写是子类的方法覆盖父类的方法，要求方法名和参数都相同。 两同两小一大原则： 两同：方法名相同、形参列表相同；两小：子类方法返回值类型小于父类方法返回值类型或相等；子类方法声明抛出的异常类型应比父类方法声明抛出的异常类型更小或相等。一大：子类方法的访问权限要大于等于父类方法的访问权限。 注意： private修饰的相同方法不是被重写了，而是另一个重新定义的方法，因为private只对当前类可见。 常用Object类的方法equals()方法== 运算符 对于基本类型变量，如果两者数值相同，则返回true。对于引用类型变量，只有两者指向同一个对象，才返回true。 Object默认提供的功能只是比较两个对象的地址是否相同。通常需要重载equals()方法。 例如：在String类中就重载了equals()方法，用来判断String对象包含的字符序列是否相同。 12345678910111213141516171819//比较严谨的重载equals()方法的实例如下public boolean equals(Object obj) &#123; //如果两个对象为同一个对象 if (this == obj) &#123; return true; &#125; //getClass()获得的是对象的运行时类型 if (obj != null &amp;&amp; obj.getClass() == Person.class) &#123; Person personObj = (Person)obj; //并且当前对象的idStr 与 obj对象的idStr 相等的时候才可以判断两个对象是相等的 if (this.getIdStr().equals(personObj.getIdStr()) &#123; return true; &#125; &#125; return false;&#125; toString()方法通常在打印对象信息时会使用到toString()方法，比如：12345System.out.println(p);//等价于//输出：Person@15db9742//打印格式为：类名+@+hashCodeSystem.out.println(p.toString); 通常需要重写toString()方法，该方法总是会返回该对象的所有令人感兴趣的信息所组成的字符串，可以返回如下格式的字符串：1类名[field1=值1, field2=值2,...] hashCode()方法 hashCode()方法主要在集合中才会用到。 将对象放入集合中的步骤： 1) 首先判断要放入对象的hashcode值与集合中的任意一个元素的hashcode值是否相等，如果不相等直接将该对象放入集合中。 2) 如果hashcode值相等，然后再通过equals方法判断要放入对象与集合中的任意一个对象是否相等，如果equals判断不相等，直接将该元素放入到集合中，否则不放入。 参考：hashCode与equals的区别与联系 finalize()方法 在垃圾回收机制回收某个对象占用的内存之前，需要程序调用一定的方法来清理资源。而java提供了默认的机制来清理该对象的资源，该机制就是finalize()方法。 注意： 垃圾回收机制什么时候调用对象的finalize()方法是完全透明的，只有当程序认为需要更多的额外内存空间时，它才能够进行垃圾回收的工作。也就是说finalize()方法是在垃圾回收之前执行的。 比如： 当一个对象虽然失去了引用，但是只占用了少量的内存资源，而且系统没有很严重的内存需求，此时，垃圾回收机制没有试图去回收对象所占用的资源，这样对象的finalize()方法是不会被调用的。 finalize()方法4个特点：1) 永远不要主动调用某个对象的finalize()方法，该方法应交给垃圾回收机制调用。 2) finalize()方法何时被调用，是否被调用具有不确定性，不要把finalize()方法当成一定会被执行的方法。 3) 当JVM执行可恢复对象的finalize()方法时，可能使该对象或系统中其他对象重新变成可达状态。 4) 当JVM执行finalize()方法时出现异常时，垃圾回收机制不会报告异常，程序继续执行。 getClass()方法 返回当前对象所属类对应的CLASS对象(具体方法查看API); clone()方法 用来帮助其他对象来实现“自我克隆”，也就是得到一个当前对象的副本，而且两者完全隔离。Object类提供的clone()方法使用了protected修饰符，该方法只能够被子类重写或调用。 注意： Object类中提供的Clone机制只可以对对象里面的各实例变量进行“简单复制”，如果实例变量的类型为引用类型，Object的Clone机制也只能够简单地复制这个引用变量。 参考：Java疯狂讲义 P247页 类访问权限 修饰词 本类 同一个包的类 继承类 其他类 private √ × × × 无（默认） √ √ × × protected √ √ √ × public √ √ √ √ String、stringbuffer、stringbuilder 联系、区别、源码String：字符串常量 StringBuffer：字符串变量（线程安全） StringBuilder：字符串变量（线程非安全） 三者在执行速度方面的比较：StringBuilder &gt; StringBuffer &gt; String 使用场景： 1) 如果要操作少量的数据用 = String 2) 单线程操作字符串缓冲区下操作大量数据 = StringBuilder 3) 多线程操作字符串缓冲区下操作大量数据 = StringBuffer 为什么线程安全比非线程安全性能低？ 1) 线程的安全是以牺牲性能为代价的，所谓线程安全就是多了个加锁，解锁的操作，比如100亿个操作中都要加锁和解锁，线程是安全了，但性能就下降了。 2) 有些软件是以性能为主的，为了提高性能，就少了加锁，解锁的操作，虽然容易出现并发性问题，但性能却提高了。 final修饰符 final修饰的变量不可改变。 final修饰成员变量说明：final修饰的成员变量必须由程序员显示地指定初始值。 类变量：必须在静态初始化块中指定初始值或声明该类变量时指定初始值，而且只能在两个地方的其中之一指定。 实例变量：必须在非静态初始化块、声明该变量或构造器中指定初始值，而且只能在三个地方的其中之一指定。 final修饰局部变量final修饰局部变量在定义时没有指定默认值，可以在后面代码中对该final变量赋初始值，但是只能一次，不可重复赋值。 final修饰的形参不能在方法体内赋值，因为形参在调用该方法时，是由系统根据传入的参数来完成初始化的。 final修饰基本类型变量和引用类型变量final修饰基本类型变量时，不可以对基本类型变量重新赋值，因此基本类型变量不能被改变。 final修饰引用类型变量时，只保证该引用类型变量所引用的地址不会改变，即一直引用同一个对象，但这个对象完全可以发生改变。 final修饰的方法final修饰的方法不能被重写，并不是不能被重载。（例如Object类中的getClass()方法就是一个final方法） final修饰类final修饰的类不可以有子类 immutable不可变类：当你获得这个类的一个实例引用时，你不可以改变这个实例的内容。不可变类的实例一但创建，其内在成员变量的值就不能被修改。 抽象类和接口的联系区别共同点： 1） 接口和抽象类都不能被实例化，它们都在继承树的顶端，用来被其他类实现和继承。 2） 接口和抽象类都可以包含抽象方法，实现接口或继承抽象类的普通子类都必须实现这些抽象方法。 设计目的： 接口主要体现一种规范，它类似于整个系统的“总纲”，它制定了系统各模块应该遵循的标准，因此一个系统中的接口不应该经常改变。 抽象类主要体现了一种模板式设计。可以认为是系统实现过程当中的中间产品。它已经实现了系统的部分功能（哪些已经提供实现的方法） 区别： 1）接口中只能包含抽象方法、静态方法和默认方法，不能为普通方法提供方法的实现；而抽象类则完全可以包含普通方法。 2）接口中只能定义静态常量，不能定义普通成员变量；抽象类里则可以定义普通成员变量，也可以定义静态常量。 3）接口里不包含构造器；抽象类里可以包含构造器；但是抽象类中的构造器不是用来创建对象，而是让其子类调用这些构造器来完成属于抽象类的初始化操作。 4）接口中不可以包含初始化块；但是抽象类中可以包含初始化块。 5）一个类最多只能有一个直接父类，包括抽象类；但一个类可以直接实现多个接口，通过实现多个接口可以弥补java单继承的不足。 什么时候用接口什么时候用抽象类？ 抽象类都是从一些相似的对象中抽象出来的一个相对无法具体描述的一个类，它的子类之间是有相似性的； 接口更侧重于对相同的动作进行抽象封装。当你关注一个事物的本质的时候，用抽象类；当你关注一个操作的时候，用接口。 对象的初始化过程1）初始化父类中的静态成员变量和静态代码块； 2）初始化子类中的静态成员变量和静态代码块； 3）初始化父类的普通成员变量和代码块，再执行父类的构造方法； 4）初始化子类的普通成员变量和代码块，再执行子类的构造方法； static修饰符static修饰变量1）对于静态变量在内存中只有一个拷贝（节省内存），JVM只为静态分配一次内存。 2）对于实例变量，每创建一个实例，就会为实例变量分配一次内存，实例变量可以在内存中有多个拷贝，互不影响（灵活）。 static方法静态方法中不能访问非静态成员方法和非静态成员变量，但是在非静态成员方法中是可以访问静态成员方法和变量的 static代码块static代码块是在类中独立于类成员的static语句块，可以有多个，位置可以随便放，它不在任何的方法体内，JVM加载类时会执行这些静态的代码块，如果static代码块有多个，JVM将按照它们在类中出现的先后顺序依次执行它们，每个代码块只会被执行一次。 关键的作用：用来形成静态代码块以优化程序性能。因为它只会在类加载的时候执行一次，所以能优化程序性能。 instanceof运算符编译时类型必须是如下3种情况： 1）要么与后面的类相同；2）要么是后面类型的父类；3）要么是后面类型的子类； 如果前面操作数的编译时类型与后面的类型没有任何关系，程序将没发通过编译。 运行阶段： 被转型变量所引用对象的实际类型必须是目标类型的实例，或者是目标类型的子类，实现类的实例，否则在运行时将引发ClassCastException异常。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>面试</tag>
      </tags>
  </entry>
</search>
